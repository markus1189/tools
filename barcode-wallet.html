<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#f97316">
    <title>Barcode Wallet</title>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #0a0a0a;
            --bg-card: #141414;
            --bg-card-hover: #1a1a1a;
            --bg-input: #1e1e1e;
            --border: #2a2a2a;
            --text: #e5e5e5;
            --text-muted: #888;
            --accent: #f97316;
            --accent-hover: #fb923c;
            --accent-dim: #c2410c;
            --danger: #ef4444;
            --danger-hover: #dc2626;
            --success: #22c55e;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .app-container {
            max-width: 768px;
            margin: 0 auto;
            padding: 1rem;
            padding-bottom: 120px;
        }

        /* Header */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding: 1rem 0;
        }

        h1 {
            font-size: 1.75rem;
            font-weight: 700;
            color: var(--accent);
        }

        .header-actions {
            display: flex;
            gap: 0.5rem;
        }

        /* Buttons */
        button {
            background: var(--bg-card);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 0.75rem 1rem;
            border-radius: 8px;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }

        button:hover {
            background: var(--bg-card-hover);
            border-color: var(--accent);
        }

        button:active {
            transform: scale(0.98);
        }

        .btn-primary {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
            font-weight: 600;
        }

        .btn-primary:hover {
            background: var(--accent-hover);
            border-color: var(--accent-hover);
        }

        .btn-danger {
            background: var(--danger);
            border-color: var(--danger);
            color: white;
        }

        .btn-danger:hover {
            background: var(--danger-hover);
            border-color: var(--danger-hover);
        }

        .btn-icon {
            padding: 0.5rem;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid var(--border);
        }

        .tab {
            flex: 1;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            color: var(--text-muted);
            padding: 0.75rem 1rem;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: -2px;
        }

        .tab:hover {
            color: var(--text);
            background: transparent;
        }

        .tab.active {
            color: var(--accent);
            border-bottom-color: var(--accent);
        }

        /* Search */
        .search-container {
            margin-bottom: 1.5rem;
        }

        input[type="text"],
        input[type="search"] {
            width: 100%;
            background: var(--bg-input);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 0.75rem 1rem;
            border-radius: 8px;
            font-size: 0.875rem;
            outline: none;
            font-family: inherit;
        }

        input:focus {
            border-color: var(--accent);
        }

        input::placeholder {
            color: var(--text-muted);
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 4rem 2rem;
        }

        .empty-state svg {
            width: 80px;
            height: 80px;
            margin-bottom: 1.5rem;
            opacity: 0.3;
        }

        .empty-state h2 {
            font-size: 1.25rem;
            margin-bottom: 0.5rem;
            color: var(--text-muted);
        }

        .empty-state p {
            color: var(--text-muted);
            margin-bottom: 2rem;
        }

        /* Grid View */
        .grid-view {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .barcode-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            position: relative;
        }

        .barcode-card:hover {
            background: var(--bg-card-hover);
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        .barcode-card.favorite {
            border-color: #fbbf24;
        }

        .favorite-badge {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            color: #fbbf24;
            font-size: 1rem;
        }

        .barcode-preview {
            width: 100%;
            height: 100px;
            background: white;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            padding: 0.25rem;
        }

        .barcode-preview canvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .barcode-card-info {
            flex: 1;
        }

        .barcode-name {
            font-weight: 600;
            font-size: 0.875rem;
            margin-bottom: 0.25rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .barcode-type {
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Action Bar (Fixed Bottom) */
        .action-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--bg-card);
            border-top: 1px solid var(--border);
            padding: 1rem;
            display: flex;
            gap: 0.75rem;
            justify-content: center;
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        .action-bar button {
            flex: 1;
            max-width: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .action-bar svg {
            width: 18px;
            height: 18px;
        }

        /* Modal */
        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 1rem;
        }

        .modal.hidden {
            display: none;
        }

        .modal-content {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 2rem;
            max-width: 500px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-content.fullscreen {
            max-width: 100%;
            max-height: 100%;
            height: 100%;
            border-radius: 0;
            background: #ffffff;
            color: #000000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .modal-header {
            margin-bottom: 1.5rem;
        }

        .modal-header h2 {
            font-size: 1.5rem;
            color: var(--accent);
            margin-bottom: 0.5rem;
        }

        .modal-header p {
            color: var(--text-muted);
            font-size: 0.875rem;
        }

        .modal-body {
            margin-bottom: 1.5rem;
        }

        .modal-footer {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
        }

        /* Form Elements */
        .form-group {
            margin-bottom: 1.25rem;
        }

        .form-group label {
            display: block;
            font-size: 0.875rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text);
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            background: var(--bg-input);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 0.75rem;
            border-radius: 8px;
            font-size: 0.875rem;
            outline: none;
            font-family: inherit;
        }

        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            border-color: var(--accent);
        }

        /* Display Modal */
        #display-modal .barcode-display {
            background: white;
            padding: 2rem;
            border-radius: 12px;
            margin-bottom: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #display-modal canvas {
            max-width: 100%;
            height: auto;
        }

        #display-modal .barcode-info {
            text-align: center;
            margin-bottom: 2rem;
        }

        #display-modal .barcode-info h2 {
            font-size: 1.5rem;
            color: #000;
            margin-bottom: 0.5rem;
        }

        #display-modal .barcode-info .barcode-data {
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            color: #666;
            margin-bottom: 0.5rem;
        }

        #display-modal .barcode-info .barcode-note {
            font-size: 0.875rem;
            color: #888;
            font-style: italic;
        }

        #display-modal .brightness-notice {
            background: #fff3cd;
            color: #856404;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            font-size: 0.875rem;
            margin-bottom: 2rem;
            text-align: center;
        }

        #display-modal .display-actions {
            position: fixed;
            bottom: 2rem;
            left: 0;
            right: 0;
            display: flex;
            gap: 0.75rem;
            justify-content: center;
            padding: 0 1rem;
        }

        #display-modal .display-actions button {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: none;
        }

        /* Navigation arrows */
        .nav-arrow {
            position: fixed;
            bottom: 7rem;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 1.25rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1001;
            transition: background 0.2s;
        }

        .nav-arrow:hover {
            background: rgba(0, 0, 0, 0.8);
        }

        .nav-arrow.disabled {
            opacity: 0.2;
            pointer-events: none;
        }

        .nav-arrow-left {
            left: 0.5rem;
        }

        .nav-arrow-right {
            right: 0.5rem;
        }

        /* Scanner Container */
        #qr-reader {
            width: 100%;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 1rem;
        }

        #qr-reader video {
            width: 100%;
            border-radius: 8px;
        }

        /* Utilities */
        .hidden {
            display: none !important;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        /* Install Button */
        #install-btn {
            background: var(--success);
            border-color: var(--success);
            color: white;
            font-weight: 600;
            font-size: 0.75rem;
            padding: 0.5rem 1rem;
        }

        #install-btn:hover {
            background: #16a34a;
            border-color: #16a34a;
        }

        /* Responsive */
        @media (max-width: 640px) {
            .app-container {
                padding: 0.5rem;
                padding-bottom: 100px;
            }

            h1 {
                font-size: 1.5rem;
            }

            .grid-view {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
                gap: 0.75rem;
            }

            .action-bar {
                padding: 0.75rem;
            }

            .action-bar button {
                font-size: 0.75rem;
                padding: 0.625rem 0.875rem;
            }
        }

        /* Diagnostic Overlay for Mobile */
        .diagnostic-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }

        .diagnostic-overlay.hidden {
            display: none;
        }

        .diagnostic-content {
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 1.5rem;
            max-width: 500px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .diagnostic-header {
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border);
        }

        .diagnostic-header h3 {
            color: var(--accent);
            font-size: 1.25rem;
            margin-bottom: 0.5rem;
        }

        .diagnostic-section {
            margin-bottom: 1rem;
            padding: 0.75rem;
            background: var(--bg-input);
            border-radius: 6px;
            font-size: 0.875rem;
        }

        .diagnostic-section h4 {
            color: var(--text);
            font-size: 0.875rem;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }

        .diagnostic-section p {
            color: var(--text-muted);
            margin: 0.25rem 0;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
        }

        .diagnostic-progress {
            color: var(--accent);
            font-weight: 600;
            font-size: 1rem;
            margin: 0.5rem 0;
        }

        .diagnostic-log {
            max-height: 200px;
            overflow-y: auto;
            background: var(--bg);
            padding: 0.75rem;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 0.75rem;
        }

        .diagnostic-log-entry {
            margin: 0.25rem 0;
            padding: 0.25rem 0;
        }

        .diagnostic-log-entry.success {
            color: var(--success);
        }

        .diagnostic-log-entry.error {
            color: var(--danger);
        }

        .diagnostic-log-entry.info {
            color: var(--text-muted);
        }

        .diagnostic-close {
            margin-top: 1rem;
            width: 100%;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <header>
            <h1>Barcode Wallet</h1>
            <div class="header-actions">
                <button id="install-btn" class="hidden" aria-label="Install app">Install</button>
                <button id="import-btn" class="btn-icon" aria-label="Import barcodes" title="Import">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="17 8 12 3 7 8"></polyline>
                        <line x1="12" y1="3" x2="12" y2="15"></line>
                    </svg>
                </button>
                <button id="export-btn" class="btn-icon" aria-label="Export barcodes" title="Export">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="7 10 12 15 17 10"></polyline>
                        <line x1="12" y1="15" x2="12" y2="3"></line>
                    </svg>
                </button>
            </div>
        </header>

        <!-- Tabs -->
        <div class="tabs">
            <button id="tab-active" class="tab active" data-tab="active">Active</button>
            <button id="tab-archived" class="tab" data-tab="archived">Archived</button>
        </div>

        <!-- Search -->
        <div class="search-container">
            <input type="search" id="search-input" placeholder="Search barcodes..." aria-label="Search barcodes">
        </div>

        <!-- Main View -->
        <main id="main-view">
            <!-- Empty State -->
            <div id="empty-state" class="empty-state">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="5" width="18" height="14" rx="2" ry="2"></rect>
                    <line x1="3" y1="10" x2="21" y2="10"></line>
                </svg>
                <h2>No barcodes yet</h2>
                <p>Scan or add your first barcode to get started</p>
                <button id="add-first-btn" class="btn-primary">Add Your First Barcode</button>
            </div>

            <!-- Grid View -->
            <div id="grid-view" class="grid-view hidden">
                <!-- Barcode cards will be rendered here -->
            </div>
        </main>
    </div>

    <!-- Bottom Action Bar -->
    <div class="action-bar">
        <button id="scan-btn" class="btn-primary">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path>
                <circle cx="12" cy="13" r="4"></circle>
            </svg>
            Scan
        </button>
        <button id="add-manual-btn">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <line x1="12" y1="5" x2="12" y2="19"></line>
                <line x1="5" y1="12" x2="19" y2="12"></line>
            </svg>
            Add Manually
        </button>
    </div>

    <!-- Scan Modal -->
    <div id="scan-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="scan-modal-title">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="scan-modal-title">Scan Barcode</h2>
                <p>Point your camera at a barcode</p>
            </div>
            <div class="modal-body">
                <div id="qr-reader"></div>
            </div>
            <div class="modal-footer">
                <button id="close-scan-btn">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Add/Edit Modal -->
    <div id="add-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="add-modal-title">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="add-modal-title">Add Barcode</h2>
                <p>Upload an image or enter details manually</p>
            </div>
            <div class="modal-body">
                <input type="file" id="barcode-file-input" accept="image/*" style="display: none;">
                <button id="upload-file-btn" class="btn-primary" style="width: 100%; display: flex; align-items: center; justify-content: center; gap: 0.5rem; margin-bottom: 1rem;">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="17 8 12 3 7 8"></polyline>
                        <line x1="12" y1="3" x2="12" y2="15"></line>
                    </svg>
                    Upload Image File
                </button>
                <div style="text-align: center; margin: 1rem 0;">
                    <span style="color: var(--text-muted); font-size: 0.875rem;">OR</span>
                </div>
                <form id="add-form">
                    <div class="form-group">
                        <label for="barcode-name">Name *</label>
                        <input type="text" id="barcode-name" placeholder="e.g., Gym Membership" required>
                    </div>
                    <div class="form-group">
                        <label for="barcode-type">Type</label>
                        <select id="barcode-type" required>
                            <option value="qr">QR Code</option>
                            <option value="ean13">EAN-13</option>
                            <option value="ean8">EAN-8</option>
                            <option value="upc">UPC-A</option>
                            <option value="code128">Code 128</option>
                            <option value="code39">Code 39</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="barcode-data">Barcode Data *</label>
                        <input type="text" id="barcode-data" placeholder="e.g., 1234567890123" required>
                    </div>
                    <div class="form-group">
                        <label for="barcode-notes">Notes (optional)</label>
                        <textarea id="barcode-notes" placeholder="Add any notes..."></textarea>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button id="cancel-add-btn">Cancel</button>
                <button id="save-barcode-btn" class="btn-primary">Save</button>
            </div>
        </div>
    </div>

    <!-- Display Modal -->
    <div id="display-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="display-modal-title">
        <div class="modal-content fullscreen">
            <div class="brightness-notice">
                Please maximize screen brightness for best scanning
            </div>

            <div class="barcode-display">
                <canvas id="barcode-canvas"></canvas>
            </div>

            <div class="barcode-info">
                <h2 id="display-barcode-name"></h2>
                <div class="barcode-data" id="display-barcode-data"></div>
                <div class="barcode-note" id="display-barcode-note"></div>
            </div>

            <!-- Navigation Arrows -->
            <button id="nav-prev" class="nav-arrow nav-arrow-left" aria-label="Previous barcode">‚Äπ</button>
            <button id="nav-next" class="nav-arrow nav-arrow-right" aria-label="Next barcode">‚Ä∫</button>

            <div class="display-actions">
                <button id="favorite-barcode-btn">‚≠ê Favorite</button>
                <button id="archive-barcode-btn">üì¶ Archive</button>
                <button id="delete-barcode-btn" class="btn-danger">Delete</button>
                <button id="close-display-btn">Close</button>
            </div>
        </div>
    </div>

    <!-- Screen Reader Announcements -->
    <div aria-live="polite" aria-atomic="true" class="sr-only" id="announcer"></div>

    <!-- Barcode Libraries -->
    <!-- Diagnostic Overlay for Mobile -->
    <div id="diagnostic-overlay" class="diagnostic-overlay hidden">
        <div class="diagnostic-content">
            <div class="diagnostic-header">
                <h3>Scan Diagnostics</h3>
            </div>
            <div class="diagnostic-section">
                <h4>File Info</h4>
                <p id="diag-file-name">-</p>
                <p id="diag-file-size">-</p>
                <p id="diag-file-type">-</p>
                <p id="diag-image-dimensions">-</p>
            </div>
            <div class="diagnostic-section">
                <h4>Image Preview</h4>
                <img id="diag-image-preview" style="max-width: 100%; height: auto; border-radius: 4px; background: white; padding: 0.5rem;" alt="Uploaded image preview">
            </div>
            <div class="diagnostic-section">
                <h4>Progress</h4>
                <p class="diagnostic-progress" id="diag-progress">Initializing...</p>
            </div>
            <div class="diagnostic-section">
                <h4>Detection Log</h4>
                <div class="diagnostic-log" id="diag-log">
                    <div class="diagnostic-log-entry info">Ready to scan...</div>
                </div>
            </div>
            <button id="close-diagnostic-btn" class="diagnostic-close btn-secondary">Close</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/jsbarcode@3.11.6/dist/JsBarcode.all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>

    <script>
        // ===========================
        // Constants & Configuration
        // ===========================
        const STORAGE_KEY = 'barcode-wallet-items';
        const SETTINGS_KEY = 'barcode-wallet-settings';
        const VERSION = 1;

        // ===========================
        // State Management
        // ===========================
        const state = {
            items: [],
            settings: {
                sortBy: 'createdAt',
                sortOrder: 'desc'
            },
            currentItem: null,
            currentItemIndex: -1,
            searchQuery: '',
            activeTab: 'active' // 'active' or 'archived'
        };

        // ===========================
        // localStorage Operations
        // ===========================
        function loadData() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (!saved) return [];

                const data = JSON.parse(saved);

                // Validate and sanitize items
                if (!Array.isArray(data)) {
                    console.warn('Invalid data format, resetting');
                    return [];
                }

                return data.filter(item => item.id && item.type && item.data).map(sanitizeItem);
            } catch (e) {
                console.error('Failed to load data:', e);
                return [];
            }
        }

        function saveData() {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(state.items));
            } catch (e) {
                console.error('Failed to save data:', e);
                if (e.name === 'QuotaExceededError') {
                    alert('Storage full! Please delete some items or export your data.');
                }
            }
        }

        function loadSettings() {
            try {
                const saved = localStorage.getItem(SETTINGS_KEY);
                if (!saved) return state.settings;
                return { ...state.settings, ...JSON.parse(saved) };
            } catch (e) {
                console.error('Failed to load settings:', e);
                return state.settings;
            }
        }

        function saveSettings() {
            try {
                localStorage.setItem(SETTINGS_KEY, JSON.stringify(state.settings));
            } catch (e) {
                console.error('Failed to save settings:', e);
            }
        }

        // ===========================
        // Data Sanitization
        // ===========================
        function sanitizeItem(item) {
            return {
                id: String(item.id).substring(0, 36),
                type: sanitizeBarcodeType(item.type),
                name: escapeHtml(String(item.name || 'Unnamed').substring(0, 100)),
                data: String(item.data).substring(0, 2000),
                notes: item.notes ? escapeHtml(String(item.notes).substring(0, 500)) : '',
                favorite: Boolean(item.favorite),
                archived: Boolean(item.archived),
                createdAt: parseInt(item.createdAt) || Date.now(),
                updatedAt: parseInt(item.updatedAt) || Date.now()
            };
        }

        function sanitizeBarcodeType(type) {
            const validTypes = ['qr', 'ean13', 'ean8', 'upc', 'code128', 'code39'];
            return validTypes.includes(type) ? type : 'qr';
        }

        function escapeHtml(unsafe) {
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substring(2);
        }

        function formatDate(timestamp) {
            const date = new Date(timestamp);
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${year}-${month}-${day} @ ${hours}:${minutes}`;
        }

        function timeAgo(timestamp) {
            const seconds = Math.floor((Date.now() - timestamp) / 1000);

            if (seconds < 60) return 'just now';

            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return `${minutes} minute${minutes !== 1 ? 's' : ''} ago`;

            const hours = Math.floor(minutes / 60);
            if (hours < 24) return `${hours} hour${hours !== 1 ? 's' : ''} ago`;

            const days = Math.floor(hours / 24);
            if (days < 30) return `${days} day${days !== 1 ? 's' : ''} ago`;

            const months = Math.floor(days / 30);
            if (months < 12) return `${months} month${months !== 1 ? 's' : ''} ago`;

            const years = Math.floor(days / 365);
            return `${years} year${years !== 1 ? 's' : ''} ago`;
        }

        // ===========================
        // CRUD Operations
        // ===========================
        function addItem(item) {
            const newItem = sanitizeItem({
                ...item,
                id: generateId(),
                createdAt: Date.now(),
                updatedAt: Date.now()
            });

            state.items.unshift(newItem);
            saveData();
            render();
            announce(`${newItem.name} added`);
        }

        function deleteItem(id) {
            const item = state.items.find(i => i.id === id);
            if (!item) return;

            if (!confirm(`Delete "${item.name}"?`)) return;

            state.items = state.items.filter(i => i.id !== id);
            saveData();
            render();
            announce(`${item.name} deleted`);
        }

        function updateItem(id, updates) {
            const index = state.items.findIndex(i => i.id === id);
            if (index === -1) return;

            state.items[index] = sanitizeItem({
                ...state.items[index],
                ...updates,
                updatedAt: Date.now()
            });

            saveData();
            render();
            announce(`${state.items[index].name} updated`);
        }

        // ===========================
        // Barcode Generation
        // ===========================
        function generateQRCode(canvas, data) {
            const qr = qrcode(0, 'M');
            qr.addData(data);
            qr.make();

            const ctx = canvas.getContext('2d');
            const moduleCount = qr.getModuleCount();
            const cellSize = canvas.width / moduleCount;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#000000';
            for (let row = 0; row < moduleCount; row++) {
                for (let col = 0; col < moduleCount; col++) {
                    if (qr.isDark(row, col)) {
                        ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
                    }
                }
            }
        }

        function generateBarcode(canvas, item) {
            try {
                const format = item.type.toUpperCase().replace('UPC', 'UPC');

                JsBarcode(canvas, item.data, {
                    format: format === 'QR' ? 'CODE128' : format,
                    width: 2,
                    height: 100,
                    displayValue: true,
                    fontSize: 14,
                    margin: 10,
                    background: '#ffffff'
                });
            } catch (err) {
                console.error('Barcode generation failed:', err);
                showFallbackDisplay(canvas, item);
            }
        }

        function generateBarcodePreview(canvas, item) {
            try {
                const format = item.type.toUpperCase().replace('UPC', 'UPC');

                JsBarcode(canvas, item.data, {
                    format: format === 'QR' ? 'CODE128' : format,
                    width: 1,
                    height: 30,
                    displayValue: false,
                    fontSize: 8,
                    margin: 2,
                    background: '#ffffff'
                });
            } catch (err) {
                console.error('Barcode preview generation failed:', err);
                showFallbackDisplay(canvas, item);
            }
        }

        function showFallbackDisplay(canvas, item) {
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#000000';
            ctx.font = '16px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(item.data, canvas.width / 2, canvas.height / 2);
        }

        function renderBarcodeToCanvas(canvas, item) {
            if (item.type === 'qr') {
                canvas.width = 300;
                canvas.height = 300;
                generateQRCode(canvas, item.data);
            } else {
                canvas.width = 400;
                canvas.height = 200;
                generateBarcode(canvas, item);
            }
        }

        // ===========================
        // Rendering
        // ===========================
        function render() {
            const filteredItems = getFilteredItems();
            const hasFilteredItems = filteredItems.length > 0;

            // Toggle empty state vs grid
            document.getElementById('empty-state').classList.toggle('hidden', hasFilteredItems);
            document.getElementById('grid-view').classList.toggle('hidden', !hasFilteredItems);

            if (hasFilteredItems) {
                renderGrid(filteredItems);
            } else {
                // Update empty state message based on tab
                const emptyState = document.getElementById('empty-state');
                const h2 = emptyState.querySelector('h2');
                const p = emptyState.querySelector('p');

                if (state.activeTab === 'archived') {
                    h2.textContent = 'No archived barcodes';
                    p.textContent = 'Archived barcodes will appear here';
                } else if (state.searchQuery) {
                    h2.textContent = 'No results';
                    p.textContent = 'Try a different search term';
                } else {
                    h2.textContent = 'No barcodes yet';
                    p.textContent = 'Scan or add your first barcode to get started';
                }
            }
        }

        function getFilteredItems() {
            let items = [...state.items];

            // Apply archive filter
            items = items.filter(item => {
                if (state.activeTab === 'archived') {
                    return item.archived === true;
                } else {
                    return !item.archived;
                }
            });

            // Apply search filter
            if (state.searchQuery) {
                const query = state.searchQuery.toLowerCase();
                items = items.filter(item =>
                    item.name.toLowerCase().includes(query) ||
                    item.data.toLowerCase().includes(query) ||
                    (item.notes && item.notes.toLowerCase().includes(query))
                );
            }

            // Sort: favorites first, then by createdAt
            items.sort((a, b) => {
                // Favorites first
                if (a.favorite && !b.favorite) return -1;
                if (!a.favorite && b.favorite) return 1;

                // Then by date (newest first)
                return b.createdAt - a.createdAt;
            });

            return items;
        }

        function renderGrid(items) {
            const grid = document.getElementById('grid-view');
            grid.innerHTML = '';

            if (items.length === 0 && state.searchQuery) {
                grid.innerHTML = '<p style="grid-column: 1/-1; text-align: center; color: var(--text-muted);">No barcodes match your search</p>';
                return;
            }

            items.forEach(item => {
                const card = createBarcodeCard(item);
                grid.appendChild(card);
            });
        }

        function createBarcodeCard(item) {
            const card = document.createElement('div');
            card.className = 'barcode-card' + (item.favorite ? ' favorite' : '');
            card.setAttribute('role', 'button');
            card.setAttribute('tabindex', '0');
            card.setAttribute('aria-label', `View ${item.name}`);

            const favoriteIcon = item.favorite ? '<span class="favorite-badge">‚≠ê</span>' : '';
            const dateStr = formatDate(item.createdAt);
            const timeAgoStr = timeAgo(item.createdAt);

            card.innerHTML = `
                ${favoriteIcon}
                <div class="barcode-preview">
                    <canvas data-id="${item.id}"></canvas>
                </div>
                <div class="barcode-card-info">
                    <div class="barcode-name">${item.name}</div>
                    <div class="barcode-type">${item.type.toUpperCase()}</div>
                    <div style="font-size: 0.7rem; color: var(--text-muted); margin-top: 0.25rem;">
                        ${dateStr}<br>${timeAgoStr}
                    </div>
                </div>
            `;

            card.addEventListener('click', () => displayBarcode(item));
            card.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    displayBarcode(item);
                }
            });

            // Generate preview in next frame
            requestAnimationFrame(() => {
                const canvas = card.querySelector('canvas');
                try {
                    if (item.type === 'qr') {
                        canvas.width = 80;
                        canvas.height = 80;
                        generateQRCode(canvas, item.data);
                    } else {
                        canvas.width = 110;
                        canvas.height = 50;
                        generateBarcodePreview(canvas, item);
                    }
                } catch (err) {
                    console.error('Preview generation failed:', err);
                }
            });

            return card;
        }

        // ===========================
        // Modal Management
        // ===========================
        function showModal(modalId) {
            const modal = document.getElementById(modalId);
            modal.classList.remove('hidden');
            modal.setAttribute('aria-hidden', 'false');

            // Focus first interactive element
            const focusable = modal.querySelectorAll('button, input, select, textarea');
            if (focusable.length) {
                setTimeout(() => focusable[0].focus(), 100);
            }
        }

        function hideModal(modalId) {
            const modal = document.getElementById(modalId);
            modal.classList.add('hidden');
            modal.setAttribute('aria-hidden', 'true');
        }

        function displayBarcode(item) {
            state.currentItem = item;

            // Find index in filtered items for navigation
            const filteredItems = getFilteredItems();
            state.currentItemIndex = filteredItems.findIndex(i => i.id === item.id);

            // Update display modal
            document.getElementById('display-barcode-name').textContent = item.name;
            document.getElementById('display-barcode-data').textContent = item.data;
            document.getElementById('display-barcode-note').textContent = item.notes || '';

            // Update favorite button
            const favoriteBtn = document.getElementById('favorite-barcode-btn');
            favoriteBtn.textContent = item.favorite ? '‚≠ê Unfavorite' : '‚≠ê Favorite';

            // Update archive button
            const archiveBtn = document.getElementById('archive-barcode-btn');
            archiveBtn.textContent = item.archived ? 'üì§ Unarchive' : 'üì¶ Archive';

            // Update navigation arrows
            const prevBtn = document.getElementById('nav-prev');
            const nextBtn = document.getElementById('nav-next');
            prevBtn.classList.toggle('disabled', state.currentItemIndex <= 0);
            nextBtn.classList.toggle('disabled', state.currentItemIndex >= filteredItems.length - 1);

            // Generate barcode
            const canvas = document.getElementById('barcode-canvas');
            renderBarcodeToCanvas(canvas, item);

            showModal('display-modal');
            announce(`Displaying ${item.name}`);

            // Request wake lock if supported
            requestWakeLock();
        }

        function navigateBarcode(direction) {
            const filteredItems = getFilteredItems();
            const newIndex = state.currentItemIndex + direction;

            if (newIndex >= 0 && newIndex < filteredItems.length) {
                displayBarcode(filteredItems[newIndex]);
            }
        }

        let wakeLock = null;

        async function requestWakeLock() {
            if ('wakeLock' in navigator) {
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                    console.log('Wake lock active');
                } catch (err) {
                    console.warn('Wake lock failed:', err);
                }
            }
        }

        function releaseWakeLock() {
            if (wakeLock) {
                wakeLock.release();
                wakeLock = null;
            }
        }

        // ===========================
        // Add/Edit Form
        // ===========================
        function showAddModal() {
            document.getElementById('add-modal-title').textContent = 'Add Barcode';
            document.getElementById('add-form').reset();
            showModal('add-modal');
        }

        function handleSaveBarcode() {
            const name = document.getElementById('barcode-name').value.trim();
            const type = document.getElementById('barcode-type').value;
            const data = document.getElementById('barcode-data').value.trim();
            const notes = document.getElementById('barcode-notes').value.trim();

            if (!name || !data) {
                alert('Please fill in required fields');
                return;
            }

            addItem({ name, type, data, notes });
            hideModal('add-modal');
        }

        function toggleFavorite() {
            if (!state.currentItem) return;

            updateItem(state.currentItem.id, {
                favorite: !state.currentItem.favorite
            });

            // Update current item reference
            state.currentItem.favorite = !state.currentItem.favorite;

            // Update button text
            const favoriteBtn = document.getElementById('favorite-barcode-btn');
            favoriteBtn.textContent = state.currentItem.favorite ? '‚≠ê Unfavorite' : '‚≠ê Favorite';

            announce(state.currentItem.favorite ? 'Added to favorites' : 'Removed from favorites');
        }

        function toggleArchive() {
            if (!state.currentItem) return;

            const willArchive = !state.currentItem.archived;

            updateItem(state.currentItem.id, {
                archived: willArchive
            });

            hideModal('display-modal');
            releaseWakeLock();

            announce(willArchive ? 'Archived' : 'Unarchived');
        }

        function switchTab(tab) {
            state.activeTab = tab;

            // Update tab buttons
            document.querySelectorAll('.tab').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === tab);
            });

            render();
        }

        // ===========================
        // Export/Import
        // ===========================
        function exportData() {
            if (state.items.length === 0) {
                alert('No barcodes to export');
                return;
            }

            const data = {
                version: VERSION,
                exportedAt: new Date().toISOString(),
                items: state.items
            };

            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = `barcode-wallet-${Date.now()}.json`;
            a.click();

            URL.revokeObjectURL(url);
            announce('Data exported successfully');
        }

        function importData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'application/json,.json';

            input.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);

                        // Validate structure
                        if (!data.items || !Array.isArray(data.items)) {
                            throw new Error('Invalid file format');
                        }

                        // Confirm before importing
                        const count = data.items.length;
                        const message = state.items.length > 0
                            ? `Import ${count} barcodes? This will ADD to your existing ${state.items.length} barcodes.`
                            : `Import ${count} barcodes?`;

                        if (!confirm(message)) return;

                        // Import items
                        let imported = 0;
                        data.items.forEach(item => {
                            if (item.name && item.data && item.type) {
                                const newItem = sanitizeItem({
                                    ...item,
                                    id: generateId(), // Generate new IDs
                                    createdAt: Date.now(),
                                    updatedAt: Date.now()
                                });
                                state.items.unshift(newItem);
                                imported++;
                            }
                        });

                        saveData();
                        render();
                        announce(`Imported ${imported} barcodes`);
                        alert(`Successfully imported ${imported} barcodes`);

                    } catch (err) {
                        console.error('Import failed:', err);
                        alert('Import failed: Invalid file format');
                    }
                };

                reader.readAsText(file);
            });

            input.click();
        }

        // ===========================
        // Screen Reader Announcements
        // ===========================
        function announce(message) {
            const announcer = document.getElementById('announcer');
            announcer.textContent = message;
            setTimeout(() => announcer.textContent = '', 1000);
        }

        // ===========================
        // Camera Scanning
        // ===========================
        let html5QrCode = null;
        let isScanning = false;

        function startScan() {
            // Check for HTTPS
            if (location.protocol !== 'https:' && !location.hostname.includes('localhost') && location.hostname !== '127.0.0.1') {
                alert('Camera scanning requires HTTPS. Please use "Add Manually" instead.');
                return;
            }

            showModal('scan-modal');
            isScanning = true;

            html5QrCode = new Html5Qrcode("qr-reader");

            const config = {
                fps: 10,
                qrbox: { width: 250, height: 250 },
                aspectRatio: 1.0
            };

            html5QrCode.start(
                { facingMode: "environment" }, // Rear camera
                config,
                onScanSuccess,
                onScanFailure
            ).catch(err => {
                console.error('Camera error:', err);
                let message = 'Camera access failed. ';

                if (err.name === 'NotAllowedError') {
                    message += 'Please grant camera permissions and try again.';
                } else if (err.name === 'NotFoundError') {
                    message += 'No camera found.';
                } else {
                    message += 'Please use "Add Manually" instead.';
                }

                alert(message);
                stopScan();
            });
        }

        function onScanSuccess(decodedText, decodedResult) {
            if (!isScanning) return;

            // Vibrate if supported
            if (navigator.vibrate) {
                navigator.vibrate(200);
            }

            // Stop scanning
            stopScan();

            // Detect barcode type
            const detectedType = detectBarcodeType(decodedText, decodedResult.result?.format);

            // Pre-fill add modal
            document.getElementById('add-modal-title').textContent = 'Scanned Barcode';
            document.getElementById('barcode-type').value = detectedType;
            document.getElementById('barcode-data').value = decodedText;
            document.getElementById('barcode-name').value = '';
            document.getElementById('barcode-notes').value = '';

            showModal('add-modal');
            announce('Barcode scanned successfully');
        }

        function onScanFailure(error) {
            // Silent - scanning in progress
        }

        function stopScan() {
            isScanning = false;

            if (html5QrCode) {
                html5QrCode.stop().then(() => {
                    html5QrCode.clear();
                    hideModal('scan-modal');
                }).catch(err => {
                    console.error('Error stopping scan:', err);
                    hideModal('scan-modal');
                });
            } else {
                hideModal('scan-modal');
            }
        }

        function handleFileUpload() {
            const fileInput = document.getElementById('barcode-file-input');
            fileInput.click();
        }

        function processUploadedFile(file) {
            if (!file) return;

            // Validate file type
            if (!file.type.startsWith('image/')) {
                alert('Please select an image file.');
                return;
            }

            // Show loading state
            const uploadBtn = document.getElementById('upload-file-btn');
            const originalBtnText = uploadBtn.innerHTML;
            uploadBtn.disabled = true;
            uploadBtn.innerHTML = '<span>Scanning image...</span>';

            // Show diagnostic overlay
            showDiagnosticOverlay();

            // Update file diagnostics (including image preview)
            updateDiagnosticFile(file);

            // Log file diagnostics (for desktop users)
            console.log('=== File Upload Diagnostics ===');
            console.log('File name:', file.name);
            console.log('File size:', (file.size / 1024).toFixed(2), 'KB');
            console.log('File type:', file.type);

            // Create a temporary element for file scanning to avoid conflicts
            const tempDiv = document.createElement('div');
            tempDiv.id = 'temp-qr-reader';
            tempDiv.style.display = 'none';
            document.body.appendChild(tempDiv);

            // Progress callback to update UI
            const updateProgress = (current, total, strategyName) => {
                uploadBtn.innerHTML = `<span>Trying ${current}/${total}: ${strategyName}</span>`;
                updateDiagnosticProgress(current, total, strategyName);
            };

            // Try scanning with multiple strategies
            attemptFileScan(file, tempDiv, updateProgress)
                .then(result => {
                    // Cleanup temp element
                    if (document.body.contains(tempDiv)) {
                        document.body.removeChild(tempDiv);
                    }

                    // Restore button
                    uploadBtn.disabled = false;
                    uploadBtn.innerHTML = originalBtnText;

                    // Hide diagnostic overlay on success
                    hideDiagnosticOverlay();

                    // Vibrate if supported
                    if (navigator.vibrate) {
                        navigator.vibrate(200);
                    }

                    // Detect barcode type
                    const detectedType = detectBarcodeType(result.decodedText, result.format);

                    // Pre-fill form fields (add modal is already open)
                    document.getElementById('add-modal-title').textContent = 'Scanned Barcode from File';
                    document.getElementById('barcode-type').value = detectedType;
                    document.getElementById('barcode-data').value = result.decodedText;
                    // Keep existing name and notes if user already entered them
                    if (!document.getElementById('barcode-name').value) {
                        document.getElementById('barcode-name').value = '';
                    }

                    announce('Barcode scanned successfully from file');
                })
                .catch(err => {
                    // Cleanup temp element
                    if (document.body.contains(tempDiv)) {
                        document.body.removeChild(tempDiv);
                    }

                    // Restore button
                    uploadBtn.disabled = false;
                    uploadBtn.innerHTML = originalBtnText;

                    console.error('File scan error:', err);

                    // Update diagnostic with error
                    addDiagnosticLog('‚ùå All strategies failed', 'error');
                    updateDiagnosticProgress(0, 0, 'Detection failed - see log above');

                    // Keep diagnostic overlay open so user can see what happened
                    // They can close it manually with the close button
                });
        }

        async function attemptFileScan(file, tempDiv, progressCallback) {
            // Optimized scanning strategies - most effective preprocessing methods
            // Now includes color inversion for white-on-black QR codes
            const strategies = [
                { name: 'Standard scan (all formats)', fn: () => basicScan(file, tempDiv, true) },
                { name: 'QR-only mode', fn: () => basicScan(file, tempDiv, false) },
                { name: 'Inverted colors', fn: () => scanWithInversion(file, tempDiv) },
                { name: '2x upscaling', fn: () => scanWithScale(file, tempDiv, 2.0) },
                { name: 'Contrast enhancement', fn: () => scanWithContrast(file, tempDiv, 1.5) },
                { name: 'Sharpening filter', fn: () => scanWithSharpening(file, tempDiv) },
                { name: 'Rotation 180¬∞', fn: () => scanWithRotation(file, tempDiv, 180) },
                { name: 'Combined: scale + contrast + sharpen', fn: () => scanWithCombinedProcessing(file, tempDiv) }
            ];

            console.log(`Starting scan with ${strategies.length} strategies...`);
            addDiagnosticLog(`Starting scan with ${strategies.length} strategies...`, 'info');

            // Try each strategy sequentially
            for (let i = 0; i < strategies.length; i++) {
                const strategy = strategies[i];
                const startTime = performance.now();
                try {
                    // Update progress UI
                    if (progressCallback) {
                        progressCallback(i + 1, strategies.length, strategy.name);
                    }

                    console.log(`Trying strategy ${i + 1}/${strategies.length}: ${strategy.name}...`);
                    const result = await strategy.fn();
                    const duration = (performance.now() - startTime).toFixed(0);
                    console.log(`‚úì Success with: ${strategy.name} (${duration}ms)`);
                    addDiagnosticLog(`‚úì ${strategy.name} (${duration}ms)`, 'success');
                    return result;
                } catch (err) {
                    const duration = (performance.now() - startTime).toFixed(0);
                    console.log(`‚úó Failed: ${strategy.name} (${duration}ms) -`, err.message);
                    addDiagnosticLog(`‚úó ${strategy.name} (${duration}ms)`, 'error');
                    // Continue to next strategy
                }
            }

            // All strategies failed
            console.error('All strategies exhausted without success');
            throw new Error('All scan strategies failed');
        }

        async function basicScan(file, tempDiv, decodeAllFormats) {
            // Load image to get dimensions for diagnostics
            const dataUrl = await readFileAsDataUrl(file);
            const img = await loadImage(dataUrl);
            const dimensions = `${img.width}x${img.height}px`;
            console.log(`  Image dimensions: ${dimensions}`);
            updateDiagnosticDimensions(dimensions);

            tempDiv.innerHTML = '';
            const scanner = new Html5Qrcode("temp-qr-reader");
            console.log(`  Scanning with decodeAllFormats=${decodeAllFormats}`);
            const result = await scanner.scanFile(file, decodeAllFormats);
            await scanner.clear().catch(() => {});
            console.log(`  Decoded result:`, result);
            return { decodedText: result, format: null };
        }

        async function scanWithScale(file, tempDiv, scale) {
            const scaledFile = await preprocessAndScaleImage(file, scale);
            tempDiv.innerHTML = '';
            const scanner = new Html5Qrcode("temp-qr-reader");
            const result = await scanner.scanFile(scaledFile, true);
            await scanner.clear().catch(() => {});
            return { decodedText: result, format: null };
        }

        async function scanWithInversion(file, tempDiv) {
            const invertedFile = await invertImageColors(file);
            tempDiv.innerHTML = '';
            const scanner = new Html5Qrcode("temp-qr-reader");
            const result = await scanner.scanFile(invertedFile, true);
            await scanner.clear().catch(() => {});
            return { decodedText: result, format: null };
        }

        async function scanWithContrast(file, tempDiv, contrastLevel) {
            const enhancedFile = await enhanceImageContrast(file, contrastLevel);
            tempDiv.innerHTML = '';
            const scanner = new Html5Qrcode("temp-qr-reader");
            const result = await scanner.scanFile(enhancedFile, true);
            await scanner.clear().catch(() => {});
            return { decodedText: result, format: null };
        }

        async function scanWithSharpening(file, tempDiv) {
            const sharpenedFile = await applySharpeningFilter(file);
            tempDiv.innerHTML = '';
            const scanner = new Html5Qrcode("temp-qr-reader");
            const result = await scanner.scanFile(sharpenedFile, true);
            await scanner.clear().catch(() => {});
            return { decodedText: result, format: null };
        }

        async function scanWithGrayscale(file, tempDiv) {
            const grayscaleFile = await convertToOptimizedGrayscale(file);
            tempDiv.innerHTML = '';
            const scanner = new Html5Qrcode("temp-qr-reader");
            const result = await scanner.scanFile(grayscaleFile, true);
            await scanner.clear().catch(() => {});
            return { decodedText: result, format: null };
        }

        async function scanWithAdaptiveThreshold(file, tempDiv) {
            const thresholdFile = await applyAdaptiveThreshold(file);
            tempDiv.innerHTML = '';
            const scanner = new Html5Qrcode("temp-qr-reader");
            const result = await scanner.scanFile(thresholdFile, true);
            await scanner.clear().catch(() => {});
            return { decodedText: result, format: null };
        }

        async function scanWithBrightnessNormalization(file, tempDiv) {
            const normalizedFile = await normalizeBrightness(file);
            tempDiv.innerHTML = '';
            const scanner = new Html5Qrcode("temp-qr-reader");
            const result = await scanner.scanFile(normalizedFile, true);
            await scanner.clear().catch(() => {});
            return { decodedText: result, format: null };
        }

        async function scanWithGammaCorrection(file, tempDiv, gamma) {
            const correctedFile = await applyGammaCorrection(file, gamma);
            tempDiv.innerHTML = '';
            const scanner = new Html5Qrcode("temp-qr-reader");
            const result = await scanner.scanFile(correctedFile, true);
            await scanner.clear().catch(() => {});
            return { decodedText: result, format: null };
        }

        async function scanWithEdgeEnhancement(file, tempDiv) {
            const enhancedFile = await enhanceEdges(file);
            tempDiv.innerHTML = '';
            const scanner = new Html5Qrcode("temp-qr-reader");
            const result = await scanner.scanFile(enhancedFile, true);
            await scanner.clear().catch(() => {});
            return { decodedText: result, format: null };
        }

        async function scanWithCombinedProcessing(file, tempDiv) {
            const processedFile = await applyCombinedProcessing(file);
            tempDiv.innerHTML = '';
            const scanner = new Html5Qrcode("temp-qr-reader");
            const result = await scanner.scanFile(processedFile, true);
            await scanner.clear().catch(() => {});
            return { decodedText: result, format: null };
        }

        async function scanWithRotation(file, tempDiv, degrees) {
            const rotatedFile = await rotateImage(file, degrees);
            tempDiv.innerHTML = '';
            const scanner = new Html5Qrcode("temp-qr-reader");
            const result = await scanner.scanFile(rotatedFile, true);
            await scanner.clear().catch(() => {});
            return { decodedText: result, format: null };
        }

        async function scanWithHistogramEqualization(file, tempDiv) {
            const equalizedFile = await applyHistogramEqualization(file);
            tempDiv.innerHTML = '';
            const scanner = new Html5Qrcode("temp-qr-reader");
            const result = await scanner.scanFile(equalizedFile, true);
            await scanner.clear().catch(() => {});
            return { decodedText: result, format: null };
        }

        async function preprocessAndScaleImage(file, scale) {
            const dataUrl = await readFileAsDataUrl(file);
            const img = await loadImage(dataUrl);

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = img.width * scale;
            canvas.height = img.height * scale;

            // Use high-quality scaling
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            return await canvasToBlob(canvas);
        }

        async function invertImageColors(file) {
            const dataUrl = await readFileAsDataUrl(file);
            const img = await loadImage(dataUrl);

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = img.width;
            canvas.height = img.height;

            ctx.drawImage(img, 0, 0);

            // Invert colors
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                data[i] = 255 - data[i];         // R
                data[i + 1] = 255 - data[i + 1]; // G
                data[i + 2] = 255 - data[i + 2]; // B
                // Alpha channel (i+3) stays the same
            }

            ctx.putImageData(imageData, 0, 0);

            return await canvasToBlob(canvas);
        }

        async function enhanceImageContrast(file, contrastLevel = 1.5) {
            const dataUrl = await readFileAsDataUrl(file);
            const img = await loadImage(dataUrl);

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            // Scale up 2x for better detection
            canvas.width = img.width * 2;
            canvas.height = img.height * 2;

            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            // Enhance contrast
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // Increase contrast by stretching histogram
            const factor = (259 * (contrastLevel + 255)) / (255 * (259 - contrastLevel));

            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, Math.max(0, factor * (data[i] - 128) + 128));       // R
                data[i + 1] = Math.min(255, Math.max(0, factor * (data[i + 1] - 128) + 128)); // G
                data[i + 2] = Math.min(255, Math.max(0, factor * (data[i + 2] - 128) + 128)); // B
            }

            ctx.putImageData(imageData, 0, 0);

            return await canvasToBlob(canvas);
        }

        async function applySharpeningFilter(file) {
            const dataUrl = await readFileAsDataUrl(file);
            const img = await loadImage(dataUrl);

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = img.width * 2;
            canvas.height = img.height * 2;

            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const w = canvas.width;
            const h = canvas.height;

            // Sharpening kernel
            const kernel = [
                0, -1, 0,
                -1, 5, -1,
                0, -1, 0
            ];

            const output = new Uint8ClampedArray(data);

            for (let y = 1; y < h - 1; y++) {
                for (let x = 1; x < w - 1; x++) {
                    for (let c = 0; c < 3; c++) { // RGB only
                        let sum = 0;
                        for (let ky = -1; ky <= 1; ky++) {
                            for (let kx = -1; kx <= 1; kx++) {
                                const idx = ((y + ky) * w + (x + kx)) * 4 + c;
                                const kernelIdx = (ky + 1) * 3 + (kx + 1);
                                sum += data[idx] * kernel[kernelIdx];
                            }
                        }
                        const outIdx = (y * w + x) * 4 + c;
                        output[outIdx] = Math.min(255, Math.max(0, sum));
                    }
                }
            }

            const sharpened = new ImageData(output, w, h);
            ctx.putImageData(sharpened, 0, 0);

            return await canvasToBlob(canvas);
        }

        async function convertToOptimizedGrayscale(file) {
            const dataUrl = await readFileAsDataUrl(file);
            const img = await loadImage(dataUrl);

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = img.width * 2;
            canvas.height = img.height * 2;

            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // Convert to grayscale using luminosity method
            for (let i = 0; i < data.length; i += 4) {
                const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                data[i] = data[i + 1] = data[i + 2] = gray;
            }

            ctx.putImageData(imageData, 0, 0);

            return await canvasToBlob(canvas);
        }

        async function applyAdaptiveThreshold(file) {
            const dataUrl = await readFileAsDataUrl(file);
            const img = await loadImage(dataUrl);

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = img.width * 3;
            canvas.height = img.height * 3;

            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const w = canvas.width;
            const h = canvas.height;

            // Convert to grayscale first
            const gray = new Uint8Array(w * h);
            for (let i = 0; i < data.length; i += 4) {
                const idx = i / 4;
                gray[idx] = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
            }

            // Apply adaptive threshold
            const blockSize = 15;
            const C = 10;

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    let sum = 0;
                    let count = 0;

                    // Calculate local mean
                    for (let dy = -blockSize; dy <= blockSize; dy++) {
                        for (let dx = -blockSize; dx <= blockSize; dx++) {
                            const ny = y + dy;
                            const nx = x + dx;
                            if (ny >= 0 && ny < h && nx >= 0 && nx < w) {
                                sum += gray[ny * w + nx];
                                count++;
                            }
                        }
                    }

                    const mean = sum / count;
                    const threshold = mean - C;
                    const pixelIdx = y * w + x;
                    const value = gray[pixelIdx] > threshold ? 255 : 0;

                    const dataIdx = pixelIdx * 4;
                    data[dataIdx] = data[dataIdx + 1] = data[dataIdx + 2] = value;
                }
            }

            ctx.putImageData(imageData, 0, 0);

            return await canvasToBlob(canvas);
        }

        async function normalizeBrightness(file) {
            const dataUrl = await readFileAsDataUrl(file);
            const img = await loadImage(dataUrl);

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = img.width * 2;
            canvas.height = img.height * 2;

            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // Calculate average brightness
            let sum = 0;
            for (let i = 0; i < data.length; i += 4) {
                sum += (data[i] + data[i + 1] + data[i + 2]) / 3;
            }
            const avgBrightness = sum / (data.length / 4);

            // Target brightness
            const targetBrightness = 128;
            const adjustment = targetBrightness - avgBrightness;

            // Adjust brightness
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, Math.max(0, data[i] + adjustment));
                data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + adjustment));
                data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + adjustment));
            }

            ctx.putImageData(imageData, 0, 0);

            return await canvasToBlob(canvas);
        }

        async function applyGammaCorrection(file, gamma) {
            const dataUrl = await readFileAsDataUrl(file);
            const img = await loadImage(dataUrl);

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = img.width * 2;
            canvas.height = img.height * 2;

            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // Build lookup table
            const lut = new Uint8Array(256);
            for (let i = 0; i < 256; i++) {
                lut[i] = Math.pow(i / 255, 1 / gamma) * 255;
            }

            // Apply gamma correction
            for (let i = 0; i < data.length; i += 4) {
                data[i] = lut[data[i]];
                data[i + 1] = lut[data[i + 1]];
                data[i + 2] = lut[data[i + 2]];
            }

            ctx.putImageData(imageData, 0, 0);

            return await canvasToBlob(canvas);
        }

        async function enhanceEdges(file) {
            const dataUrl = await readFileAsDataUrl(file);
            const img = await loadImage(dataUrl);

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = img.width * 2;
            canvas.height = img.height * 2;

            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const w = canvas.width;
            const h = canvas.height;

            // Edge detection kernel (Laplacian)
            const kernel = [
                -1, -1, -1,
                -1, 8, -1,
                -1, -1, -1
            ];

            const output = new Uint8ClampedArray(data);

            for (let y = 1; y < h - 1; y++) {
                for (let x = 1; x < w - 1; x++) {
                    for (let c = 0; c < 3; c++) {
                        let sum = 0;
                        for (let ky = -1; ky <= 1; ky++) {
                            for (let kx = -1; kx <= 1; kx++) {
                                const idx = ((y + ky) * w + (x + kx)) * 4 + c;
                                const kernelIdx = (ky + 1) * 3 + (kx + 1);
                                sum += data[idx] * kernel[kernelIdx];
                            }
                        }
                        const outIdx = (y * w + x) * 4 + c;
                        // Add edges back to original
                        output[outIdx] = Math.min(255, Math.max(0, data[outIdx] + sum * 0.5));
                    }
                }
            }

            const enhanced = new ImageData(output, w, h);
            ctx.putImageData(enhanced, 0, 0);

            return await canvasToBlob(canvas);
        }

        async function applyCombinedProcessing(file) {
            const dataUrl = await readFileAsDataUrl(file);
            const img = await loadImage(dataUrl);

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            // 3x scaling for combined approach
            canvas.width = img.width * 3;
            canvas.height = img.height * 3;

            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            let data = imageData.data;

            // Step 1: Contrast enhancement
            const contrast = 1.8;
            const factor = (259 * (contrast + 255)) / (255 * (259 - contrast));
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, Math.max(0, factor * (data[i] - 128) + 128));
                data[i + 1] = Math.min(255, Math.max(0, factor * (data[i + 1] - 128) + 128));
                data[i + 2] = Math.min(255, Math.max(0, factor * (data[i + 2] - 128) + 128));
            }

            ctx.putImageData(imageData, 0, 0);

            // Step 2: Sharpening
            imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            data = imageData.data;
            const w = canvas.width;
            const h = canvas.height;

            const kernel = [0, -1, 0, -1, 5, -1, 0, -1, 0];
            const output = new Uint8ClampedArray(data);

            for (let y = 1; y < h - 1; y++) {
                for (let x = 1; x < w - 1; x++) {
                    for (let c = 0; c < 3; c++) {
                        let sum = 0;
                        for (let ky = -1; ky <= 1; ky++) {
                            for (let kx = -1; kx <= 1; kx++) {
                                const idx = ((y + ky) * w + (x + kx)) * 4 + c;
                                const kernelIdx = (ky + 1) * 3 + (kx + 1);
                                sum += data[idx] * kernel[kernelIdx];
                            }
                        }
                        const outIdx = (y * w + x) * 4 + c;
                        output[outIdx] = Math.min(255, Math.max(0, sum));
                    }
                }
            }

            const sharpened = new ImageData(output, w, h);
            ctx.putImageData(sharpened, 0, 0);

            return await canvasToBlob(canvas);
        }

        async function rotateImage(file, degrees) {
            const dataUrl = await readFileAsDataUrl(file);
            const img = await loadImage(dataUrl);

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            // Scale up 2x
            const scale = 2;
            const radians = (degrees * Math.PI) / 180;

            if (degrees === 90 || degrees === 270) {
                canvas.width = img.height * scale;
                canvas.height = img.width * scale;
            } else {
                canvas.width = img.width * scale;
                canvas.height = img.height * scale;
            }

            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.rotate(radians);
            ctx.drawImage(img, -img.width * scale / 2, -img.height * scale / 2, img.width * scale, img.height * scale);

            return await canvasToBlob(canvas);
        }

        async function applyHistogramEqualization(file) {
            const dataUrl = await readFileAsDataUrl(file);
            const img = await loadImage(dataUrl);

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = img.width * 2;
            canvas.height = img.height * 2;

            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // Build histogram for each channel
            const histR = new Array(256).fill(0);
            const histG = new Array(256).fill(0);
            const histB = new Array(256).fill(0);

            for (let i = 0; i < data.length; i += 4) {
                histR[data[i]]++;
                histG[data[i + 1]]++;
                histB[data[i + 2]]++;
            }

            // Calculate cumulative distribution
            const cdfR = new Array(256);
            const cdfG = new Array(256);
            const cdfB = new Array(256);

            cdfR[0] = histR[0];
            cdfG[0] = histG[0];
            cdfB[0] = histB[0];

            for (let i = 1; i < 256; i++) {
                cdfR[i] = cdfR[i - 1] + histR[i];
                cdfG[i] = cdfG[i - 1] + histG[i];
                cdfB[i] = cdfB[i - 1] + histB[i];
            }

            // Normalize
            const totalPixels = data.length / 4;
            const lutR = cdfR.map(v => Math.round((v / totalPixels) * 255));
            const lutG = cdfG.map(v => Math.round((v / totalPixels) * 255));
            const lutB = cdfB.map(v => Math.round((v / totalPixels) * 255));

            // Apply equalization
            for (let i = 0; i < data.length; i += 4) {
                data[i] = lutR[data[i]];
                data[i + 1] = lutG[data[i + 1]];
                data[i + 2] = lutB[data[i + 2]];
            }

            ctx.putImageData(imageData, 0, 0);

            return await canvasToBlob(canvas);
        }

        function canvasToBlob(canvas) {
            return new Promise((resolve) => {
                canvas.toBlob(resolve, 'image/png');
            });
        }

        function readFileAsDataUrl(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = src;
            });
        }

        function detectBarcodeType(data, scannedFormat) {
            // Normalize input
            const normalizedData = String(data || '').trim();
            if (!normalizedData) return 'qr';

            // Use scanned format if available and reliable
            if (scannedFormat) {
                const formatMap = {
                    'QR_CODE': 'qr',
                    'EAN_13': 'ean13',
                    'EAN_8': 'ean8',
                    'UPC_A': 'upc',
                    'UPC_E': 'upc',
                    'CODE_128': 'code128',
                    'CODE_39': 'code39',
                    'CODE_93': 'code128', // Fallback to code128
                    'ITF': 'code128', // Interleaved 2 of 5, fallback
                    'CODABAR': 'code39' // Fallback to code39
                };

                const mappedFormat = formatMap[scannedFormat] || formatMap[scannedFormat.toUpperCase()];
                if (mappedFormat) {
                    // Validate that the format makes sense for the data
                    if (validateBarcodeFormat(normalizedData, mappedFormat)) {
                        return mappedFormat;
                    }
                }
            }

            // Pattern-based detection with validation
            // EAN-13: 13 digits, checksum validation
            if (/^\d{13}$/.test(normalizedData)) {
                return 'ean13';
            }

            // EAN-8: 8 digits
            if (/^\d{8}$/.test(normalizedData)) {
                return 'ean8';
            }

            // UPC-A: 12 digits
            if (/^\d{12}$/.test(normalizedData)) {
                return 'upc';
            }

            // UPC-E: 6-8 digits
            if (/^\d{6,8}$/.test(normalizedData)) {
                return 'upc';
            }

            // Code 39: Alphanumeric with special chars
            if (/^[A-Z0-9\-\.\$\/\+\%\s]+$/i.test(normalizedData) && normalizedData.length <= 43) {
                // Prefer Code 39 for shorter alphanumeric codes
                return 'code39';
            }

            // Code 128: More flexible, handles ASCII
            if (/^[\x20-\x7E]+$/.test(normalizedData) && normalizedData.length <= 80) {
                // Check if it looks like a structured barcode (shipping, product codes)
                if (/^[A-Z0-9\-\.\s]+$/i.test(normalizedData)) {
                    return 'code128';
                }
            }

            // Complex data, URLs, special characters -> QR Code
            if (
                normalizedData.includes('://') ||  // URLs
                normalizedData.includes('\n') ||   // Multi-line
                normalizedData.length > 80 ||      // Long data
                /[^\x20-\x7E]/.test(normalizedData) // Non-ASCII
            ) {
                return 'qr';
            }

            // Default to QR for safety (most versatile)
            return 'qr';
        }

        function validateBarcodeFormat(data, format) {
            const normalizedData = String(data || '').trim();

            switch (format) {
                case 'ean13':
                    return /^\d{13}$/.test(normalizedData);
                case 'ean8':
                    return /^\d{8}$/.test(normalizedData);
                case 'upc':
                    return /^\d{6,12}$/.test(normalizedData);
                case 'code39':
                    return /^[A-Z0-9\-\.\$\/\+\%\s]+$/i.test(normalizedData) && normalizedData.length <= 43;
                case 'code128':
                    return /^[\x20-\x7E]+$/.test(normalizedData) && normalizedData.length <= 80;
                case 'qr':
                    return true; // QR can handle anything
                default:
                    return false;
            }
        }

        // ===========================
        // Touch/Swipe Support
        // ===========================
        // Swipe gestures removed - use navigation arrows instead

        // ===========================
        // Event Listeners
        // ===========================
        function initEventListeners() {
            // Tabs
            document.getElementById('tab-active').addEventListener('click', () => switchTab('active'));
            document.getElementById('tab-archived').addEventListener('click', () => switchTab('archived'));

            // Action buttons
            document.getElementById('scan-btn').addEventListener('click', startScan);
            document.getElementById('close-scan-btn').addEventListener('click', stopScan);
            document.getElementById('close-diagnostic-btn').addEventListener('click', hideDiagnosticOverlay);

            document.getElementById('add-manual-btn').addEventListener('click', showAddModal);
            document.getElementById('add-first-btn').addEventListener('click', showAddModal);

            // File upload
            document.getElementById('upload-file-btn').addEventListener('click', handleFileUpload);
            document.getElementById('barcode-file-input').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    processUploadedFile(file);
                }
                // Reset input so same file can be selected again
                e.target.value = '';
            });

            // Modal buttons
            document.getElementById('save-barcode-btn').addEventListener('click', handleSaveBarcode);
            document.getElementById('cancel-add-btn').addEventListener('click', () => hideModal('add-modal'));

            document.getElementById('favorite-barcode-btn').addEventListener('click', toggleFavorite);
            document.getElementById('archive-barcode-btn').addEventListener('click', toggleArchive);

            document.getElementById('close-display-btn').addEventListener('click', () => {
                hideModal('display-modal');
                releaseWakeLock();
            });

            document.getElementById('delete-barcode-btn').addEventListener('click', () => {
                if (state.currentItem) {
                    deleteItem(state.currentItem.id);
                    hideModal('display-modal');
                    releaseWakeLock();
                }
            });

            // Navigation arrows
            document.getElementById('nav-prev').addEventListener('click', () => navigateBarcode(-1));
            document.getElementById('nav-next').addEventListener('click', () => navigateBarcode(1));

            // Search
            document.getElementById('search-input').addEventListener('input', (e) => {
                state.searchQuery = e.target.value;
                render();
            });

            // Export/Import
            document.getElementById('export-btn').addEventListener('click', exportData);
            document.getElementById('import-btn').addEventListener('click', importData);

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    hideModal('scan-modal');
                    hideModal('add-modal');
                    hideModal('display-modal');
                    releaseWakeLock();
                }

                // Arrow keys for navigation in display modal
                if (!document.getElementById('display-modal').classList.contains('hidden')) {
                    if (e.key === 'ArrowLeft') {
                        e.preventDefault();
                        navigateBarcode(-1);
                    } else if (e.key === 'ArrowRight') {
                        e.preventDefault();
                        navigateBarcode(1);
                    }
                }
            });
        }

        // ===========================
        // PWA Features
        // ===========================
        function generateManifest() {
            const manifest = {
                name: "Barcode Wallet",
                short_name: "Barcodes",
                description: "Store and display loyalty cards, membership barcodes, and QR codes offline",
                start_url: window.location.pathname,
                scope: window.location.pathname.replace('barcode-wallet.html', ''),
                display: "standalone",
                orientation: "portrait",
                theme_color: "#f97316",
                background_color: "#0a0a0a",
                categories: ["utilities", "lifestyle"],
                icons: [
                    {
                        src: generateIconDataUrl(),
                        sizes: "512x512",
                        type: "image/svg+xml",
                        purpose: "any maskable"
                    }
                ]
            };

            const json = JSON.stringify(manifest);
            const base64 = btoa(unescape(encodeURIComponent(json)));
            const dataUrl = `data:application/json;charset=utf-8;base64,${base64}`;

            const link = document.createElement('link');
            link.rel = 'manifest';
            link.href = dataUrl;
            document.head.appendChild(link);
        }

        function generateIconDataUrl() {
            const svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
                <rect fill="#f97316" width="512" height="512" rx="64"/>
                <rect x="80" y="80" width="352" height="352" rx="16" fill="none" stroke="#ffffff" stroke-width="24"/>
                <rect x="120" y="120" width="80" height="80" fill="#ffffff"/>
                <rect x="216" y="120" width="80" height="80" fill="#ffffff"/>
                <rect x="312" y="120" width="80" height="80" fill="#ffffff"/>
                <rect x="120" y="216" width="80" height="80" fill="#ffffff"/>
                <rect x="312" y="216" width="80" height="80" fill="#ffffff"/>
                <rect x="120" y="312" width="80" height="80" fill="#ffffff"/>
                <rect x="216" y="312" width="80" height="80" fill="#ffffff"/>
                <rect x="312" y="312" width="80" height="80" fill="#ffffff"/>
            </svg>`;

            return `data:image/svg+xml;base64,${btoa(svg)}`;
        }

        function registerServiceWorker() {
            if (!('serviceWorker' in navigator)) {
                console.log('Service Worker not supported');
                return;
            }

            const swCode = `
const CACHE_NAME = 'barcode-wallet-v1';
const ASSETS = [];

self.addEventListener('install', (event) => {
    console.log('Service Worker installing');
    event.waitUntil(
        caches.open(CACHE_NAME).then(cache => {
            return cache.addAll(ASSETS);
        })
    );
    self.skipWaiting();
});

self.addEventListener('activate', (event) => {
    console.log('Service Worker activating');
    event.waitUntil(
        caches.keys().then(keys => {
            return Promise.all(
                keys.map(key => {
                    if (key !== CACHE_NAME) {
                        console.log('Deleting old cache:', key);
                        return caches.delete(key);
                    }
                })
            );
        })
    );
    self.clients.claim();
});

self.addEventListener('fetch', (event) => {
    // Network-first strategy
    event.respondWith(
        fetch(event.request)
            .catch(() => caches.match(event.request))
    );
});
`;

            try {
                const blob = new Blob([swCode], { type: 'application/javascript' });
                const swUrl = URL.createObjectURL(blob);

                navigator.serviceWorker.register(swUrl)
                    .then(reg => {
                        console.log('Service Worker registered:', reg);
                    })
                    .catch(err => {
                        console.error('Service Worker registration failed:', err);
                    });
            } catch (err) {
                console.error('Service Worker setup failed:', err);
            }
        }

        // Install prompt handling
        let deferredPrompt;

        function setupInstallPrompt() {
            window.addEventListener('beforeinstallprompt', (e) => {
                e.preventDefault();
                deferredPrompt = e;
                showInstallButton();
            });

            window.addEventListener('appinstalled', () => {
                console.log('PWA installed');
                deferredPrompt = null;
                hideInstallButton();
                announce('App installed successfully');
            });
        }

        function showInstallButton() {
            const btn = document.getElementById('install-btn');
            btn.classList.remove('hidden');
            btn.addEventListener('click', async () => {
                if (!deferredPrompt) return;

                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;
                console.log('Install outcome:', outcome);

                if (outcome === 'accepted') {
                    announce('Installing app...');
                }

                deferredPrompt = null;
                hideInstallButton();
            });
        }

        function hideInstallButton() {
            const btn = document.getElementById('install-btn');
            btn.classList.add('hidden');
        }

        // ===========================
        // Diagnostic Overlay Functions
        // ===========================
        function showDiagnosticOverlay() {
            const overlay = document.getElementById('diagnostic-overlay');
            overlay.classList.remove('hidden');
            // Reset log
            const log = document.getElementById('diag-log');
            log.innerHTML = '<div class="diagnostic-log-entry info">Initializing scan...</div>';
        }

        function hideDiagnosticOverlay() {
            const overlay = document.getElementById('diagnostic-overlay');
            overlay.classList.add('hidden');
        }

        async function updateDiagnosticFile(file) {
            document.getElementById('diag-file-name').textContent = `Name: ${file.name}`;
            document.getElementById('diag-file-size').textContent = `Size: ${(file.size / 1024).toFixed(2)} KB`;
            document.getElementById('diag-file-type').textContent = `Type: ${file.type}`;

            // Load and display image preview
            const dataUrl = await readFileAsDataUrl(file);
            document.getElementById('diag-image-preview').src = dataUrl;
        }

        function updateDiagnosticDimensions(dimensions) {
            document.getElementById('diag-image-dimensions').textContent = `Dimensions: ${dimensions}`;
        }

        function updateDiagnosticProgress(current, total, strategyName) {
            const progress = document.getElementById('diag-progress');
            if (current === 0 && total === 0) {
                // Error state
                progress.textContent = strategyName;
                progress.style.color = 'var(--danger)';
            } else {
                progress.textContent = `${current}/${total}: ${strategyName}`;
                progress.style.color = 'var(--accent)';
            }
        }

        function addDiagnosticLog(message, type = 'info') {
            const log = document.getElementById('diag-log');
            const entry = document.createElement('div');
            entry.className = `diagnostic-log-entry ${type}`;
            entry.textContent = message;
            log.appendChild(entry);
            // Auto-scroll to bottom
            log.scrollTop = log.scrollHeight;
        }

        // ===========================
        // Initialization
        // ===========================
        function init() {
            // Load data
            state.items = loadData();
            state.settings = loadSettings();

            // Setup PWA
            generateManifest();
            registerServiceWorker();
            setupInstallPrompt();

            // Setup event listeners
            initEventListeners();

            // Initial render
            render();

            console.log('Barcode Wallet initialized');
            console.log(`Loaded ${state.items.length} items`);
        }

        // Start app when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>
