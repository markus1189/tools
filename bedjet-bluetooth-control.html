<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Control BedJet climate comfort system via Bluetooth LE with real-time status monitoring">
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="BedJet Control">
    <link rel="manifest" href="bedjet-bluetooth-control.manifest.json">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='80' font-size='80'>üõèÔ∏è</text></svg>">
    <title>BedJet Bluetooth Control</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 0;
            margin: 0;
            overflow-x: hidden;
        }

        .container {
            background: white;
            min-height: 100vh;
            width: 100%;
            padding: 0;
            display: flex;
            flex-direction: column;
        }

        /* Hamburger Menu */
        .hamburger {
            position: fixed;
            top: 15px;
            left: 15px;
            width: 40px;
            height: 40px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            z-index: 1001;
            transition: all 0.3s ease;
        }

        .hamburger span {
            width: 22px;
            height: 2px;
            background: #667eea;
            transition: all 0.3s ease;
        }

        .hamburger.active span:nth-child(1) {
            transform: translateY(7px) rotate(45deg);
        }

        .hamburger.active span:nth-child(2) {
            opacity: 0;
        }

        .hamburger.active span:nth-child(3) {
            transform: translateY(-7px) rotate(-45deg);
        }

        .menu-drawer {
            position: fixed;
            top: 0;
            left: -100%;
            width: 280px;
            height: 100vh;
            background: white;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            transition: left 0.3s ease;
            overflow-y: auto;
            padding: 70px 20px 20px 20px;
        }

        .menu-drawer.open {
            left: 0;
        }

        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .menu-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        .menu-section {
            margin-bottom: 25px;
        }

        .menu-section h3 {
            font-size: 14px;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 60px 15px 15px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
        }

        .header h1 {
            font-size: 20px;
            font-weight: 700;
            margin: 0;
        }

        .header .status-bar {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
        }

        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            flex-shrink: 0;
        }

        .status-indicator.connected {
            background: #4caf50;
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.8);
        }

        .device-name {
            font-size: 11px;
            opacity: 0.9;
            margin-left: 4px;
        }

        .device-name:not(:empty)::before {
            content: '‚Ä¢ ';
            margin-right: 4px;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        /* Mode Panel */
        .mode-panel {
            margin-bottom: 20px;
        }

        .mode-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 12px;
        }

        .mode-btn {
            padding: 12px 8px;
            border: 2px solid #e0e0e0;
            background: white;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #666;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: #667eea;
            color: white;
        }

        .time-remaining-display {
            text-align: center;
            padding: 10px;
            background: #f9f9f9;
            border-radius: 8px;
            font-size: 14px;
            color: #666;
        }

        .time-remaining-display .value {
            font-size: 20px;
            font-weight: 700;
            color: #333;
            margin-left: 8px;
        }

        /* Gauges */
        .gauges-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .gauge-wrapper {
            text-align: center;
        }

        .gauge {
            position: relative;
            width: 140px;
            height: 140px;
            margin: 0 auto 15px auto;
        }

        .gauge-background {
            fill: none;
            stroke: #e0e0e0;
            stroke-width: 12;
        }

        .gauge-progress {
            fill: none;
            stroke: url(#gaugeGradient);
            stroke-width: 12;
            stroke-linecap: round;
            transition: stroke-dashoffset 0.3s ease;
            transform: rotate(-90deg);
            transform-origin: 50% 50%;
        }

        .gauge-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        .gauge-value {
            font-size: 32px;
            font-weight: 700;
            color: #333;
            display: block;
        }

        .gauge-unit {
            font-size: 14px;
            color: #999;
            display: block;
        }

        .gauge-label {
            font-size: 14px;
            color: #666;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
        }

        .gauge-sub-value {
            font-size: 12px;
            color: #999;
            margin-top: 5px;
        }

        .gauge.dirty {
            opacity: 0.7;
        }

        .gauge-actions {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-top: 10px;
        }

        .gauge-actions.hidden {
            display: none;
        }

        .action-btn {
            width: 44px;
            height: 44px;
            border: none;
            border-radius: 8px;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .action-btn.confirm {
            background: #4caf50;
            color: white;
        }

        .action-btn.cancel {
            background: #f44336;
            color: white;
        }

        .control-buttons {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-top: 8px;
        }

        .control-btn {
            width: 40px;
            height: 40px;
            border: 2px solid #667eea;
            background: white;
            border-radius: 8px;
            font-size: 18px;
            font-weight: 700;
            color: #667eea;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .control-btn:active {
            background: #667eea;
            color: white;
        }

        /* Sliders */
        .slider-wrapper {
            padding: 10px 0;
        }

        input[type="range"] {
            width: 100%;
            height: 10px;
            border-radius: 5px;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 var(--value), #e0e0e0 var(--value));
            outline: none;
            -webkit-appearance: none;
            transition: background 0.1s ease;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 26px;
            height: 26px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4), inset 0 0 0 3px #667eea;
            transition: all 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 3px 12px rgba(102, 126, 234, 0.6), inset 0 0 0 3px #667eea;
        }

        input[type="range"]::-webkit-slider-thumb:active {
            transform: scale(1.2);
            box-shadow: 0 4px 16px rgba(102, 126, 234, 0.8), inset 0 0 0 4px #667eea;
        }

        input[type="range"]::-moz-range-thumb {
            width: 26px;
            height: 26px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4), inset 0 0 0 3px #667eea;
            border: none;
            transition: all 0.2s ease;
        }

        input[type="range"]::-moz-range-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 3px 12px rgba(102, 126, 234, 0.6), inset 0 0 0 3px #667eea;
        }

        input[type="range"]::-moz-range-thumb:active {
            transform: scale(1.2);
            box-shadow: 0 4px 16px rgba(102, 126, 234, 0.8), inset 0 0 0 4px #667eea;
        }

        input[type="range"]:disabled {
            opacity: 0.5;
        }

        /* Mobile-optimized touch targets */
        @media (pointer: coarse) {
            input[type="range"]::-webkit-slider-thumb {
                width: 32px;
                height: 32px;
            }

            input[type="range"]::-moz-range-thumb {
                width: 32px;
                height: 32px;
            }
        }

        /* Memory Presets */
        .memory-section {
            margin: 20px 0;
        }

        .memory-section h2 {
            font-size: 16px;
            color: #333;
            margin-bottom: 12px;
            font-weight: 600;
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .preset-btn {
            padding: 14px;
            border: 2px solid #e0e0e0;
            background: white;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #666;
        }

        .preset-btn:active {
            border-color: #764ba2;
            color: #764ba2;
            background: #f5f0ff;
        }

        /* Buttons */
        .btn {
            width: 100%;
            padding: 14px;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-bottom: 12px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-danger {
            background: #f44336;
            color: white;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .error {
            background: #ffebee;
            color: #c62828;
            padding: 12px;
            border-radius: 8px;
            margin: 15px 20px;
            font-size: 14px;
            display: none;
        }

        .error.show {
            display: block;
        }

        /* Debug Section */
        .debug-section {
            background: #f5f5f5;
            border-radius: 10px;
            padding: 15px;
            margin: 20px;
            border: 2px solid #e0e0e0;
        }

        .debug-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        .debug-title {
            font-size: 16px;
            font-weight: 700;
            color: #333;
        }

        .debug-toggle {
            font-size: 12px;
            color: #667eea;
            font-weight: 600;
        }

        .debug-content {
            margin-top: 10px;
            display: none;
        }

        .debug-section:not(.collapsed) .debug-content {
            display: block;
        }

        .debug-section.collapsed .debug-toggle::after {
            content: ' ‚ñº';
        }

        .debug-section:not(.collapsed) .debug-toggle::after {
            content: ' ‚ñ≤';
        }

        .debug-options {
            margin-bottom: 10px;
            padding: 10px;
            background: white;
            border-radius: 6px;
        }

        .debug-options label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 13px;
            color: #666;
            margin-bottom: 8px;
        }

        .debug-options label:last-child {
            margin-bottom: 0;
            margin-left: 20px;
        }

        .debug-options input[type="checkbox"] {
            margin-right: 8px;
            cursor: pointer;
        }

        .debug-buttons {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .debug-btn {
            padding: 8px 12px;
            border: 1px solid #667eea;
            background: white;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            color: #667eea;
            transition: all 0.2s ease;
        }

        .debug-btn:active {
            background: #667eea;
            color: white;
        }

        .debug-log {
            background: #1e1e1e;
            color: #d4d4d4;
            border-radius: 6px;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            max-height: 250px;
            overflow-y: auto;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            line-height: 1.4;
        }

        .debug-log:empty::before {
            content: "No logs yet. Enable debug logging to collect logs.";
            color: #888;
        }

        .log-entry {
            margin-bottom: 4px;
            padding: 2px 0;
        }

        .log-time {
            color: #858585;
        }

        .log-level-info {
            color: #4ec9b0;
        }

        .log-level-error {
            color: #f48771;
        }

        .log-level-warn {
            color: #dcdcaa;
        }

        .log-level-success {
            color: #89d185;
        }

        /* Biorhythm Section */
        .biorhythm-section {
            margin: 20px;
        }

        .biorhythm-section h2 {
            font-size: 16px;
            color: #333;
            margin-bottom: 12px;
            font-weight: 600;
        }

        @media (max-width: 360px) {
            .gauges-container {
                grid-template-columns: 1fr;
            }

            .gauge {
                width: 160px;
                height: 160px;
            }
        }
    </style>
</head>
<body>
    <!-- Hamburger Menu Button -->
    <div class="hamburger" id="hamburger">
        <span></span>
        <span></span>
        <span></span>
    </div>

    <!-- Menu Overlay -->
    <div class="menu-overlay" id="menuOverlay"></div>

    <!-- Menu Drawer -->
    <div class="menu-drawer" id="menuDrawer">
        <div class="menu-section">
            <h3>Connection</h3>
            <button id="connectBtn" class="btn btn-primary">Connect to BedJet</button>
            <button id="reconnectBtn" class="btn btn-primary" style="display: none;">Reconnect to <span id="savedDeviceName"></span></button>
            <button id="disconnectBtn" class="btn btn-danger" style="display: none;">Disconnect</button>
        </div>

        <div class="menu-section">
            <h3>Settings</h3>
            <label style="display: flex; align-items: center; cursor: pointer; font-size: 14px; color: #666; margin-bottom: 12px;">
                <input type="checkbox" id="showAllDevices" style="margin-right: 8px; cursor: pointer;">
                <span>Show all Bluetooth devices</span>
            </label>
            <label style="display: flex; align-items: center; cursor: pointer; font-size: 14px; color: #666;">
                <input type="checkbox" id="useCelsius" style="margin-right: 8px; cursor: pointer;">
                <span>Use Fahrenheit (¬∞F)</span>
            </label>
        </div>
    </div>

    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>JetCommand</h1>
            <div class="status-bar">
                <span class="status-indicator" id="statusIndicator"></span>
                <span id="statusText">Not Connected</span>
                <span class="device-name" id="deviceName"></span>
            </div>
        </div>

        <div id="error" class="error"></div>

        <!-- Main Content -->
        <div class="main-content" id="controls" style="display: none;">
            <!-- Mode Panel -->
            <div class="mode-panel">
                <div class="mode-buttons">
                    <button class="mode-btn" data-mode="off">OFF</button>
                    <button class="mode-btn" data-mode="cool">COOL</button>
                    <button class="mode-btn" data-mode="heat">HEAT</button>
                    <button class="mode-btn" data-mode="turbo">TURBO</button>
                    <button class="mode-btn" data-mode="dry">DRY</button>
                    <button class="mode-btn" data-mode="ext_ht">EXT HT</button>
                </div>
                <div class="time-remaining-display">
                    Time Remaining: <span class="value" id="timeRemaining">--</span>
                </div>
            </div>

            <!-- Gauges -->
            <div class="gauges-container">
                <!-- Temperature Gauge -->
                <div class="gauge-wrapper">
                    <div class="gauge-label">TEMPERATURE</div>
                    <div class="gauge" id="tempGauge">
                        <svg width="140" height="140" viewBox="0 0 140 140">
                            <defs>
                                <linearGradient id="gaugeGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#667eea;stop-opacity:1" />
                                    <stop offset="100%" style="stop-color:#764ba2;stop-opacity:1" />
                                </linearGradient>
                            </defs>
                            <circle class="gauge-background" cx="70" cy="70" r="60"/>
                            <circle class="gauge-progress" id="tempGaugeProgress" cx="70" cy="70" r="60"
                                    stroke-dasharray="377" stroke-dashoffset="377"/>
                        </svg>
                        <div class="gauge-text">
                            <span class="gauge-value" id="targetTemp">--</span>
                            <span class="gauge-unit" id="targetTempUnit">¬∞C</span>
                        </div>
                    </div>
                    <div class="gauge-sub-value">Current: <span id="currentTemp">--</span><span id="currentTempUnit">¬∞C</span></div>
                    <div class="gauge-sub-value" id="tempRangeIndicator" style="font-size: 11px; color: #999; margin-top: 2px;">Range: --</div>
                    <div class="slider-wrapper">
                        <input type="range" id="tempSlider" min="19" max="40" value="22" step="1">
                    </div>
                    <div class="gauge-actions hidden" id="tempActions">
                        <button class="action-btn confirm" id="tempConfirm">‚úì</button>
                        <button class="action-btn cancel" id="tempCancel">‚úó</button>
                    </div>
                    <div class="control-buttons">
                        <button class="control-btn" id="tempDownBtn">‚àí</button>
                        <button class="control-btn" id="tempUpBtn">+</button>
                    </div>
                </div>

                <!-- Fan Gauge -->
                <div class="gauge-wrapper">
                    <div class="gauge-label">FAN SPEED</div>
                    <div class="gauge" id="fanGauge">
                        <svg width="140" height="140" viewBox="0 0 140 140">
                            <circle class="gauge-background" cx="70" cy="70" r="60"/>
                            <circle class="gauge-progress" id="fanGaugeProgress" cx="70" cy="70" r="60"
                                    stroke-dasharray="377" stroke-dashoffset="377"/>
                        </svg>
                        <div class="gauge-text">
                            <span class="gauge-value" id="fanSpeed">--</span>
                            <span class="gauge-unit">%</span>
                        </div>
                    </div>
                    <div class="gauge-sub-value">&nbsp;</div>
                    <div class="gauge-sub-value">&nbsp;</div>
                    <div class="slider-wrapper">
                        <input type="range" id="fanSlider" min="5" max="100" value="50" step="5">
                    </div>
                    <div class="gauge-actions hidden" id="fanActions">
                        <button class="action-btn confirm" id="fanConfirm">‚úì</button>
                        <button class="action-btn cancel" id="fanCancel">‚úó</button>
                    </div>
                    <div class="control-buttons">
                        <button class="control-btn" id="fanDownBtn">‚àí</button>
                        <button class="control-btn" id="fanUpBtn">+</button>
                    </div>
                </div>
            </div>

            <!-- Memory Presets -->
            <div class="memory-section">
                <h2>Memory Presets</h2>
                <div class="preset-buttons">
                    <button class="preset-btn" data-preset="1">M1</button>
                    <button class="preset-btn" data-preset="2">M2</button>
                    <button class="preset-btn" data-preset="3">M3</button>
                </div>
            </div>
        </div>

        <!-- Biorhythms -->
        <div class="biorhythm-section" id="biorhythmSection" style="display: none;">
            <h2>Biorhythms</h2>
            <button class="btn btn-primary" id="loadBiorhythmsBtn" style="margin-bottom: 15px;">Load Biorhythms</button>
            <div id="biorhythmsList" style="display: none;">
                <div class="biorhythm-item" id="bio1Card" style="margin-bottom: 10px;">
                    <div style="padding: 15px; background: white; border-radius: 8px; border: 2px solid #e0e0e0;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <div>
                                <div style="font-weight: 700; font-size: 16px; color: #333;">Bio1</div>
                                <div id="bio1Name" style="font-size: 14px; color: #666; margin-top: 3px;">Not loaded</div>
                            </div>
                            <button class="preset-btn" id="bio1ExpandBtn" style="width: auto; padding: 8px 16px;">View</button>
                        </div>
                        <div id="bio1Steps" style="display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid #e0e0e0;"></div>
                    </div>
                </div>
                <div class="biorhythm-item" id="bio2Card" style="margin-bottom: 10px;">
                    <div style="padding: 15px; background: white; border-radius: 8px; border: 2px solid #e0e0e0;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <div>
                                <div style="font-weight: 700; font-size: 16px; color: #333;">Bio2</div>
                                <div id="bio2Name" style="font-size: 14px; color: #666; margin-top: 3px;">Not loaded</div>
                            </div>
                            <button class="preset-btn" id="bio2ExpandBtn" style="width: auto; padding: 8px 16px;">View</button>
                        </div>
                        <div id="bio2Steps" style="display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid #e0e0e0;"></div>
                    </div>
                </div>
                <div class="biorhythm-item" id="bio3Card" style="margin-bottom: 10px;">
                    <div style="padding: 15px; background: white; border-radius: 8px; border: 2px solid #e0e0e0;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <div>
                                <div style="font-weight: 700; font-size: 16px; color: #333;">Bio3</div>
                                <div id="bio3Name" style="font-size: 14px; color: #666; margin-top: 3px;">Not loaded</div>
                            </div>
                            <button class="preset-btn" id="bio3ExpandBtn" style="width: auto; padding: 8px 16px;">View</button>
                        </div>
                        <div id="bio3Steps" style="display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid #e0e0e0;"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Debug Section -->
        <div class="debug-section collapsed" id="debugSection">
            <div class="debug-header" onclick="toggleDebugLog()">
                <div class="debug-title">üêõ Debug Log</div>
                <div class="debug-toggle"></div>
            </div>
            <div class="debug-content">
                <div class="debug-options">
                    <label>
                        <input type="checkbox" id="enableDebugLogging">
                        <span><strong>Enable debug logging</strong></span>
                    </label>
                    <label>
                        <input type="checkbox" id="enableStatusLogging">
                        <span>Include status notifications</span>
                    </label>
                </div>
                <div class="debug-buttons">
                    <button class="debug-btn" onclick="copyDebugLog()">üìã Copy</button>
                    <button class="debug-btn" onclick="clearDebugLog()">üóëÔ∏è Clear</button>
                    <button class="debug-btn" onclick="downloadDebugLog()">üíæ Download</button>
                </div>
                <div class="debug-log" id="debugLog"></div>
            </div>
        </div>
    </div>

    <script>
        // BedJet Bluetooth UUIDs and Constants
        // Service UUID
        const BEDJET_SERVICE_UUID = '00001000-bed0-0080-aa55-4265644a6574';

        // Characteristic UUIDs (all under the same service)
        const BEDJET_STATUS_UUID = '00002000-bed0-0080-aa55-4265644a6574';
        const BEDJET_NAME_UUID = '00002001-bed0-0080-aa55-4265644a6574';
        const BEDJET_COMMAND_UUID = '00002004-bed0-0080-aa55-4265644a6574';
        const BEDJET_BIODATA_UUID = '00002005-bed0-0080-aa55-4265644a6574';

        const MODE_MAP = {
            0x01: 'off',
            0x02: 'cool',
            0x03: 'heat',
            0x04: 'turbo',
            0x05: 'dry',
            0x06: 'ext_ht'
        };

        const REVERSE_MODE_MAP = {
            'off': 0x01,
            'cool': 0x02,
            'heat': 0x03,
            'turbo': 0x04,
            'dry': 0x05,
            'ext_ht': 0x06
        };

        // Temperature ranges by mode (in Fahrenheit for direct use)
        // Source: /tmp/bedjet-source/docs/temperature-ranges.md
        // Note: DRY mode uses dynamic bounds from device (see dry-mode-temperature-bounds.md)
        const TEMP_RANGES = {
            'heat': { minF: 72, maxF: 104, minC: 22, maxC: 40 },      // Heat: 22.5-40¬∞C (72.5-104¬∞F) - rounded
            'turbo': { minF: 109, maxF: 109, minC: 43, maxC: 43 },    // Turbo: Fixed 43¬∞C (109.4¬∞F)
            'ext_ht': { minF: 66, maxF: 92, minC: 19, maxC: 33 },     // Extended Heat: 19-33.5¬∞C (66.2-92.3¬∞F) - rounded
            'cool': { minF: 66, maxF: 88, minC: 19, maxC: 31 },       // Cool: 19-31¬∞C (66.2-87.8¬∞F)
            'dry': { minF: 68, maxF: 104, minC: 20, maxC: 40 },       // Dry: 20-40¬∞C (68-104¬∞F) - STATIC FALLBACK, device overrides
            'off': { minF: 66, maxF: 104, minC: 19, maxC: 40 }        // Default range when off
        };

        // Biorhythm mode constants
        const BIO_MODE_NAMES = {
            0: 'STANDBY',
            1: 'HEAT',
            2: 'TURBO',
            3: 'EXTHT',
            4: 'COOL',
            5: 'DRY',
            6: 'WAIT'
        };

        // State
        let device = null;
        let server = null;
        let commandCharacteristic = null;
        let biodataCharacteristic = null;
        let currentMode = null;
        let useCelsius = true;
        let lastStatusUpdate = null;

        // Device-reported dynamic temperature bounds (for DRY mode)
        let deviceMinTemp = null;  // in half-degrees Celsius (raw value from device)
        let deviceMaxTemp = null;  // in half-degrees Celsius (raw value from device)
        let ambientTemp = null;    // in half-degrees Celsius (raw value from device)

        // Gauge/Slider dirty state
        let tempDirty = false;
        let fanDirty = false;
        let tempPendingValue = null;
        let fanPendingValue = null;

        // Biorhythm state
        let biorhythms = {
            bio1: { name: null, steps: [] },
            bio2: { name: null, steps: [] },
            bio3: { name: null, steps: [] }
        };
        let currentBioTag = 1;

        // Auto-reconnect state
        let reconnectAttempts = 0;
        let maxReconnectAttempts = 10;
        let reconnectBaseDelay = 3000; // 3 seconds
        let reconnectTimer = null;
        let isReconnecting = false;
        let userDisconnected = false;

        // LocalStorage keys
        const STORAGE_KEY_DEVICE_ID = 'bedjet_device_id';
        const STORAGE_KEY_DEVICE_NAME = 'bedjet_device_name';
        const STORAGE_KEY_DEBUG_LOGGING = 'bedjet_debug_logging_enabled';
        const STORAGE_KEY_STATUS_LOGGING = 'bedjet_status_logging_enabled';

        // LocalStorage functions
        function saveDeviceToStorage(deviceId, deviceName) {
            try {
                localStorage.setItem(STORAGE_KEY_DEVICE_ID, deviceId);
                localStorage.setItem(STORAGE_KEY_DEVICE_NAME, deviceName);
                logDebug(`‚úì Device saved to storage: ${deviceName} (${deviceId})`, 'success');
            } catch (error) {
                logDebug(`‚ö† Failed to save device to storage: ${error.message}`, 'warn');
            }
        }

        function getSavedDevice() {
            try {
                const deviceId = localStorage.getItem(STORAGE_KEY_DEVICE_ID);
                const deviceName = localStorage.getItem(STORAGE_KEY_DEVICE_NAME);
                if (deviceId && deviceName) {
                    return { id: deviceId, name: deviceName };
                }
            } catch (error) {
                logDebug(`‚ö† Failed to load device from storage: ${error.message}`, 'warn');
            }
            return null;
        }

        function clearSavedDevice() {
            try {
                localStorage.removeItem(STORAGE_KEY_DEVICE_ID);
                localStorage.removeItem(STORAGE_KEY_DEVICE_NAME);
                logDebug('‚úì Saved device cleared from storage', 'info');
            } catch (error) {
                logDebug(`‚ö† Failed to clear device from storage: ${error.message}`, 'warn');
            }
        }

        function saveDebugLoggingPreference(enabled) {
            try {
                localStorage.setItem(STORAGE_KEY_DEBUG_LOGGING, enabled ? 'true' : 'false');
            } catch (error) {
                console.warn('Failed to save debug logging preference:', error);
            }
        }

        function getDebugLoggingPreference() {
            try {
                const value = localStorage.getItem(STORAGE_KEY_DEBUG_LOGGING);
                return value === 'true';
            } catch (error) {
                return false; // Default to disabled
            }
        }

        function saveStatusLoggingPreference(enabled) {
            try {
                localStorage.setItem(STORAGE_KEY_STATUS_LOGGING, enabled ? 'true' : 'false');
            } catch (error) {
                console.warn('Failed to save status logging preference:', error);
            }
        }

        function getStatusLoggingPreference() {
            try {
                const value = localStorage.getItem(STORAGE_KEY_STATUS_LOGGING);
                return value === 'true';
            } catch (error) {
                return false; // Default to disabled
            }
        }

        // Debug logging
        let debugLoggingEnabled = getDebugLoggingPreference(); // Default to disabled
        let statusLoggingEnabled = getStatusLoggingPreference(); // Default to disabled
        let debugLogContent = '';
        const debugLogEl = document.getElementById('debugLog');

        // Temperature conversion helpers
        function fToC(fahrenheit) {
            return Math.round((fahrenheit - 32) * 5 / 9);
        }

        function cToF(celsius) {
            return Math.round(celsius * 9 / 5 + 32);
        }

        function getTempUnit() {
            return useCelsius ? '¬∞C' : '¬∞F';
        }

        function displayTemp(fahrenheit) {
            return useCelsius ? fToC(fahrenheit) : fahrenheit;
        }

        function inputToFahrenheit(value) {
            return useCelsius ? cToF(value) : value;
        }

        function fahrenheitToInput(fahrenheit) {
            return useCelsius ? fToC(fahrenheit) : fahrenheit;
        }

        function getTempRange(mode = null) {
            const activeMode = mode || currentMode || 'off';
            const range = TEMP_RANGES[activeMode] || TEMP_RANGES['off'];

            // DRY mode uses dynamic bounds from device if available
            if (activeMode === 'dry' && deviceMinTemp !== null && deviceMaxTemp !== null) {
                // Convert from half-degrees Celsius to actual temperature
                // deviceMinTemp/deviceMaxTemp are in the format: value = temp * 2
                // e.g., 40 = 20¬∞C, 80 = 40¬∞C
                const minC = Math.round(deviceMinTemp / 2);
                const maxC = Math.round(deviceMaxTemp / 2);
                const minF = Math.round((deviceMinTemp * 9) / 10 + 32);
                const maxF = Math.round((deviceMaxTemp * 9) / 10 + 32);

                if (useCelsius) {
                    return { min: minC, max: maxC };
                } else {
                    return { min: minF, max: maxF };
                }
            }

            // All other modes use static ranges
            if (useCelsius) {
                return { min: range.minC, max: range.maxC };
            } else {
                return { min: range.minF, max: range.maxF };
            }
        }

        function updateTempSliderRange() {
            const range = getTempRange();
            tempSlider.min = range.min;
            tempSlider.max = range.max;

            // Update range indicator
            const unit = getTempUnit();
            const rangeIndicator = document.getElementById('tempRangeIndicator');
            if (currentMode === 'turbo') {
                rangeIndicator.textContent = `Fixed: ${range.min}${unit}`;
                rangeIndicator.style.color = '#ff9800';
                logDebug(`Temperature locked to ${range.min}${unit} for TURBO mode`, 'info');
            } else if (currentMode === 'dry' && deviceMinTemp !== null && deviceMaxTemp !== null) {
                // DRY mode with dynamic bounds from device
                const ambientTempC = ambientTemp ? Math.round(ambientTemp / 2) : '?';
                rangeIndicator.textContent = `Range: ${range.min}-${range.max}${unit} (ambient: ${ambientTempC}¬∞C)`;
                rangeIndicator.style.color = '#4caf50';  // Green to indicate dynamic
                logDebug(`Temperature range (dynamic): ${range.min}-${range.max}${unit} for DRY mode (ambient: ${ambientTempC}¬∞C)`, 'info');
            } else {
                rangeIndicator.textContent = `Range: ${range.min}-${range.max}${unit}`;
                rangeIndicator.style.color = '#999';
                logDebug(`Temperature range updated: ${range.min}-${range.max}${unit} for ${(currentMode || 'off').toUpperCase()} mode`, 'info');
            }

            // Clamp current slider value to new range
            const currentValue = parseInt(tempSlider.value);
            if (currentValue < range.min) {
                tempSlider.value = range.min;
                targetTempEl.textContent = range.min;
                logDebug(`Temperature clamped to minimum: ${range.min}${unit}`, 'warn');
            } else if (currentValue > range.max) {
                tempSlider.value = range.max;
                targetTempEl.textContent = range.max;
                logDebug(`Temperature clamped to maximum: ${range.max}${unit}`, 'warn');
            }

            updateSliderFill(tempSlider);

            // Update gauge to reflect current value
            const fahrenheit = inputToFahrenheit(parseInt(tempSlider.value));
            updateTempGauge(fahrenheit);

            // Disable slider for turbo mode (fixed temperature)
            if (currentMode === 'turbo') {
                tempSlider.disabled = true;
                tempSlider.style.opacity = '0.5';
            } else {
                tempSlider.disabled = false;
                tempSlider.style.opacity = '1';
            }
        }

        function logDebug(message, level = 'info') {
            // Always log to console for browser devtools debugging
            const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false, fractionalSecondDigits: 3 });
            console.log(`[${timestamp}] ${message}`);

            // Only collect logs in UI if debug logging is enabled
            if (!debugLoggingEnabled) {
                return;
            }

            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';

            const timeSpan = document.createElement('span');
            timeSpan.className = 'log-time';
            timeSpan.textContent = `[${timestamp}] `;

            const levelSpan = document.createElement('span');
            levelSpan.className = `log-level-${level}`;
            levelSpan.textContent = message;

            logEntry.appendChild(timeSpan);
            logEntry.appendChild(levelSpan);
            debugLogEl.appendChild(logEntry);

            // Auto-scroll to bottom
            debugLogEl.scrollTop = debugLogEl.scrollHeight;

            // Keep text content for copying
            debugLogContent += `[${timestamp}] ${message}\n`;
        }

        function clearDebugLog() {
            debugLogContent = '';
            debugLogEl.innerHTML = '';
            if (debugLoggingEnabled) {
                logDebug('Debug log cleared', 'info');
            }
        }

        function copyDebugLog() {
            if (!debugLogContent) {
                alert('No logs to copy');
                return;
            }

            navigator.clipboard.writeText(debugLogContent).then(() => {
                logDebug('Log copied to clipboard!', 'success');
                setTimeout(() => alert('Debug log copied to clipboard!'), 100);
            }).catch(err => {
                // Fallback for mobile browsers
                const textArea = document.createElement('textarea');
                textArea.value = debugLogContent;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    logDebug('Log copied to clipboard (fallback)!', 'success');
                    alert('Debug log copied to clipboard!');
                } catch (e) {
                    logDebug('Failed to copy: ' + e.message, 'error');
                    alert('Failed to copy. Error: ' + e.message);
                }
                document.body.removeChild(textArea);
            });
        }

        function downloadDebugLog() {
            if (!debugLogContent) {
                alert('No logs to download');
                return;
            }

            const blob = new Blob([debugLogContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `bedjet-debug-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            logDebug('Log downloaded', 'success');
        }

        function toggleDebugLog() {
            const section = document.getElementById('debugSection');
            section.classList.toggle('collapsed');
        }

        // Hamburger menu functions
        function openMenu() {
            hamburger.classList.add('active');
            menuDrawer.classList.add('open');
            menuOverlay.classList.add('active');
        }

        function closeMenu() {
            hamburger.classList.remove('active');
            menuDrawer.classList.remove('open');
            menuOverlay.classList.remove('active');
        }

        function toggleMenu() {
            if (menuDrawer.classList.contains('open')) {
                closeMenu();
            } else {
                openMenu();
            }
        }

        // Gauge update functions
        function updateGauge(gaugeId, value, min, max) {
            const gauge = document.getElementById(gaugeId);
            const circumference = 2 * Math.PI * 60; // r=60
            const percentage = ((value - min) / (max - min)) * 100;
            const offset = circumference - (percentage / 100) * circumference;
            gauge.style.strokeDashoffset = offset;
        }

        function updateTempGauge(tempF) {
            const displayValue = displayTemp(tempF);
            const range = getTempRange();
            updateGauge('tempGaugeProgress', displayValue, range.min, range.max);
        }

        function updateFanGauge(fanPercent) {
            updateGauge('fanGaugeProgress', fanPercent, 5, 100);
        }

        // UI Elements
        const hamburger = document.getElementById('hamburger');
        const menuDrawer = document.getElementById('menuDrawer');
        const menuOverlay = document.getElementById('menuOverlay');
        const connectBtn = document.getElementById('connectBtn');
        const reconnectBtn = document.getElementById('reconnectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const savedDeviceNameEl = document.getElementById('savedDeviceName');
        const statusIndicator = document.getElementById('statusIndicator');
        const statusText = document.getElementById('statusText');
        const deviceName = document.getElementById('deviceName');
        const controls = document.getElementById('controls');
        const biorhythmSection = document.getElementById('biorhythmSection');
        const errorDiv = document.getElementById('error');
        const useCelsiusCheckbox = document.getElementById('useCelsius');
        const enableDebugLoggingCheckbox = document.getElementById('enableDebugLogging');
        const enableStatusLoggingCheckbox = document.getElementById('enableStatusLogging');

        // State displays
        const currentTempEl = document.getElementById('currentTemp');
        const currentTempUnitEl = document.getElementById('currentTempUnit');
        const targetTempEl = document.getElementById('targetTemp');
        const targetTempUnitEl = document.getElementById('targetTempUnit');
        const fanSpeedEl = document.getElementById('fanSpeed');
        const timeRemainingEl = document.getElementById('timeRemaining');

        // Controls
        const modeButtons = document.querySelectorAll('.mode-btn');
        const tempSlider = document.getElementById('tempSlider');
        const tempUpBtn = document.getElementById('tempUpBtn');
        const tempDownBtn = document.getElementById('tempDownBtn');
        const fanSlider = document.getElementById('fanSlider');
        const fanUpBtn = document.getElementById('fanUpBtn');
        const fanDownBtn = document.getElementById('fanDownBtn');
        const presetButtons = document.querySelectorAll('.preset-btn');

        // Check Web Bluetooth support
        if (!navigator.bluetooth) {
            showError('Web Bluetooth API is not supported in this browser. Please use Chrome, Edge, or Opera.');
            connectBtn.disabled = true;
            logDebug('‚ùå Web Bluetooth API not supported in this browser', 'error');
            logDebug('User Agent: ' + navigator.userAgent, 'info');
        } else {
            logDebug('‚úì Web Bluetooth API is available', 'success');
            logDebug('User Agent: ' + navigator.userAgent, 'info');
        }

        // Slider fill update
        function updateSliderFill(slider) {
            const min = parseFloat(slider.min);
            const max = parseFloat(slider.max);
            const value = parseFloat(slider.value);
            const percentage = ((value - min) / (max - min)) * 100;
            slider.style.setProperty('--value', `${percentage}%`);
        }

        // Temperature unit toggle
        function updateTemperatureUI() {
            useCelsius = !useCelsiusCheckbox.checked;
            const unit = getTempUnit();

            // Update all unit displays
            currentTempUnitEl.textContent = unit;
            targetTempUnitEl.textContent = unit;

            // Update temperature slider range based on current mode and unit
            updateTempSliderRange();

            logDebug(`Temperature unit changed to: ${unit}`, 'info');
        }

        // Event Listeners
        hamburger.addEventListener('click', toggleMenu);
        menuOverlay.addEventListener('click', closeMenu);

        connectBtn.addEventListener('click', () => {
            connectToBedJet();
            closeMenu();
        });
        reconnectBtn.addEventListener('click', () => {
            reconnectToSavedDevice();
            closeMenu();
        });
        disconnectBtn.addEventListener('click', () => {
            disconnect();
            closeMenu();
        });
        useCelsiusCheckbox.addEventListener('change', updateTemperatureUI);
        enableDebugLoggingCheckbox.addEventListener('change', (e) => {
            debugLoggingEnabled = e.target.checked;
            saveDebugLoggingPreference(debugLoggingEnabled);
            if (debugLoggingEnabled) {
                logDebug('‚úì Debug logging enabled', 'success');
            } else {
                console.log('Debug logging disabled');
            }
        });

        enableStatusLoggingCheckbox.addEventListener('change', (e) => {
            statusLoggingEnabled = e.target.checked;
            saveStatusLoggingPreference(statusLoggingEnabled);
            if (debugLoggingEnabled) {
                logDebug(`Status notification logging ${statusLoggingEnabled ? 'enabled' : 'disabled'}`, 'info');
            } else {
                console.log(`Status notification logging ${statusLoggingEnabled ? 'enabled' : 'disabled'}`);
            }
        });

        modeButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                const mode = btn.dataset.mode;
                setMode(mode);
            });
        });

        tempSlider.addEventListener('input', (e) => {
            const sliderValue = parseInt(e.target.value);
            document.getElementById('targetTemp').textContent = sliderValue;
            updateSliderFill(e.target);

            // Mark as dirty - user is changing value
            if (!tempDirty) {
                tempDirty = true;
                tempPendingValue = sliderValue;
                document.getElementById('tempActions').classList.remove('hidden');
                document.getElementById('tempGauge').classList.add('dirty');
            } else {
                tempPendingValue = sliderValue;
            }

            // Update gauge visual
            const fahrenheit = inputToFahrenheit(sliderValue);
            updateTempGauge(fahrenheit);
        });

        document.getElementById('tempConfirm').addEventListener('click', () => {
            if (tempDirty && tempPendingValue !== null) {
                const fahrenheit = inputToFahrenheit(tempPendingValue);
                setTemperature(fahrenheit);
                tempDirty = false;
                tempPendingValue = null;
                document.getElementById('tempActions').classList.add('hidden');
                document.getElementById('tempGauge').classList.remove('dirty');
            }
        });

        document.getElementById('tempCancel').addEventListener('click', () => {
            if (tempDirty) {
                // Revert to last known value from status
                const currentValue = document.getElementById('targetTemp').textContent;
                if (currentValue !== '--') {
                    tempSlider.value = currentValue;
                    updateSliderFill(tempSlider);
                }
                tempDirty = false;
                tempPendingValue = null;
                document.getElementById('tempActions').classList.add('hidden');
                document.getElementById('tempGauge').classList.remove('dirty');
            }
        });

        fanSlider.addEventListener('input', (e) => {
            const sliderValue = parseInt(e.target.value);
            document.getElementById('fanSpeed').textContent = sliderValue;
            updateSliderFill(e.target);

            // Mark as dirty - user is changing value
            if (!fanDirty) {
                fanDirty = true;
                fanPendingValue = sliderValue;
                document.getElementById('fanActions').classList.remove('hidden');
                document.getElementById('fanGauge').classList.add('dirty');
            } else {
                fanPendingValue = sliderValue;
            }

            // Update gauge visual
            updateFanGauge(sliderValue);
        });

        document.getElementById('fanConfirm').addEventListener('click', () => {
            if (fanDirty && fanPendingValue !== null) {
                setFanSpeed(fanPendingValue);
                fanDirty = false;
                fanPendingValue = null;
                document.getElementById('fanActions').classList.add('hidden');
                document.getElementById('fanGauge').classList.remove('dirty');
            }
        });

        document.getElementById('fanCancel').addEventListener('click', () => {
            if (fanDirty) {
                // Revert to last known value from status
                const currentValue = document.getElementById('fanSpeed').textContent;
                if (currentValue !== '--') {
                    fanSlider.value = currentValue;
                    updateSliderFill(fanSlider);
                }
                fanDirty = false;
                fanPendingValue = null;
                document.getElementById('fanActions').classList.add('hidden');
                document.getElementById('fanGauge').classList.remove('dirty');
            }
        });

        // Initialize slider fills
        updateSliderFill(tempSlider);
        updateSliderFill(fanSlider);

        // Initialize temperature slider range based on default mode
        updateTempSliderRange();

        tempUpBtn.addEventListener('click', () => {
            incrementTemperature();
        });

        tempDownBtn.addEventListener('click', () => {
            decrementTemperature();
        });

        fanUpBtn.addEventListener('click', () => {
            incrementFan();
        });

        fanDownBtn.addEventListener('click', () => {
            decrementFan();
        });

        presetButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                const preset = parseInt(btn.dataset.preset);
                activatePreset(preset);
            });
        });

        // Biorhythm button event listeners
        document.getElementById('loadBiorhythmsBtn').addEventListener('click', () => {
            logDebug('Load biorhythms button clicked', 'info');
            loadAllBiorhythms();
        });

        document.getElementById('bio1ExpandBtn').addEventListener('click', () => {
            const stepsEl = document.getElementById('bio1Steps');
            const btn = document.getElementById('bio1ExpandBtn');
            if (stepsEl.style.display === 'none') {
                stepsEl.style.display = 'block';
                btn.textContent = 'Hide';
                logDebug('Bio1 steps expanded', 'info');
            } else {
                stepsEl.style.display = 'none';
                btn.textContent = 'View';
                logDebug('Bio1 steps collapsed', 'info');
            }
        });

        document.getElementById('bio2ExpandBtn').addEventListener('click', () => {
            const stepsEl = document.getElementById('bio2Steps');
            const btn = document.getElementById('bio2ExpandBtn');
            if (stepsEl.style.display === 'none') {
                stepsEl.style.display = 'block';
                btn.textContent = 'Hide';
                logDebug('Bio2 steps expanded', 'info');
            } else {
                stepsEl.style.display = 'none';
                btn.textContent = 'View';
                logDebug('Bio2 steps collapsed', 'info');
            }
        });

        document.getElementById('bio3ExpandBtn').addEventListener('click', () => {
            const stepsEl = document.getElementById('bio3Steps');
            const btn = document.getElementById('bio3ExpandBtn');
            if (stepsEl.style.display === 'none') {
                stepsEl.style.display = 'block';
                btn.textContent = 'Hide';
                logDebug('Bio3 steps expanded', 'info');
            } else {
                stepsEl.style.display = 'none';
                btn.textContent = 'View';
                logDebug('Bio3 steps collapsed', 'info');
            }
        });

        async function connectToBedJet() {
            try {
                hideError();
                statusText.textContent = 'Scanning...';

                // Reset reconnect state
                userDisconnected = false;
                reconnectAttempts = 0;
                if (reconnectTimer) {
                    clearTimeout(reconnectTimer);
                    reconnectTimer = null;
                }

                const showAll = document.getElementById('showAllDevices').checked;
                logDebug('=== Starting BedJet Connection ===', 'info');
                logDebug(`Show all devices mode: ${showAll}`, 'info');

                // Request BedJet device with fallback options
                const requestOptions = {
                    optionalServices: [
                        BEDJET_SERVICE_UUID
                    ]
                };

                if (showAll) {
                    // Fallback: show all devices (useful if service UUIDs aren't advertised)
                    requestOptions.acceptAllDevices = true;
                    logDebug('Using acceptAllDevices mode (fallback)', 'warn');
                } else {
                    // Default: filter by service UUIDs and name prefix
                    requestOptions.filters = [
                        { services: [BEDJET_SERVICE_UUID] },
                        { namePrefix: 'BedJet' },
                        { namePrefix: 'BEDJET' }
                    ];
                    logDebug('Scanning with filters:', 'info');
                    logDebug(`  - Service UUID: ${BEDJET_SERVICE_UUID}`, 'info');
                    logDebug(`  - Name prefixes: BedJet, BEDJET`, 'info');
                }

                logDebug('Requesting Bluetooth device...', 'info');
                device = await navigator.bluetooth.requestDevice(requestOptions);

                logDebug(`‚úì Device selected: ${device.name || 'Unknown'}`, 'success');
                logDebug(`  Device ID: ${device.id}`, 'info');
                logDebug(`  Device GATT connected: ${device.gatt.connected}`, 'info');

                statusText.textContent = 'Connecting...';
                device.addEventListener('gattserverdisconnected', onDisconnected);

                logDebug('Connecting to GATT server...', 'info');
                server = await device.gatt.connect();
                logDebug('‚úì Connected to GATT server', 'success');

                // Get the BedJet service (all characteristics are under this one service)
                logDebug(`Getting BedJet service (${BEDJET_SERVICE_UUID})...`, 'info');
                const bedjetService = await server.getPrimaryService(BEDJET_SERVICE_UUID);
                logDebug('‚úì Got BedJet service', 'success');

                // Get command characteristic (for sending commands)
                logDebug(`Getting command characteristic (${BEDJET_COMMAND_UUID})...`, 'info');
                commandCharacteristic = await bedjetService.getCharacteristic(BEDJET_COMMAND_UUID);
                logDebug('‚úì Got command characteristic', 'success');
                logDebug(`  Properties: ${Array.from(commandCharacteristic.properties).join(', ')}`, 'info');

                // Get status characteristic (for receiving status updates)
                logDebug(`Getting status characteristic (${BEDJET_STATUS_UUID})...`, 'info');
                const statusCharacteristic = await bedjetService.getCharacteristic(BEDJET_STATUS_UUID);
                logDebug('‚úì Got status characteristic', 'success');
                logDebug(`  Properties: ${Array.from(statusCharacteristic.properties).join(', ')}`, 'info');

                // Subscribe to status notifications
                logDebug('Starting notifications...', 'info');
                await statusCharacteristic.startNotifications();
                statusCharacteristic.addEventListener('characteristicvaluechanged', handleStatusUpdate);
                logDebug('‚úì Notifications enabled', 'success');

                // Get biodata characteristic (for biorhythm data)
                // Note: biodata is optional and only needed for loading biorhythms
                // The official app uses READ operations, not notifications, for biodata
                try {
                    logDebug(`Getting biodata characteristic (${BEDJET_BIODATA_UUID})...`, 'info');
                    biodataCharacteristic = await bedjetService.getCharacteristic(BEDJET_BIODATA_UUID);
                    logDebug('‚úì Got biodata characteristic', 'success');
                    logDebug(`  Properties: ${Array.from(biodataCharacteristic.properties).join(', ')}`, 'info');
                    logDebug('Note: Biodata will be read on-demand when loading biorhythms', 'info');
                } catch (error) {
                    logDebug(`‚ö† Could not get biodata characteristic: ${error.message}`, 'warn');
                    logDebug('  Biorhythm loading will not be available', 'warn');
                    biodataCharacteristic = null;
                }

                // Read device name
                try {
                    logDebug(`Getting name characteristic (${BEDJET_NAME_UUID})...`, 'info');
                    const nameCharacteristic = await bedjetService.getCharacteristic(BEDJET_NAME_UUID);
                    const nameValue = await nameCharacteristic.readValue();
                    const name = new TextDecoder().decode(nameValue);
                    deviceName.textContent = name || device.name;
                    logDebug(`‚úì Device name: ${name || device.name}`, 'success');
                } catch (err) {
                    deviceName.textContent = device.name;
                    logDebug(`‚ö† Could not read device name: ${err.message}`, 'warn');
                }

                // Save device to localStorage
                const finalDeviceName = deviceName.textContent || device.name;
                saveDeviceToStorage(device.id, finalDeviceName);

                // Update UI
                updateConnectionStatus(true);
                controls.style.display = 'block';
                biorhythmSection.style.display = 'block';
                connectBtn.style.display = 'none';
                reconnectBtn.style.display = 'none';
                disconnectBtn.style.display = '';

                logDebug('=== Connection Complete ===', 'success');

            } catch (error) {
                console.error('Connection failed:', error);
                logDebug(`‚ùå Connection failed: ${error.name} - ${error.message}`, 'error');
                if (error.stack) {
                    logDebug(`Stack: ${error.stack}`, 'error');
                }
                showError(`Failed to connect: ${error.message}`);
                updateConnectionStatus(false);
            }
        }

        async function reconnectToSavedDevice() {
            try {
                hideError();
                statusText.textContent = 'Reconnecting...';

                // Reset reconnect state
                userDisconnected = false;
                reconnectAttempts = 0;
                if (reconnectTimer) {
                    clearTimeout(reconnectTimer);
                    reconnectTimer = null;
                }

                const savedDevice = getSavedDevice();
                if (!savedDevice) {
                    showError('No saved device found. Please connect manually.');
                    logDebug('‚ùå No saved device found', 'error');
                    return;
                }

                logDebug('=== Reconnecting to Saved Device ===', 'info');
                logDebug(`Saved device: ${savedDevice.name} (${savedDevice.id})`, 'info');

                // Check if we still have the device object in memory
                if (device && device.id === savedDevice.id && device.gatt) {
                    logDebug('Using existing device object from memory', 'info');
                } else {
                    // Device object lost (page reload) - need to request again with user gesture
                    // This will show the device picker, which should remember the previously paired device
                    logDebug('Device object not in memory, requesting device selection...', 'info');

                    const showAll = document.getElementById('showAllDevices').checked;
                    const requestOptions = {
                        optionalServices: [BEDJET_SERVICE_UUID]
                    };

                    if (showAll) {
                        requestOptions.acceptAllDevices = true;
                    } else {
                        requestOptions.filters = [
                            { services: [BEDJET_SERVICE_UUID] },
                            { namePrefix: 'BedJet' },
                            { namePrefix: 'BEDJET' }
                        ];
                    }

                    device = await navigator.bluetooth.requestDevice(requestOptions);
                    logDebug(`‚úì Device selected: ${device.name || 'Unknown'}`, 'success');
                }

                logDebug(`  Device ID: ${device.id}`, 'info');

                device.addEventListener('gattserverdisconnected', onDisconnected);

                logDebug('Connecting to GATT server...', 'info');
                server = await device.gatt.connect();
                logDebug('‚úì Connected to GATT server', 'success');

                // Get the BedJet service
                logDebug(`Getting BedJet service (${BEDJET_SERVICE_UUID})...`, 'info');
                const bedjetService = await server.getPrimaryService(BEDJET_SERVICE_UUID);
                logDebug('‚úì Got BedJet service', 'success');

                // Get command characteristic
                logDebug(`Getting command characteristic (${BEDJET_COMMAND_UUID})...`, 'info');
                commandCharacteristic = await bedjetService.getCharacteristic(BEDJET_COMMAND_UUID);
                logDebug('‚úì Got command characteristic', 'success');

                // Get status characteristic
                logDebug(`Getting status characteristic (${BEDJET_STATUS_UUID})...`, 'info');
                const statusCharacteristic = await bedjetService.getCharacteristic(BEDJET_STATUS_UUID);
                logDebug('‚úì Got status characteristic', 'success');

                // Subscribe to status notifications
                logDebug('Starting notifications...', 'info');
                await statusCharacteristic.startNotifications();
                statusCharacteristic.addEventListener('characteristicvaluechanged', handleStatusUpdate);
                logDebug('‚úì Notifications enabled', 'success');

                // Get biodata characteristic (optional)
                try {
                    logDebug(`Getting biodata characteristic (${BEDJET_BIODATA_UUID})...`, 'info');
                    biodataCharacteristic = await bedjetService.getCharacteristic(BEDJET_BIODATA_UUID);
                    logDebug('‚úì Got biodata characteristic', 'success');
                    logDebug('Note: Biodata will be read on-demand when loading biorhythms', 'info');
                } catch (error) {
                    logDebug(`‚ö† Could not get biodata characteristic: ${error.message}`, 'warn');
                    logDebug('  Biorhythm loading will not be available', 'warn');
                    biodataCharacteristic = null;
                }

                // Read device name
                try {
                    logDebug(`Getting name characteristic (${BEDJET_NAME_UUID})...`, 'info');
                    const nameCharacteristic = await bedjetService.getCharacteristic(BEDJET_NAME_UUID);
                    const nameValue = await nameCharacteristic.readValue();
                    const name = new TextDecoder().decode(nameValue);
                    deviceName.textContent = name || device.name;
                    logDebug(`‚úì Device name: ${name || device.name}`, 'success');
                } catch (err) {
                    deviceName.textContent = device.name;
                    logDebug(`‚ö† Could not read device name: ${err.message}`, 'warn');
                }

                // Update saved device info (in case it changed)
                const finalDeviceName = deviceName.textContent || device.name;
                saveDeviceToStorage(device.id, finalDeviceName);

                // Update UI
                updateConnectionStatus(true);
                controls.style.display = 'block';
                biorhythmSection.style.display = 'block';
                connectBtn.style.display = 'none';
                reconnectBtn.style.display = 'none';
                disconnectBtn.style.display = '';

                logDebug('=== Reconnection Complete ===', 'success');

            } catch (error) {
                console.error('Reconnection failed:', error);
                logDebug(`‚ùå Reconnection failed: ${error.name} - ${error.message}`, 'error');
                if (error.stack) {
                    logDebug(`Stack: ${error.stack}`, 'error');
                }
                showError(`Failed to reconnect: ${error.message}`);
                updateConnectionStatus(false);
                updateButtonVisibility();
            }
        }

        async function disconnect() {
            logDebug('User requested disconnect', 'info');
            userDisconnected = true;

            // Clear any pending reconnect attempts
            if (reconnectTimer) {
                clearTimeout(reconnectTimer);
                reconnectTimer = null;
            }

            if (device && device.gatt.connected) {
                device.gatt.disconnect();
                logDebug('Disconnect command sent', 'info');
            } else {
                logDebug('No active connection to disconnect', 'warn');
            }
        }

        async function attemptReconnect() {
            if (userDisconnected || isReconnecting) {
                return;
            }

            // Auto-reconnect only works if we still have the device object in memory
            // (Web Bluetooth doesn't allow reconnecting without user gesture after page reload)
            if (!device || !device.gatt) {
                logDebug('‚ùå Cannot auto-reconnect: device object not in memory (page was reloaded)', 'error');
                showError('Connection lost. Please click Reconnect button.');
                updateButtonVisibility();
                return;
            }

            isReconnecting = true;
            reconnectAttempts++;

            const delayMs = reconnectBaseDelay * reconnectAttempts; // Linear backoff
            logDebug(`Reconnect attempt ${reconnectAttempts}/${maxReconnectAttempts} in ${delayMs/1000}s...`, 'warn');

            reconnectTimer = setTimeout(async () => {
                try {
                    logDebug(`Attempting to reconnect to ${device.name}...`, 'info');

                    server = await device.gatt.connect();
                    logDebug('‚úì Reconnected to GATT server', 'success');

                    // Re-establish characteristics
                    const bedjetService = await server.getPrimaryService(BEDJET_SERVICE_UUID);
                    commandCharacteristic = await bedjetService.getCharacteristic(BEDJET_COMMAND_UUID);

                    const statusCharacteristic = await bedjetService.getCharacteristic(BEDJET_STATUS_UUID);
                    await statusCharacteristic.startNotifications();
                    statusCharacteristic.addEventListener('characteristicvaluechanged', handleStatusUpdate);

                    // Get biodata characteristic (optional)
                    try {
                        biodataCharacteristic = await bedjetService.getCharacteristic(BEDJET_BIODATA_UUID);
                    } catch (error) {
                        biodataCharacteristic = null;
                    }

                    // Update UI
                    updateConnectionStatus(true);
                    controls.style.display = 'block';
                    biorhythmSection.style.display = 'block';
                    connectBtn.style.display = 'none';
                    reconnectBtn.style.display = 'none';
                    disconnectBtn.style.display = '';

                    // Reset reconnect state
                    reconnectAttempts = 0;
                    isReconnecting = false;

                    logDebug('=== Auto-reconnection Complete ===', 'success');
                } catch (error) {
                    logDebug(`Reconnect attempt ${reconnectAttempts} failed: ${error.message}`, 'error');
                    isReconnecting = false;

                    if (reconnectAttempts < maxReconnectAttempts) {
                        attemptReconnect();
                    } else {
                        logDebug(`Max reconnect attempts (${maxReconnectAttempts}) reached. Giving up.`, 'error');
                        showError('Connection lost. Please reconnect manually.');
                        updateButtonVisibility();
                    }
                }
            }, delayMs);
        }

        function onDisconnected() {
            logDebug('Device disconnected', 'warn');
            logDebug(`Device: ${device?.name || 'Unknown'}`, 'info');
            updateConnectionStatus(false);
            controls.style.display = 'none';
            biorhythmSection.style.display = 'none';
            disconnectBtn.style.display = 'none';
            deviceName.textContent = '';
            currentMode = null;
            updateModeButtons();
            updateButtonVisibility();

            // Attempt auto-reconnect if not user-initiated
            if (!userDisconnected) {
                logDebug('Unexpected disconnect - initiating auto-reconnect', 'warn');
                attemptReconnect();
            } else {
                logDebug('User-initiated disconnect - auto-reconnect disabled', 'info');
            }
        }

        function handleStatusUpdate(event) {
            const data = new Uint8Array(event.target.value.buffer);

            if (data.length >= 17) {  // Need at least 17 bytes to read ambient temp at byte 16
                const hexData = Array.from(data).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ');
                console.log('Status data:', hexData);

                // Only log status updates if status logging is enabled
                if (statusLoggingEnabled) {
                    logDebug(`‚óÑ Status update (${data.length} bytes): ${hexData}`, 'info');
                }

                // Parse device-reported temperature bounds (bytes 12, 13)
                // These are dynamic for DRY mode, based on ambient temperature
                const newDeviceMinTemp = data[12];
                const newDeviceMaxTemp = data[13];
                const newAmbientTemp = data[16];

                // Check if bounds have changed
                const boundsChanged = (deviceMinTemp !== newDeviceMinTemp ||
                                      deviceMaxTemp !== newDeviceMaxTemp);

                deviceMinTemp = newDeviceMinTemp;
                deviceMaxTemp = newDeviceMaxTemp;
                ambientTemp = newAmbientTemp;

                if (statusLoggingEnabled && boundsChanged) {
                    const minTempC = Math.round(deviceMinTemp / 2);
                    const maxTempC = Math.round(deviceMaxTemp / 2);
                    const ambientTempC = Math.round(ambientTemp / 2);
                    logDebug(`  Device temp bounds: ${minTempC}-${maxTempC}¬∞C (ambient: ${ambientTempC}¬∞C)`, 'info');
                }

                // Update temperature slider range if bounds changed (important for DRY mode)
                if (boundsChanged && currentMode === 'dry') {
                    updateTempSliderRange();
                }

                // Parse current temperature (byte 7)
                if (data[7] !== 0 && data[7] !== 0x26) {
                    const rawCurrent = data[7] - 0x26;
                    const currentTempF = Math.round((rawCurrent + 66) - (rawCurrent / 9));
                    const displayCurrent = displayTemp(currentTempF);
                    currentTempEl.textContent = displayCurrent;
                    if (statusLoggingEnabled) {
                        logDebug(`  Current temp: ${currentTempF}¬∞F (${fToC(currentTempF)}¬∞C) (byte[7]=0x${data[7].toString(16)})`, 'info');
                    }
                }

                // Parse target temperature (byte 8)
                if (data[8] !== 0 && data[8] !== 0x26) {
                    const rawTarget = data[8] - 0x26;
                    const targetTempF = Math.round((rawTarget + 66) - (rawTarget / 9));
                    const displayTarget = displayTemp(targetTempF);

                    // Only update if not dirty (user hasn't changed slider)
                    if (!tempDirty) {
                        targetTempEl.textContent = displayTarget;
                        tempSlider.value = displayTarget;
                        updateSliderFill(tempSlider);
                        updateTempGauge(targetTempF);
                    }

                    if (statusLoggingEnabled) {
                        logDebug(`  Target temp: ${targetTempF}¬∞F (${fToC(targetTempF)}¬∞C) (byte[8]=0x${data[8].toString(16)})`, 'info');
                    }
                }

                // Parse fan speed (byte 10)
                // BedJet formula: fanSpeed = fanByte * 5 + 5
                // fanByte 0 = 5%, fanByte 19 = 100%
                const fanSpeed = data[10] * 5 + 5;
                if (fanSpeed >= 5 && fanSpeed <= 100) {
                    // Only update if not dirty (user hasn't changed slider)
                    if (!fanDirty) {
                        fanSpeedEl.textContent = fanSpeed;
                        fanSlider.value = fanSpeed;
                        updateSliderFill(fanSlider);
                        updateFanGauge(fanSpeed);
                    }

                    if (statusLoggingEnabled) {
                        logDebug(`  Fan speed: ${fanSpeed}% (byte[10]=0x${data[10].toString(16)})`, 'info');
                    }
                }

                // Parse time remaining (bytes 4, 5, 6)
                const hours = data[4];
                const minutes = data[5];
                const seconds = data[6];
                const totalSeconds = hours * 3600 + minutes * 60 + seconds;

                if (totalSeconds > 0) {
                    const h = Math.floor(totalSeconds / 3600);
                    const m = Math.floor((totalSeconds % 3600) / 60);
                    const s = totalSeconds % 60;
                    const timeStr = `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
                    timeRemainingEl.textContent = timeStr;
                    if (statusLoggingEnabled) {
                        logDebug(`  Time remaining: ${timeStr}`, 'info');
                    }
                } else {
                    timeRemainingEl.textContent = '--';
                }

                // Parse mode (bytes 13, 14)
                const byte13 = data[13];
                const byte14 = data[14];

                let detectedMode = null;
                if (byte14 === 0x50 && byte13 === 0x14) {
                    detectedMode = 'off';
                } else if (byte14 === 0x34) {
                    detectedMode = 'cool';
                } else if (byte14 === 0x56) {
                    detectedMode = 'turbo';
                } else if (byte14 === 0x50 && byte13 === 0x2d) {
                    detectedMode = 'heat';
                } else if (byte14 === 0x3e) {
                    detectedMode = 'dry';
                } else if (byte14 === 0x43) {
                    detectedMode = 'ext_ht';
                }

                if (detectedMode) {
                    currentMode = detectedMode;
                    if (statusLoggingEnabled) {
                        logDebug(`  Mode: ${detectedMode.toUpperCase()} (byte[13]=0x${byte13.toString(16)}, byte[14]=0x${byte14.toString(16)})`, 'info');
                    }
                } else {
                    if (statusLoggingEnabled) {
                        logDebug(`  Unknown mode (byte[13]=0x${byte13.toString(16)}, byte[14]=0x${byte14.toString(16)})`, 'warn');
                    }
                }

                updateModeButtons();
            } else {
                if (statusLoggingEnabled) {
                    logDebug(`‚ö† Status update too short: ${data.length} bytes (expected ‚â•15)`, 'warn');
                }
            }
        }

        function updateModeButtons() {
            modeButtons.forEach(btn => {
                if (btn.dataset.mode === currentMode) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            // Update temperature slider range when mode changes
            updateTempSliderRange();
        }

        async function sendCommand(command) {
            if (!commandCharacteristic) {
                showError('Not connected to BedJet');
                logDebug('‚ùå Cannot send command: Not connected', 'error');
                return;
            }

            try {
                const commandArray = new Uint8Array(command);
                const hexCommand = Array.from(commandArray).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ');
                console.log('Sending command:', hexCommand);
                logDebug(`‚ñ∫ Sending command: ${hexCommand}`, 'info');

                await commandCharacteristic.writeValue(commandArray);
                logDebug('‚úì Command sent successfully', 'success');

                await new Promise(resolve => setTimeout(resolve, 300));
            } catch (error) {
                console.error('Command failed:', error);
                logDebug(`‚ùå Command failed: ${error.message}`, 'error');
                showError(`Command failed: ${error.message}`);
            }
        }

        async function setMode(mode) {
            logDebug(`Setting mode to: ${mode.toUpperCase()}`, 'info');
            const modeByte = REVERSE_MODE_MAP[mode];
            if (modeByte === undefined) {
                showError(`Invalid mode: ${mode}`);
                logDebug(`‚ùå Invalid mode: ${mode}`, 'error');
                return;
            }
            logDebug(`  Mode byte: 0x${modeByte.toString(16)}`, 'info');
            await sendCommand([0x01, modeByte]);
        }

        async function setTemperature(temp) {
            logDebug(`Setting temperature to: ${temp}¬∞F`, 'info');
            if (temp < 66 || temp > 104) {
                showError(`Temperature ${temp} out of range (66-104¬∞F)`);
                logDebug(`‚ùå Temperature ${temp}¬∞F out of range (66-104¬∞F)`, 'error');
                return;
            }

            // Convert temperature to BedJet format (matches Python implementations)
            // Formula: temp_byte = (temp - 60) / 9 + (temp - 66) + 0x26
            const tempByte = Math.round((temp - 60) / 9 + (temp - 66) + 0x26);
            const clampedByte = Math.max(0, Math.min(255, tempByte));

            console.log(`Setting temperature ${temp}¬∞F (byte: 0x${clampedByte.toString(16)})`);
            logDebug(`  Temp byte: 0x${clampedByte.toString(16)}`, 'info');
            await sendCommand([0x03, clampedByte]);
        }

        async function setFanSpeed(speed) {
            logDebug(`Setting fan speed to: ${speed}%`, 'info');
            if (speed < 5 || speed > 100) {
                showError(`Fan speed ${speed} out of range (5-100%)`);
                logDebug(`‚ùå Fan speed ${speed}% out of range (5-100%)`, 'error');
                return;
            }

            // Convert percentage to BedJet format
            // BedJet formula: actual_speed = fanByte * 5 + 5
            // Therefore: fanByte = (speed - 5) / 5
            const fanByte = Math.round((speed - 5) / 5);
            logDebug(`  Fan byte: 0x${fanByte.toString(16)}`, 'info');
            await sendCommand([0x07, fanByte]);
        }

        async function setRuntime(minutes) {
            logDebug(`Setting runtime to: ${minutes} minutes`, 'info');
            if (minutes < 1 || minutes > 600) {
                showError(`Runtime ${minutes} out of range (1-600 minutes)`);
                logDebug(`‚ùå Runtime ${minutes} min out of range (1-600 min)`, 'error');
                return;
            }

            // Convert minutes to hours and minutes
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;

            logDebug(`  Runtime: ${hours}h ${mins}m`, 'info');
            await sendCommand([0x02, hours, mins]);
        }

        async function incrementTemperature() {
            logDebug('Increment temperature button pressed', 'info');
            await sendCommand([0x01, 0x12]); // TEMP_UP command
        }

        async function decrementTemperature() {
            logDebug('Decrement temperature button pressed', 'info');
            await sendCommand([0x01, 0x13]); // TEMP_DOWN command
        }

        async function incrementFan() {
            logDebug('Increment fan speed button pressed', 'info');
            await sendCommand([0x01, 0x10]); // FAN_UP command
        }

        async function decrementFan() {
            logDebug('Decrement fan speed button pressed', 'info');
            await sendCommand([0x01, 0x11]); // FAN_DOWN command
        }

        async function activatePreset(preset) {
            logDebug(`Activating memory preset: M${preset}`, 'info');
            if (preset < 1 || preset > 3) {
                showError(`Invalid preset: ${preset}`);
                logDebug(`‚ùå Invalid preset: ${preset}`, 'error');
                return;
            }

            const presetByte = 0x20 + (preset - 1);
            logDebug(`  Preset byte: 0x${presetByte.toString(16)}`, 'info');
            await sendCommand([0x01, presetByte]);
        }

        // Biorhythm functions
        function getNextBioTag() {
            currentBioTag = (currentBioTag % 255) + 1;
            return currentBioTag;
        }

        async function requestBioPacket(fragmentID) {
            if (!biodataCharacteristic) {
                showError('Not connected to BedJet biodata');
                logDebug('‚ùå Cannot request biodata: Not connected', 'error');
                return;
            }

            const tag = getNextBioTag();
            const command = new Uint8Array([0x41, fragmentID, tag]);
            const hexCommand = Array.from(command).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ');

            logDebug(`‚ñ∫ Requesting bio packet: fragment=${fragmentID}, tag=${tag}`, 'info');
            logDebug(`  Command: ${hexCommand}`, 'info');

            // Send the request command
            await commandCharacteristic.writeValue(command);
            logDebug('  Command sent, waiting for device to prepare response...', 'info');

            // Wait a bit for the device to prepare the response
            await new Promise(resolve => setTimeout(resolve, 300));

            // Read the biodata characteristic (NOT notifications - the official app uses readValue!)
            logDebug(`  Reading biodata characteristic...`, 'info');
            const dataView = await biodataCharacteristic.readValue();
            const data = new Uint8Array(dataView.buffer);

            const hexData = Array.from(data).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ');
            logDebug(`‚óÑ Biodata read (${data.length} bytes): ${hexData}`, 'info');

            // Verify response matches our request
            if (data[0] === fragmentID && data[1] === tag) {
                logDebug(`‚úì Biodata response matches request (fragment=${fragmentID}, tag=${tag})`, 'success');
                return data;
            } else {
                logDebug(`‚ö† Biodata response mismatch: expected fragment=${fragmentID} tag=${tag}, got fragment=${data[0]} tag=${data[1]}`, 'warn');
                throw new Error(`Biodata response mismatch: expected fragment=${fragmentID} tag=${tag}, got fragment=${data[0]} tag=${data[1]}`);
            }
        }

        function parseBioNames(data) {
            logDebug(`Parsing bio names (${data.length} bytes)`, 'info');

            // Expected: 2 header bytes + 48 bytes for names (3 √ó 16 bytes) = 50 bytes total
            // But BLE MTU limitations may truncate the response to ~20-23 bytes
            // We need at least: 2 (header) + 16 (Bio1) = 18 bytes minimum
            if (data.length < 18) {
                logDebug(`‚ö† Bio names response too short: ${data.length} bytes (need at least 18)`, 'warn');
                return;
            }

            // Skip first 2 bytes (fragmentID and tag), then parse available names (16 bytes each)
            const names = [];
            const maxBios = Math.min(3, Math.floor((data.length - 2) / 16));
            logDebug(`  Can parse ${maxBios} biorhythm name(s) from ${data.length} bytes`, 'info');

            for (let i = 0; i < 3; i++) {
                const offset = 2 + (i * 16);

                // Check if we have enough bytes for this bio slot
                if (offset + 16 > data.length) {
                    logDebug(`  Bio${i + 1}: Not enough data (need ${offset + 16} bytes, have ${data.length})`, 'warn');
                    names.push(null);
                    continue;
                }

                const nameBytes = data.slice(offset, offset + 16);

                if (nameBytes[0] === 0x01) {
                    names.push(null); // Empty slot
                    logDebug(`  Bio${i + 1}: Empty slot`, 'info');
                } else {
                    // Find null terminator or use all 15 chars (first byte may be status, rest is name)
                    let nameStr = '';
                    for (let j = 0; j < 16; j++) {
                        if (nameBytes[j] === 0) break;
                        // Skip non-printable characters
                        if (nameBytes[j] >= 0x20 && nameBytes[j] <= 0x7E) {
                            nameStr += String.fromCharCode(nameBytes[j]);
                        }
                    }
                    names.push(nameStr.trim() || null);
                    logDebug(`  Bio${i + 1}: "${names[i]}"`, 'info');
                }
            }

            biorhythms.bio1.name = names[0];
            biorhythms.bio2.name = names[1];
            biorhythms.bio3.name = names[2];

            updateBiorhythmsUI();
        }

        function parseSequenceStep(bytes, offset) {
            const mode = bytes[offset];
            const fanStep = bytes[offset + 1];
            const temperature = bytes[offset + 2];
            const hoursByte = bytes[offset + 3];
            const minutes = bytes[offset + 4];

            const hours = hoursByte & 0x7F;
            const clocktime = (hoursByte & 0x80) !== 0;

            return {
                mode,
                fanStep,
                temperature,
                hours,
                minutes,
                clocktime
            };
        }

        function parseBioSequence(data, sequenceNum) {
            logDebug(`Parsing bio sequence ${sequenceNum} (${data.length} bytes)`, 'info');

            if (data.length < 3) {
                logDebug(`‚ö† Bio sequence response too short: ${data.length} bytes`, 'warn');
                return;
            }

            const fragmentID = data[0];
            const tag = data[1];
            const stepCount = data[2];

            logDebug(`  Fragment ID: ${fragmentID}, Tag: ${tag}, Step count: ${stepCount}`, 'info');

            const fragmentNum = (fragmentID - 7) & 3;
            const stepOffset = fragmentNum * 8;

            // Calculate how many steps we SHOULD parse based on the total step count
            const expectedStepsInFragment = Math.min(8, stepCount - stepOffset);

            // Calculate how many steps we CAN parse based on available data (MTU limitation)
            // Each step is 5 bytes, header is 3 bytes
            const availableBytes = data.length - 3;
            const maxParseableSteps = Math.floor(availableBytes / 5);

            // Use the minimum of expected and parseable
            const stepsInFragment = Math.min(expectedStepsInFragment, maxParseableSteps);

            logDebug(`  Fragment num: ${fragmentNum}, Step offset: ${stepOffset}`, 'info');
            logDebug(`  Expected steps: ${expectedStepsInFragment}, Parseable steps: ${maxParseableSteps}, Parsing: ${stepsInFragment}`, 'info');

            if (stepsInFragment < expectedStepsInFragment) {
                logDebug(`  ‚ö† MTU limitation: Only ${data.length} bytes received, can parse ${stepsInFragment}/${expectedStepsInFragment} steps`, 'warn');
            }

            const bioKey = `bio${sequenceNum + 1}`;

            for (let i = 0; i < stepsInFragment; i++) {
                const byteOffset = 3 + (i * 5);

                // Double-check we have enough bytes for this step
                if (byteOffset + 5 > data.length) {
                    logDebug(`    ‚ö† Skipping step ${stepOffset + i}: Not enough data`, 'warn');
                    break;
                }

                const step = parseSequenceStep(data, byteOffset);

                const globalStepNum = stepOffset + i;
                biorhythms[bioKey].steps[globalStepNum] = step;

                const modeName = BIO_MODE_NAMES[step.mode] || 'UNKNOWN';
                const fanPercent = step.fanStep * 5 + 5;
                const tempC = step.temperature / 2;
                const timeType = step.clocktime ? 'clock' : 'duration';

                logDebug(`    Step ${globalStepNum}: ${modeName}, ${fanPercent}%, ${tempC}¬∞C, ${step.hours}:${step.minutes.toString().padStart(2, '0')} (${timeType})`, 'info');
            }

            biorhythms[bioKey].totalSteps = stepCount;

            return { stepCount, fragmentNum };
        }

        async function loadBiorhythm(sequenceNum) {
            logDebug(`Loading biorhythm ${sequenceNum + 1}...`, 'info');

            const startFragment = (sequenceNum * 4) + 7;
            logDebug(`  Start fragment: ${startFragment}`, 'info');
            biorhythms[`bio${sequenceNum + 1}`].steps = [];

            try {
                let currentFragment = startFragment;
                let stepCount = 0;
                let fragmentNum = 0;
                let fragmentsLoaded = 0;

                do {
                    logDebug(`  Loading fragment ${currentFragment} (fragment ${fragmentsLoaded + 1})...`, 'info');
                    const data = await requestBioPacket(currentFragment);
                    const result = parseBioSequence(data, sequenceNum);

                    if (result) {
                        stepCount = result.stepCount;
                        fragmentNum = result.fragmentNum;
                        fragmentsLoaded++;
                        logDebug(`  ‚úì Fragment ${currentFragment} parsed: ${result.stepCount} total steps, fragment ${fragmentNum}`, 'success');
                    }

                    currentFragment++;

                    const nextFragmentFirstStep = (fragmentNum + 1) * 8;
                    if (stepCount <= nextFragmentFirstStep) {
                        logDebug(`  All steps loaded (${stepCount} <= ${nextFragmentFirstStep}), stopping`, 'info');
                        break;
                    }
                } while (fragmentNum < 3);

                logDebug(`‚úì Biorhythm ${sequenceNum + 1} loaded: ${stepCount} steps from ${fragmentsLoaded} fragment(s)`, 'success');
                updateBiorhythmsUI();
            } catch (error) {
                logDebug(`‚ùå Failed to load biorhythm ${sequenceNum + 1}: ${error.message}`, 'error');
                if (error.stack) {
                    logDebug(`  Stack trace: ${error.stack}`, 'error');
                }
                throw error;
            }
        }

        async function loadAllBiorhythms() {
            logDebug('=== Loading All Biorhythms ===', 'info');

            try {
                // Check if biodata characteristic is available
                if (!biodataCharacteristic) {
                    showError('Biodata characteristic not available. Your BedJet may not support biorhythm data.');
                    logDebug('‚ùå Biodata characteristic not available', 'error');
                    return;
                }

                logDebug('Biodata characteristic ready for reading', 'info');
                logDebug('Note: Using READ operations (not notifications) - matching official BedJet app protocol', 'info');

                // First load names
                logDebug('Requesting biorhythm names...', 'info');
                const namesData = await requestBioPacket(4);
                parseBioNames(namesData);

                // Then load all three sequences
                let loadedCount = 0;
                for (let i = 0; i < 3; i++) {
                    if (biorhythms[`bio${i + 1}`].name) {
                        await loadBiorhythm(i);
                        loadedCount++;
                    } else {
                        logDebug(`Skipping Bio${i + 1} (empty slot)`, 'info');
                    }
                }

                document.getElementById('biorhythmsList').style.display = 'block';
                logDebug(`‚úì Biorhythms list displayed (${loadedCount} biorhythm(s) loaded)`, 'success');
                logDebug('=== All Biorhythms Loaded ===', 'success');
            } catch (error) {
                showError(`Failed to load biorhythms: ${error.message}`);
                logDebug(`‚ùå Failed to load biorhythms: ${error.message}`, 'error');
                if (error.stack) {
                    logDebug(`Stack trace: ${error.stack}`, 'error');
                }
            }
        }

        function formatStepTime(step) {
            if (step.clocktime) {
                return `until ${step.hours}:${step.minutes.toString().padStart(2, '0')}`;
            } else {
                if (step.hours > 0) {
                    return `for ${step.hours}h ${step.minutes}m`;
                } else {
                    return `for ${step.minutes}m`;
                }
            }
        }

        function formatStepTemperature(tempHalfC) {
            const tempC = tempHalfC / 2;
            const tempF = Math.round(tempC * 9 / 5 + 32);
            return useCelsius ? `${tempC}¬∞C` : `${tempF}¬∞F`;
        }

        function updateBiorhythmsUI() {
            logDebug('Updating biorhythms UI...', 'info');
            for (let i = 1; i <= 3; i++) {
                const bioKey = `bio${i}`;
                const bio = biorhythms[bioKey];
                const nameEl = document.getElementById(`${bioKey}Name`);
                const stepsEl = document.getElementById(`${bioKey}Steps`);

                if (bio.name) {
                    nameEl.textContent = `${bio.name} (${bio.steps.length} steps)`;
                    logDebug(`  Bio${i}: "${bio.name}" with ${bio.steps.length} steps`, 'info');

                    // Generate steps HTML
                    let stepsHTML = '<div style="font-size: 12px; color: #666;">';
                    bio.steps.forEach((step, idx) => {
                        if (step) {
                            const modeName = BIO_MODE_NAMES[step.mode] || 'UNKNOWN';
                            const fanPercent = step.fanStep * 5 + 5;
                            const temp = formatStepTemperature(step.temperature);
                            const time = formatStepTime(step);

                            stepsHTML += `<div style="padding: 8px; margin-bottom: 5px; background: #f9f9f9; border-radius: 4px;">`;
                            stepsHTML += `<strong>Step ${idx + 1}:</strong> ${modeName} @ ${temp}, Fan ${fanPercent}%, ${time}`;
                            stepsHTML += `</div>`;
                        }
                    });
                    stepsHTML += '</div>';
                    stepsEl.innerHTML = stepsHTML;
                } else {
                    nameEl.textContent = 'Empty';
                    stepsEl.innerHTML = '<div style="font-size: 12px; color: #999;">No biorhythm configured</div>';
                    logDebug(`  Bio${i}: Empty slot`, 'info');
                }
            }
            logDebug('‚úì Biorhythms UI updated', 'success');
        }

        // Note: handleBiodataUpdate is no longer used
        // The official BedJet app uses READ operations (readCharacteristic), not notifications
        // for biodata. We now use direct readValue() calls in requestBioPacket() instead.

        function updateConnectionStatus(connected) {
            if (connected) {
                statusIndicator.classList.add('connected');
                statusText.textContent = 'Connected';
            } else {
                statusIndicator.classList.remove('connected');
                statusText.textContent = 'Not Connected';
            }
        }

        function showError(message) {
            errorDiv.textContent = message;
            errorDiv.classList.add('show');
            setTimeout(() => hideError(), 5000);
        }

        function hideError() {
            errorDiv.classList.remove('show');
        }

        function updateButtonVisibility() {
            const savedDevice = getSavedDevice();

            if (device && device.gatt && device.gatt.connected) {
                // Currently connected
                connectBtn.style.display = 'none';
                reconnectBtn.style.display = 'none';
                disconnectBtn.style.display = '';
            } else if (savedDevice) {
                // Not connected, but have saved device
                connectBtn.style.display = '';
                reconnectBtn.style.display = '';
                disconnectBtn.style.display = 'none';
                savedDeviceNameEl.textContent = savedDevice.name;
            } else {
                // Not connected, no saved device
                connectBtn.style.display = '';
                reconnectBtn.style.display = 'none';
                disconnectBtn.style.display = 'none';
            }
        }

        // Initialize button visibility on page load
        function initializeApp() {
            // Initialize debug logging checkboxes
            enableDebugLoggingCheckbox.checked = debugLoggingEnabled;
            enableStatusLoggingCheckbox.checked = statusLoggingEnabled;

            const savedDevice = getSavedDevice();
            if (savedDevice) {
                logDebug(`Found saved device: ${savedDevice.name} (${savedDevice.id})`, 'info');
            } else {
                logDebug('No saved device found', 'info');
            }
            updateButtonVisibility();
        }

        // PWA Service Worker Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('bedjet-bluetooth-control-sw.js')
                    .then(registration => {
                        logDebug('‚úì Service Worker registered successfully', 'success');
                        console.log('ServiceWorker registration successful:', registration.scope);
                    })
                    .catch(error => {
                        logDebug(`‚ö† Service Worker registration failed: ${error}`, 'warn');
                        console.log('ServiceWorker registration failed:', error);
                    });

                // Initialize app after page load
                initializeApp();
            });
        } else {
            // Initialize app even if service worker not available
            initializeApp();
        }
    </script>
</body>
</html>
