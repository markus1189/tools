<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Control BedJet climate comfort system via Bluetooth LE with real-time status monitoring">
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="BedJet Control">
    <link rel="manifest" href="bedjet-bluetooth-control.manifest.json">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='80' font-size='80'>üõèÔ∏è</text></svg>">
    <title>BedJet Bluetooth Control</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            width: 100%;
            padding: 30px;
        }

        h1 {
            font-size: 28px;
            color: #333;
            margin-bottom: 10px;
            text-align: center;
        }

        .subtitle {
            text-align: center;
            color: #666;
            font-size: 14px;
            margin-bottom: 25px;
        }

        .status-bar {
            background: #f5f5f5;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            background: #ccc;
        }

        .status-indicator.connected {
            background: #4caf50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        .status-text {
            font-weight: 600;
            color: #333;
        }

        .device-name {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .btn {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 15px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-danger {
            background: #f44336;
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            background: #d32f2f;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .state-section {
            background: #f9f9f9;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .state-section h2 {
            font-size: 18px;
            color: #333;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }

        .state-section h2::before {
            content: "";
            display: inline-block;
            width: 4px;
            height: 18px;
            background: #667eea;
            margin-right: 10px;
            border-radius: 2px;
        }

        .state-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .state-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .state-label {
            font-size: 12px;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
        }

        .state-value {
            font-size: 24px;
            font-weight: 700;
            color: #333;
        }

        .state-unit {
            font-size: 16px;
            color: #999;
            margin-left: 3px;
        }

        .control-section {
            margin-bottom: 20px;
        }

        .control-section h2 {
            font-size: 18px;
            color: #333;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }

        .control-section h2::before {
            content: "";
            display: inline-block;
            width: 4px;
            height: 18px;
            background: #667eea;
            margin-right: 10px;
            border-radius: 2px;
        }

        .mode-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .mode-btn {
            padding: 12px;
            border: 2px solid #e0e0e0;
            background: white;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #666;
        }

        .mode-btn:hover:not(:disabled) {
            border-color: #667eea;
            color: #667eea;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: #667eea;
            color: white;
        }

        .mode-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .slider-control {
            margin-bottom: 20px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
            color: #666;
        }

        .slider-value {
            font-weight: 700;
            color: #667eea;
            font-size: 16px;
        }

        .slider-range {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 11px;
            color: #999;
        }

        .slider-wrapper {
            position: relative;
            padding: 10px 0;
        }

        input[type="range"] {
            width: 100%;
            height: 10px;
            border-radius: 5px;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 var(--value), #e0e0e0 var(--value));
            outline: none;
            -webkit-appearance: none;
            transition: background 0.1s ease;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 26px;
            height: 26px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4), inset 0 0 0 3px #667eea;
            transition: all 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 3px 12px rgba(102, 126, 234, 0.6), inset 0 0 0 3px #667eea;
        }

        input[type="range"]::-webkit-slider-thumb:active {
            transform: scale(1.2);
            box-shadow: 0 4px 16px rgba(102, 126, 234, 0.8), inset 0 0 0 4px #667eea;
        }

        input[type="range"]::-moz-range-thumb {
            width: 26px;
            height: 26px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4), inset 0 0 0 3px #667eea;
            border: none;
            transition: all 0.2s ease;
        }

        input[type="range"]::-moz-range-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 3px 12px rgba(102, 126, 234, 0.6), inset 0 0 0 3px #667eea;
        }

        input[type="range"]::-moz-range-thumb:active {
            transform: scale(1.2);
            box-shadow: 0 4px 16px rgba(102, 126, 234, 0.8), inset 0 0 0 4px #667eea;
        }

        input[type="range"]:disabled {
            opacity: 0.5;
        }

        /* Mobile-optimized touch targets */
        @media (pointer: coarse) {
            input[type="range"]::-webkit-slider-thumb {
                width: 32px;
                height: 32px;
            }

            input[type="range"]::-moz-range-thumb {
                width: 32px;
                height: 32px;
            }
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .preset-btn {
            padding: 12px;
            border: 2px solid #e0e0e0;
            background: white;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #666;
        }

        .preset-btn:hover:not(:disabled) {
            border-color: #764ba2;
            color: #764ba2;
            background: #f5f0ff;
        }

        .preset-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .error {
            background: #ffebee;
            color: #c62828;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 14px;
            display: none;
        }

        .error.show {
            display: block;
        }

        .info {
            background: #e3f2fd;
            color: #1565c0;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 13px;
            line-height: 1.5;
        }

        .debug-section {
            background: #f5f5f5;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            border: 2px solid #e0e0e0;
        }

        .debug-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            cursor: pointer;
            user-select: none;
        }

        .debug-title {
            font-size: 16px;
            font-weight: 700;
            color: #333;
        }

        .debug-toggle {
            font-size: 12px;
            color: #667eea;
            font-weight: 600;
        }

        .debug-buttons {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .debug-btn {
            padding: 8px 12px;
            border: 1px solid #667eea;
            background: white;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            color: #667eea;
            transition: all 0.2s ease;
        }

        .debug-btn:hover {
            background: #667eea;
            color: white;
        }

        .debug-log {
            background: #1e1e1e;
            color: #d4d4d4;
            border-radius: 6px;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            max-height: 300px;
            overflow-y: auto;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            line-height: 1.4;
        }

        .debug-log:empty::before {
            content: "No logs yet. Enable debug logging above to collect logs.";
            color: #888;
        }

        .log-entry {
            margin-bottom: 4px;
            padding: 2px 0;
        }

        .log-time {
            color: #858585;
        }

        .log-level-info {
            color: #4ec9b0;
        }

        .log-level-error {
            color: #f48771;
        }

        .log-level-warn {
            color: #dcdcaa;
        }

        .log-level-success {
            color: #89d185;
        }

        .debug-collapsed .debug-log,
        .debug-collapsed .debug-buttons {
            display: none;
        }

        @media (max-width: 480px) {
            .state-grid {
                grid-template-columns: 1fr;
            }

            .mode-buttons {
                grid-template-columns: repeat(2, 1fr);
            }

            .debug-log {
                font-size: 10px;
                max-height: 250px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üõèÔ∏è BedJet Control</h1>
        <p class="subtitle">Bluetooth LE Control Panel</p>

        <div id="error" class="error"></div>

        <div class="status-bar">
            <div>
                <span class="status-indicator" id="statusIndicator"></span>
                <span class="status-text" id="statusText">Not Connected</span>
            </div>
            <div class="device-name" id="deviceName"></div>
            <div class="device-name" id="lastUpdate" style="font-size: 11px; color: #999; margin-top: 3px;"></div>
        </div>

        <div style="margin-bottom: 15px; padding: 12px; background: #f9f9f9; border-radius: 8px;">
            <label style="display: flex; align-items: center; cursor: pointer; font-size: 14px; color: #666; margin-bottom: 8px;">
                <input type="checkbox" id="showAllDevices" style="margin-right: 8px; cursor: pointer;">
                <span>Show all Bluetooth devices (use if BedJet not found)</span>
            </label>
            <label style="display: flex; align-items: center; cursor: pointer; font-size: 14px; color: #666;">
                <input type="checkbox" id="useCelsius" style="margin-right: 8px; cursor: pointer;">
                <span>Use Celsius (¬∞C) instead of Fahrenheit (¬∞F)</span>
            </label>
        </div>

        <button id="connectBtn" class="btn btn-primary">Connect to BedJet</button>
        <button id="reconnectBtn" class="btn btn-primary" style="display: none;">Reconnect to <span id="savedDeviceName"></span></button>
        <button id="disconnectBtn" class="btn btn-danger" style="display: none;">Disconnect</button>

        <div id="controls" style="display: none;">
            <div class="state-section">
                <h2>Current State</h2>
                <div class="state-grid">
                    <div class="state-item">
                        <div class="state-label">Current Temp</div>
                        <div class="state-value">
                            <span id="currentTemp">--</span><span class="state-unit" id="currentTempUnit">¬∞F</span>
                        </div>
                    </div>
                    <div class="state-item">
                        <div class="state-label">Target Temp</div>
                        <div class="state-value">
                            <span id="targetTemp">--</span><span class="state-unit" id="targetTempUnit">¬∞F</span>
                        </div>
                    </div>
                    <div class="state-item">
                        <div class="state-label">Fan Speed</div>
                        <div class="state-value">
                            <span id="fanSpeed">--</span><span class="state-unit">%</span>
                        </div>
                    </div>
                    <div class="state-item">
                        <div class="state-label">Time Left</div>
                        <div class="state-value">
                            <span id="timeRemaining">--</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="control-section">
                <h2>Mode</h2>
                <div class="mode-buttons">
                    <button class="mode-btn" data-mode="off">OFF</button>
                    <button class="mode-btn" data-mode="cool">COOL</button>
                    <button class="mode-btn" data-mode="heat">HEAT</button>
                    <button class="mode-btn" data-mode="turbo">TURBO</button>
                    <button class="mode-btn" data-mode="dry">DRY</button>
                    <button class="mode-btn" data-mode="ext_ht">EXT HT</button>
                </div>
            </div>

            <div class="control-section">
                <h2>Temperature</h2>
                <div class="slider-control">
                    <div class="slider-label">
                        <span>Set Temperature</span>
                        <span class="slider-value"><span id="tempSliderValue">72</span><span id="tempSliderUnit">¬∞F</span></span>
                    </div>
                    <div class="slider-wrapper">
                        <input type="range" id="tempSlider" min="66" max="104" value="72" step="1">
                    </div>
                    <div class="slider-range">
                        <span id="tempMin">66¬∞F</span>
                        <span id="tempMax">104¬∞F</span>
                    </div>
                </div>
                <div class="preset-buttons" style="margin-top: 10px;">
                    <button class="preset-btn" id="tempDownBtn">TEMP ‚ñº</button>
                    <button class="preset-btn" id="tempUpBtn">TEMP ‚ñ≤</button>
                </div>
            </div>

            <div class="control-section">
                <h2>Fan Speed</h2>
                <div class="slider-control">
                    <div class="slider-label">
                        <span>Set Fan Speed</span>
                        <span class="slider-value"><span id="fanSliderValue">50</span>%</span>
                    </div>
                    <div class="slider-wrapper">
                        <input type="range" id="fanSlider" min="5" max="100" value="50" step="5">
                    </div>
                    <div class="slider-range">
                        <span>5%</span>
                        <span>100%</span>
                    </div>
                </div>
                <div class="preset-buttons" style="margin-top: 10px;">
                    <button class="preset-btn" id="fanDownBtn">FAN ‚ñº</button>
                    <button class="preset-btn" id="fanUpBtn">FAN ‚ñ≤</button>
                </div>
            </div>

            <div class="control-section">
                <h2>Runtime / Timer</h2>
                <div class="slider-control">
                    <div class="slider-label">
                        <span>Set Runtime</span>
                        <span class="slider-value"><span id="runtimeValue">60</span> min</span>
                    </div>
                    <div class="slider-wrapper">
                        <input type="range" id="runtimeSlider" min="1" max="600" value="60" step="1">
                    </div>
                    <div class="slider-range">
                        <span>1 min</span>
                        <span>600 min (10h)</span>
                    </div>
                </div>
            </div>

            <div class="control-section">
                <h2>Memory Presets</h2>
                <div class="preset-buttons">
                    <button class="preset-btn" data-preset="1">M1</button>
                    <button class="preset-btn" data-preset="2">M2</button>
                    <button class="preset-btn" data-preset="3">M3</button>
                </div>
            </div>

            <div class="control-section">
                <h2>Biorhythms</h2>
                <button class="btn btn-primary" id="loadBiorhythmsBtn" style="margin-bottom: 15px;">Load Biorhythms</button>
                <div id="biorhythmsList" style="display: none;">
                    <div class="biorhythm-item" id="bio1Card" style="margin-bottom: 10px;">
                        <div style="padding: 15px; background: white; border-radius: 8px; border: 2px solid #e0e0e0;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <div>
                                    <div style="font-weight: 700; font-size: 16px; color: #333;">Bio1</div>
                                    <div id="bio1Name" style="font-size: 14px; color: #666; margin-top: 3px;">Not loaded</div>
                                </div>
                                <button class="preset-btn" id="bio1ExpandBtn" style="width: auto; padding: 8px 16px;">View</button>
                            </div>
                            <div id="bio1Steps" style="display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid #e0e0e0;">
                                <!-- Steps will be populated here -->
                            </div>
                        </div>
                    </div>
                    <div class="biorhythm-item" id="bio2Card" style="margin-bottom: 10px;">
                        <div style="padding: 15px; background: white; border-radius: 8px; border: 2px solid #e0e0e0;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <div>
                                    <div style="font-weight: 700; font-size: 16px; color: #333;">Bio2</div>
                                    <div id="bio2Name" style="font-size: 14px; color: #666; margin-top: 3px;">Not loaded</div>
                                </div>
                                <button class="preset-btn" id="bio2ExpandBtn" style="width: auto; padding: 8px 16px;">View</button>
                            </div>
                            <div id="bio2Steps" style="display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid #e0e0e0;">
                                <!-- Steps will be populated here -->
                            </div>
                        </div>
                    </div>
                    <div class="biorhythm-item" id="bio3Card" style="margin-bottom: 10px;">
                        <div style="padding: 15px; background: white; border-radius: 8px; border: 2px solid #e0e0e0;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <div>
                                    <div style="font-weight: 700; font-size: 16px; color: #333;">Bio3</div>
                                    <div id="bio3Name" style="font-size: 14px; color: #666; margin-top: 3px;">Not loaded</div>
                                </div>
                                <button class="preset-btn" id="bio3ExpandBtn" style="width: auto; padding: 8px 16px;">View</button>
                            </div>
                            <div id="bio3Steps" style="display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid #e0e0e0;">
                                <!-- Steps will be populated here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="debug-section">
            <div class="debug-header" onclick="toggleDebugLog()">
                <div class="debug-title">üêõ Debug Log</div>
                <div class="debug-toggle" id="debugToggle">Hide ‚ñ≤</div>
            </div>
            <div style="margin-bottom: 10px; padding: 10px; background: #fff3cd; border-radius: 6px; border: 1px solid #ffc107;">
                <label style="display: flex; align-items: center; cursor: pointer; font-size: 13px; color: #856404; margin-bottom: 8px;">
                    <input type="checkbox" id="enableDebugLogging" style="margin-right: 8px; cursor: pointer;">
                    <span><strong>Enable debug logging</strong> (logs disabled by default to save memory)</span>
                </label>
                <label style="display: flex; align-items: center; cursor: pointer; font-size: 12px; color: #856404; margin-left: 20px;">
                    <input type="checkbox" id="enableStatusLogging" style="margin-right: 8px; cursor: pointer;">
                    <span>Include status notifications (can spam log)</span>
                </label>
            </div>
            <div class="debug-buttons">
                <button class="debug-btn" onclick="copyDebugLog()">üìã Copy Log</button>
                <button class="debug-btn" onclick="clearDebugLog()">üóëÔ∏è Clear</button>
                <button class="debug-btn" onclick="downloadDebugLog()">üíæ Download</button>
            </div>
            <div class="debug-log" id="debugLog"></div>
        </div>
    </div>

    <script>
        // BedJet Bluetooth UUIDs and Constants
        // Service UUID
        const BEDJET_SERVICE_UUID = '00001000-bed0-0080-aa55-4265644a6574';

        // Characteristic UUIDs (all under the same service)
        const BEDJET_STATUS_UUID = '00002000-bed0-0080-aa55-4265644a6574';
        const BEDJET_NAME_UUID = '00002001-bed0-0080-aa55-4265644a6574';
        const BEDJET_COMMAND_UUID = '00002004-bed0-0080-aa55-4265644a6574';
        const BEDJET_BIODATA_UUID = '00002005-bed0-0080-aa55-4265644a6574';

        const MODE_MAP = {
            0x01: 'off',
            0x02: 'cool',
            0x03: 'heat',
            0x04: 'turbo',
            0x05: 'dry',
            0x06: 'ext_ht'
        };

        const REVERSE_MODE_MAP = {
            'off': 0x01,
            'cool': 0x02,
            'heat': 0x03,
            'turbo': 0x04,
            'dry': 0x05,
            'ext_ht': 0x06
        };

        // Biorhythm mode constants
        const BIO_MODE_NAMES = {
            0: 'STANDBY',
            1: 'HEAT',
            2: 'TURBO',
            3: 'EXTHT',
            4: 'COOL',
            5: 'DRY',
            6: 'WAIT'
        };

        // State
        let device = null;
        let server = null;
        let commandCharacteristic = null;
        let biodataCharacteristic = null;
        let currentMode = null;
        let useCelsius = false;
        let lastStatusUpdate = null;

        // Biorhythm state
        let biorhythms = {
            bio1: { name: null, steps: [] },
            bio2: { name: null, steps: [] },
            bio3: { name: null, steps: [] }
        };
        let currentBioTag = 1;

        // Auto-reconnect state
        let reconnectAttempts = 0;
        let maxReconnectAttempts = 10;
        let reconnectBaseDelay = 3000; // 3 seconds
        let reconnectTimer = null;
        let isReconnecting = false;
        let userDisconnected = false;

        // LocalStorage keys
        const STORAGE_KEY_DEVICE_ID = 'bedjet_device_id';
        const STORAGE_KEY_DEVICE_NAME = 'bedjet_device_name';
        const STORAGE_KEY_DEBUG_LOGGING = 'bedjet_debug_logging_enabled';
        const STORAGE_KEY_STATUS_LOGGING = 'bedjet_status_logging_enabled';

        // LocalStorage functions
        function saveDeviceToStorage(deviceId, deviceName) {
            try {
                localStorage.setItem(STORAGE_KEY_DEVICE_ID, deviceId);
                localStorage.setItem(STORAGE_KEY_DEVICE_NAME, deviceName);
                logDebug(`‚úì Device saved to storage: ${deviceName} (${deviceId})`, 'success');
            } catch (error) {
                logDebug(`‚ö† Failed to save device to storage: ${error.message}`, 'warn');
            }
        }

        function getSavedDevice() {
            try {
                const deviceId = localStorage.getItem(STORAGE_KEY_DEVICE_ID);
                const deviceName = localStorage.getItem(STORAGE_KEY_DEVICE_NAME);
                if (deviceId && deviceName) {
                    return { id: deviceId, name: deviceName };
                }
            } catch (error) {
                logDebug(`‚ö† Failed to load device from storage: ${error.message}`, 'warn');
            }
            return null;
        }

        function clearSavedDevice() {
            try {
                localStorage.removeItem(STORAGE_KEY_DEVICE_ID);
                localStorage.removeItem(STORAGE_KEY_DEVICE_NAME);
                logDebug('‚úì Saved device cleared from storage', 'info');
            } catch (error) {
                logDebug(`‚ö† Failed to clear device from storage: ${error.message}`, 'warn');
            }
        }

        function saveDebugLoggingPreference(enabled) {
            try {
                localStorage.setItem(STORAGE_KEY_DEBUG_LOGGING, enabled ? 'true' : 'false');
            } catch (error) {
                console.warn('Failed to save debug logging preference:', error);
            }
        }

        function getDebugLoggingPreference() {
            try {
                const value = localStorage.getItem(STORAGE_KEY_DEBUG_LOGGING);
                return value === 'true';
            } catch (error) {
                return false; // Default to disabled
            }
        }

        function saveStatusLoggingPreference(enabled) {
            try {
                localStorage.setItem(STORAGE_KEY_STATUS_LOGGING, enabled ? 'true' : 'false');
            } catch (error) {
                console.warn('Failed to save status logging preference:', error);
            }
        }

        function getStatusLoggingPreference() {
            try {
                const value = localStorage.getItem(STORAGE_KEY_STATUS_LOGGING);
                return value === 'true';
            } catch (error) {
                return false; // Default to disabled
            }
        }

        // Debug logging
        let debugLoggingEnabled = getDebugLoggingPreference(); // Default to disabled
        let statusLoggingEnabled = getStatusLoggingPreference(); // Default to disabled
        let debugLogContent = '';
        const debugLogEl = document.getElementById('debugLog');

        // Temperature conversion helpers
        function fToC(fahrenheit) {
            return Math.round((fahrenheit - 32) * 5 / 9);
        }

        function cToF(celsius) {
            return Math.round(celsius * 9 / 5 + 32);
        }

        function getTempUnit() {
            return useCelsius ? '¬∞C' : '¬∞F';
        }

        function displayTemp(fahrenheit) {
            return useCelsius ? fToC(fahrenheit) : fahrenheit;
        }

        function inputToFahrenheit(value) {
            return useCelsius ? cToF(value) : value;
        }

        function fahrenheitToInput(fahrenheit) {
            return useCelsius ? fToC(fahrenheit) : fahrenheit;
        }

        function logDebug(message, level = 'info') {
            // Always log to console for browser devtools debugging
            const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false, fractionalSecondDigits: 3 });
            console.log(`[${timestamp}] ${message}`);

            // Only collect logs in UI if debug logging is enabled
            if (!debugLoggingEnabled) {
                return;
            }

            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';

            const timeSpan = document.createElement('span');
            timeSpan.className = 'log-time';
            timeSpan.textContent = `[${timestamp}] `;

            const levelSpan = document.createElement('span');
            levelSpan.className = `log-level-${level}`;
            levelSpan.textContent = message;

            logEntry.appendChild(timeSpan);
            logEntry.appendChild(levelSpan);
            debugLogEl.appendChild(logEntry);

            // Auto-scroll to bottom
            debugLogEl.scrollTop = debugLogEl.scrollHeight;

            // Keep text content for copying
            debugLogContent += `[${timestamp}] ${message}\n`;
        }

        function clearDebugLog() {
            debugLogContent = '';
            debugLogEl.innerHTML = '';
            if (debugLoggingEnabled) {
                logDebug('Debug log cleared', 'info');
            }
        }

        function copyDebugLog() {
            if (!debugLogContent) {
                alert('No logs to copy');
                return;
            }

            navigator.clipboard.writeText(debugLogContent).then(() => {
                logDebug('Log copied to clipboard!', 'success');
                setTimeout(() => alert('Debug log copied to clipboard!'), 100);
            }).catch(err => {
                // Fallback for mobile browsers
                const textArea = document.createElement('textarea');
                textArea.value = debugLogContent;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    logDebug('Log copied to clipboard (fallback)!', 'success');
                    alert('Debug log copied to clipboard!');
                } catch (e) {
                    logDebug('Failed to copy: ' + e.message, 'error');
                    alert('Failed to copy. Error: ' + e.message);
                }
                document.body.removeChild(textArea);
            });
        }

        function downloadDebugLog() {
            if (!debugLogContent) {
                alert('No logs to download');
                return;
            }

            const blob = new Blob([debugLogContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `bedjet-debug-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            logDebug('Log downloaded', 'success');
        }

        function toggleDebugLog() {
            const section = document.querySelector('.debug-section');
            const toggle = document.getElementById('debugToggle');

            if (section.classList.contains('debug-collapsed')) {
                section.classList.remove('debug-collapsed');
                toggle.textContent = 'Hide ‚ñ≤';
            } else {
                section.classList.add('debug-collapsed');
                toggle.textContent = 'Show ‚ñº';
            }
        }

        // UI Elements
        const connectBtn = document.getElementById('connectBtn');
        const reconnectBtn = document.getElementById('reconnectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const savedDeviceNameEl = document.getElementById('savedDeviceName');
        const statusIndicator = document.getElementById('statusIndicator');
        const statusText = document.getElementById('statusText');
        const deviceName = document.getElementById('deviceName');
        const lastUpdateEl = document.getElementById('lastUpdate');
        const controls = document.getElementById('controls');
        const errorDiv = document.getElementById('error');
        const useCelsiusCheckbox = document.getElementById('useCelsius');
        const enableDebugLoggingCheckbox = document.getElementById('enableDebugLogging');
        const enableStatusLoggingCheckbox = document.getElementById('enableStatusLogging');

        // State displays
        const currentTempEl = document.getElementById('currentTemp');
        const currentTempUnitEl = document.getElementById('currentTempUnit');
        const targetTempEl = document.getElementById('targetTemp');
        const targetTempUnitEl = document.getElementById('targetTempUnit');
        const fanSpeedEl = document.getElementById('fanSpeed');
        const timeRemainingEl = document.getElementById('timeRemaining');

        // Controls
        const modeButtons = document.querySelectorAll('.mode-btn');
        const tempSlider = document.getElementById('tempSlider');
        const tempSliderValue = document.getElementById('tempSliderValue');
        const tempSliderUnit = document.getElementById('tempSliderUnit');
        const tempUpBtn = document.getElementById('tempUpBtn');
        const tempDownBtn = document.getElementById('tempDownBtn');
        const fanSlider = document.getElementById('fanSlider');
        const fanSliderValue = document.getElementById('fanSliderValue');
        const fanUpBtn = document.getElementById('fanUpBtn');
        const fanDownBtn = document.getElementById('fanDownBtn');
        const runtimeSlider = document.getElementById('runtimeSlider');
        const runtimeValue = document.getElementById('runtimeValue');
        const presetButtons = document.querySelectorAll('.preset-btn');

        // Check Web Bluetooth support
        if (!navigator.bluetooth) {
            showError('Web Bluetooth API is not supported in this browser. Please use Chrome, Edge, or Opera.');
            connectBtn.disabled = true;
            logDebug('‚ùå Web Bluetooth API not supported in this browser', 'error');
            logDebug('User Agent: ' + navigator.userAgent, 'info');
        } else {
            logDebug('‚úì Web Bluetooth API is available', 'success');
            logDebug('User Agent: ' + navigator.userAgent, 'info');
        }

        // Slider fill update
        function updateSliderFill(slider) {
            const min = parseFloat(slider.min);
            const max = parseFloat(slider.max);
            const value = parseFloat(slider.value);
            const percentage = ((value - min) / (max - min)) * 100;
            slider.style.setProperty('--value', `${percentage}%`);
        }

        // Temperature unit toggle
        function updateTemperatureUI() {
            useCelsius = useCelsiusCheckbox.checked;
            const unit = getTempUnit();

            // Update all unit displays
            currentTempUnitEl.textContent = unit;
            targetTempUnitEl.textContent = unit;
            tempSliderUnit.textContent = unit;

            // Update temperature slider range and value
            if (useCelsius) {
                // Convert to Celsius range: 66¬∞F = 19¬∞C, 104¬∞F = 40¬∞C
                tempSlider.min = 19;
                tempSlider.max = 40;
                tempSlider.value = fahrenheitToInput(72); // Default 72¬∞F = 22¬∞C
                tempSliderValue.textContent = tempSlider.value;
                document.getElementById('tempMin').textContent = '19¬∞C';
                document.getElementById('tempMax').textContent = '40¬∞C';
            } else {
                // Fahrenheit range
                tempSlider.min = 66;
                tempSlider.max = 104;
                tempSlider.value = 72;
                tempSliderValue.textContent = 72;
                document.getElementById('tempMin').textContent = '66¬∞F';
                document.getElementById('tempMax').textContent = '104¬∞F';
            }

            // Update slider fill
            updateSliderFill(tempSlider);

            // Update current state displays if they have values
            if (currentTempEl.textContent !== '--') {
                // Re-parse from the stored Fahrenheit values
                // (We'd need to store raw values, for now just update units)
                // This will be properly updated on next status notification
            }

            logDebug(`Temperature unit changed to: ${unit}`, 'info');
        }

        // Event Listeners
        connectBtn.addEventListener('click', connectToBedJet);
        reconnectBtn.addEventListener('click', reconnectToSavedDevice);
        disconnectBtn.addEventListener('click', disconnect);
        useCelsiusCheckbox.addEventListener('change', updateTemperatureUI);
        enableDebugLoggingCheckbox.addEventListener('change', (e) => {
            debugLoggingEnabled = e.target.checked;
            saveDebugLoggingPreference(debugLoggingEnabled);
            if (debugLoggingEnabled) {
                logDebug('‚úì Debug logging enabled', 'success');
            } else {
                console.log('Debug logging disabled');
            }
        });

        enableStatusLoggingCheckbox.addEventListener('change', (e) => {
            statusLoggingEnabled = e.target.checked;
            saveStatusLoggingPreference(statusLoggingEnabled);
            if (debugLoggingEnabled) {
                logDebug(`Status notification logging ${statusLoggingEnabled ? 'enabled' : 'disabled'}`, 'info');
            } else {
                console.log(`Status notification logging ${statusLoggingEnabled ? 'enabled' : 'disabled'}`);
            }
        });

        modeButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                const mode = btn.dataset.mode;
                setMode(mode);
            });
        });

        tempSlider.addEventListener('input', (e) => {
            tempSliderValue.textContent = e.target.value;
            updateSliderFill(e.target);
        });

        tempSlider.addEventListener('change', (e) => {
            const sliderValue = parseInt(e.target.value);
            const fahrenheit = inputToFahrenheit(sliderValue);
            setTemperature(fahrenheit);
        });

        fanSlider.addEventListener('input', (e) => {
            fanSliderValue.textContent = e.target.value;
            updateSliderFill(e.target);
        });

        fanSlider.addEventListener('change', (e) => {
            setFanSpeed(parseInt(e.target.value));
        });

        runtimeSlider.addEventListener('input', (e) => {
            runtimeValue.textContent = e.target.value;
            updateSliderFill(e.target);
        });

        runtimeSlider.addEventListener('change', (e) => {
            setRuntime(parseInt(e.target.value));
        });

        // Initialize slider fills
        updateSliderFill(tempSlider);
        updateSliderFill(fanSlider);
        updateSliderFill(runtimeSlider);

        tempUpBtn.addEventListener('click', () => {
            incrementTemperature();
        });

        tempDownBtn.addEventListener('click', () => {
            decrementTemperature();
        });

        fanUpBtn.addEventListener('click', () => {
            incrementFan();
        });

        fanDownBtn.addEventListener('click', () => {
            decrementFan();
        });

        presetButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                const preset = parseInt(btn.dataset.preset);
                activatePreset(preset);
            });
        });

        // Biorhythm button event listeners
        document.getElementById('loadBiorhythmsBtn').addEventListener('click', () => {
            logDebug('Load biorhythms button clicked', 'info');
            loadAllBiorhythms();
        });

        document.getElementById('bio1ExpandBtn').addEventListener('click', () => {
            const stepsEl = document.getElementById('bio1Steps');
            const btn = document.getElementById('bio1ExpandBtn');
            if (stepsEl.style.display === 'none') {
                stepsEl.style.display = 'block';
                btn.textContent = 'Hide';
                logDebug('Bio1 steps expanded', 'info');
            } else {
                stepsEl.style.display = 'none';
                btn.textContent = 'View';
                logDebug('Bio1 steps collapsed', 'info');
            }
        });

        document.getElementById('bio2ExpandBtn').addEventListener('click', () => {
            const stepsEl = document.getElementById('bio2Steps');
            const btn = document.getElementById('bio2ExpandBtn');
            if (stepsEl.style.display === 'none') {
                stepsEl.style.display = 'block';
                btn.textContent = 'Hide';
                logDebug('Bio2 steps expanded', 'info');
            } else {
                stepsEl.style.display = 'none';
                btn.textContent = 'View';
                logDebug('Bio2 steps collapsed', 'info');
            }
        });

        document.getElementById('bio3ExpandBtn').addEventListener('click', () => {
            const stepsEl = document.getElementById('bio3Steps');
            const btn = document.getElementById('bio3ExpandBtn');
            if (stepsEl.style.display === 'none') {
                stepsEl.style.display = 'block';
                btn.textContent = 'Hide';
                logDebug('Bio3 steps expanded', 'info');
            } else {
                stepsEl.style.display = 'none';
                btn.textContent = 'View';
                logDebug('Bio3 steps collapsed', 'info');
            }
        });

        async function connectToBedJet() {
            try {
                hideError();
                statusText.textContent = 'Scanning...';

                // Reset reconnect state
                userDisconnected = false;
                reconnectAttempts = 0;
                if (reconnectTimer) {
                    clearTimeout(reconnectTimer);
                    reconnectTimer = null;
                }

                const showAll = document.getElementById('showAllDevices').checked;
                logDebug('=== Starting BedJet Connection ===', 'info');
                logDebug(`Show all devices mode: ${showAll}`, 'info');

                // Request BedJet device with fallback options
                const requestOptions = {
                    optionalServices: [
                        BEDJET_SERVICE_UUID
                    ]
                };

                if (showAll) {
                    // Fallback: show all devices (useful if service UUIDs aren't advertised)
                    requestOptions.acceptAllDevices = true;
                    logDebug('Using acceptAllDevices mode (fallback)', 'warn');
                } else {
                    // Default: filter by service UUIDs and name prefix
                    requestOptions.filters = [
                        { services: [BEDJET_SERVICE_UUID] },
                        { namePrefix: 'BedJet' },
                        { namePrefix: 'BEDJET' }
                    ];
                    logDebug('Scanning with filters:', 'info');
                    logDebug(`  - Service UUID: ${BEDJET_SERVICE_UUID}`, 'info');
                    logDebug(`  - Name prefixes: BedJet, BEDJET`, 'info');
                }

                logDebug('Requesting Bluetooth device...', 'info');
                device = await navigator.bluetooth.requestDevice(requestOptions);

                logDebug(`‚úì Device selected: ${device.name || 'Unknown'}`, 'success');
                logDebug(`  Device ID: ${device.id}`, 'info');
                logDebug(`  Device GATT connected: ${device.gatt.connected}`, 'info');

                statusText.textContent = 'Connecting...';
                device.addEventListener('gattserverdisconnected', onDisconnected);

                logDebug('Connecting to GATT server...', 'info');
                server = await device.gatt.connect();
                logDebug('‚úì Connected to GATT server', 'success');

                // Get the BedJet service (all characteristics are under this one service)
                logDebug(`Getting BedJet service (${BEDJET_SERVICE_UUID})...`, 'info');
                const bedjetService = await server.getPrimaryService(BEDJET_SERVICE_UUID);
                logDebug('‚úì Got BedJet service', 'success');

                // Get command characteristic (for sending commands)
                logDebug(`Getting command characteristic (${BEDJET_COMMAND_UUID})...`, 'info');
                commandCharacteristic = await bedjetService.getCharacteristic(BEDJET_COMMAND_UUID);
                logDebug('‚úì Got command characteristic', 'success');
                logDebug(`  Properties: ${Array.from(commandCharacteristic.properties).join(', ')}`, 'info');

                // Get status characteristic (for receiving status updates)
                logDebug(`Getting status characteristic (${BEDJET_STATUS_UUID})...`, 'info');
                const statusCharacteristic = await bedjetService.getCharacteristic(BEDJET_STATUS_UUID);
                logDebug('‚úì Got status characteristic', 'success');
                logDebug(`  Properties: ${Array.from(statusCharacteristic.properties).join(', ')}`, 'info');

                // Subscribe to status notifications
                logDebug('Starting notifications...', 'info');
                await statusCharacteristic.startNotifications();
                statusCharacteristic.addEventListener('characteristicvaluechanged', handleStatusUpdate);
                logDebug('‚úì Notifications enabled', 'success');

                // Get biodata characteristic (for biorhythm data)
                // Note: biodata is optional and only needed for loading biorhythms
                // The official app uses READ operations, not notifications, for biodata
                try {
                    logDebug(`Getting biodata characteristic (${BEDJET_BIODATA_UUID})...`, 'info');
                    biodataCharacteristic = await bedjetService.getCharacteristic(BEDJET_BIODATA_UUID);
                    logDebug('‚úì Got biodata characteristic', 'success');
                    logDebug(`  Properties: ${Array.from(biodataCharacteristic.properties).join(', ')}`, 'info');
                    logDebug('Note: Biodata will be read on-demand when loading biorhythms', 'info');
                } catch (error) {
                    logDebug(`‚ö† Could not get biodata characteristic: ${error.message}`, 'warn');
                    logDebug('  Biorhythm loading will not be available', 'warn');
                    biodataCharacteristic = null;
                }

                // Read device name
                try {
                    logDebug(`Getting name characteristic (${BEDJET_NAME_UUID})...`, 'info');
                    const nameCharacteristic = await bedjetService.getCharacteristic(BEDJET_NAME_UUID);
                    const nameValue = await nameCharacteristic.readValue();
                    const name = new TextDecoder().decode(nameValue);
                    deviceName.textContent = name || device.name;
                    logDebug(`‚úì Device name: ${name || device.name}`, 'success');
                } catch (err) {
                    deviceName.textContent = device.name;
                    logDebug(`‚ö† Could not read device name: ${err.message}`, 'warn');
                }

                // Save device to localStorage
                const finalDeviceName = deviceName.textContent || device.name;
                saveDeviceToStorage(device.id, finalDeviceName);

                // Update UI
                updateConnectionStatus(true);
                controls.style.display = 'block';
                connectBtn.style.display = 'none';
                reconnectBtn.style.display = 'none';
                disconnectBtn.style.display = '';

                logDebug('=== Connection Complete ===', 'success');

            } catch (error) {
                console.error('Connection failed:', error);
                logDebug(`‚ùå Connection failed: ${error.name} - ${error.message}`, 'error');
                if (error.stack) {
                    logDebug(`Stack: ${error.stack}`, 'error');
                }
                showError(`Failed to connect: ${error.message}`);
                updateConnectionStatus(false);
            }
        }

        async function reconnectToSavedDevice() {
            try {
                hideError();
                statusText.textContent = 'Reconnecting...';

                // Reset reconnect state
                userDisconnected = false;
                reconnectAttempts = 0;
                if (reconnectTimer) {
                    clearTimeout(reconnectTimer);
                    reconnectTimer = null;
                }

                const savedDevice = getSavedDevice();
                if (!savedDevice) {
                    showError('No saved device found. Please connect manually.');
                    logDebug('‚ùå No saved device found', 'error');
                    return;
                }

                logDebug('=== Reconnecting to Saved Device ===', 'info');
                logDebug(`Saved device: ${savedDevice.name} (${savedDevice.id})`, 'info');

                // Check if we still have the device object in memory
                if (device && device.id === savedDevice.id && device.gatt) {
                    logDebug('Using existing device object from memory', 'info');
                } else {
                    // Device object lost (page reload) - need to request again with user gesture
                    // This will show the device picker, which should remember the previously paired device
                    logDebug('Device object not in memory, requesting device selection...', 'info');

                    const showAll = document.getElementById('showAllDevices').checked;
                    const requestOptions = {
                        optionalServices: [BEDJET_SERVICE_UUID]
                    };

                    if (showAll) {
                        requestOptions.acceptAllDevices = true;
                    } else {
                        requestOptions.filters = [
                            { services: [BEDJET_SERVICE_UUID] },
                            { namePrefix: 'BedJet' },
                            { namePrefix: 'BEDJET' }
                        ];
                    }

                    device = await navigator.bluetooth.requestDevice(requestOptions);
                    logDebug(`‚úì Device selected: ${device.name || 'Unknown'}`, 'success');
                }

                logDebug(`  Device ID: ${device.id}`, 'info');

                device.addEventListener('gattserverdisconnected', onDisconnected);

                logDebug('Connecting to GATT server...', 'info');
                server = await device.gatt.connect();
                logDebug('‚úì Connected to GATT server', 'success');

                // Get the BedJet service
                logDebug(`Getting BedJet service (${BEDJET_SERVICE_UUID})...`, 'info');
                const bedjetService = await server.getPrimaryService(BEDJET_SERVICE_UUID);
                logDebug('‚úì Got BedJet service', 'success');

                // Get command characteristic
                logDebug(`Getting command characteristic (${BEDJET_COMMAND_UUID})...`, 'info');
                commandCharacteristic = await bedjetService.getCharacteristic(BEDJET_COMMAND_UUID);
                logDebug('‚úì Got command characteristic', 'success');

                // Get status characteristic
                logDebug(`Getting status characteristic (${BEDJET_STATUS_UUID})...`, 'info');
                const statusCharacteristic = await bedjetService.getCharacteristic(BEDJET_STATUS_UUID);
                logDebug('‚úì Got status characteristic', 'success');

                // Subscribe to status notifications
                logDebug('Starting notifications...', 'info');
                await statusCharacteristic.startNotifications();
                statusCharacteristic.addEventListener('characteristicvaluechanged', handleStatusUpdate);
                logDebug('‚úì Notifications enabled', 'success');

                // Get biodata characteristic (optional)
                try {
                    logDebug(`Getting biodata characteristic (${BEDJET_BIODATA_UUID})...`, 'info');
                    biodataCharacteristic = await bedjetService.getCharacteristic(BEDJET_BIODATA_UUID);
                    logDebug('‚úì Got biodata characteristic', 'success');
                    logDebug('Note: Biodata will be read on-demand when loading biorhythms', 'info');
                } catch (error) {
                    logDebug(`‚ö† Could not get biodata characteristic: ${error.message}`, 'warn');
                    logDebug('  Biorhythm loading will not be available', 'warn');
                    biodataCharacteristic = null;
                }

                // Read device name
                try {
                    logDebug(`Getting name characteristic (${BEDJET_NAME_UUID})...`, 'info');
                    const nameCharacteristic = await bedjetService.getCharacteristic(BEDJET_NAME_UUID);
                    const nameValue = await nameCharacteristic.readValue();
                    const name = new TextDecoder().decode(nameValue);
                    deviceName.textContent = name || device.name;
                    logDebug(`‚úì Device name: ${name || device.name}`, 'success');
                } catch (err) {
                    deviceName.textContent = device.name;
                    logDebug(`‚ö† Could not read device name: ${err.message}`, 'warn');
                }

                // Update saved device info (in case it changed)
                const finalDeviceName = deviceName.textContent || device.name;
                saveDeviceToStorage(device.id, finalDeviceName);

                // Update UI
                updateConnectionStatus(true);
                controls.style.display = 'block';
                connectBtn.style.display = 'none';
                reconnectBtn.style.display = 'none';
                disconnectBtn.style.display = '';

                logDebug('=== Reconnection Complete ===', 'success');

            } catch (error) {
                console.error('Reconnection failed:', error);
                logDebug(`‚ùå Reconnection failed: ${error.name} - ${error.message}`, 'error');
                if (error.stack) {
                    logDebug(`Stack: ${error.stack}`, 'error');
                }
                showError(`Failed to reconnect: ${error.message}`);
                updateConnectionStatus(false);
                updateButtonVisibility();
            }
        }

        async function disconnect() {
            logDebug('User requested disconnect', 'info');
            userDisconnected = true;

            // Clear any pending reconnect attempts
            if (reconnectTimer) {
                clearTimeout(reconnectTimer);
                reconnectTimer = null;
            }

            if (device && device.gatt.connected) {
                device.gatt.disconnect();
                logDebug('Disconnect command sent', 'info');
            } else {
                logDebug('No active connection to disconnect', 'warn');
            }
        }

        async function attemptReconnect() {
            if (userDisconnected || isReconnecting) {
                return;
            }

            // Auto-reconnect only works if we still have the device object in memory
            // (Web Bluetooth doesn't allow reconnecting without user gesture after page reload)
            if (!device || !device.gatt) {
                logDebug('‚ùå Cannot auto-reconnect: device object not in memory (page was reloaded)', 'error');
                showError('Connection lost. Please click Reconnect button.');
                updateButtonVisibility();
                return;
            }

            isReconnecting = true;
            reconnectAttempts++;

            const delayMs = reconnectBaseDelay * reconnectAttempts; // Linear backoff
            logDebug(`Reconnect attempt ${reconnectAttempts}/${maxReconnectAttempts} in ${delayMs/1000}s...`, 'warn');

            reconnectTimer = setTimeout(async () => {
                try {
                    logDebug(`Attempting to reconnect to ${device.name}...`, 'info');

                    server = await device.gatt.connect();
                    logDebug('‚úì Reconnected to GATT server', 'success');

                    // Re-establish characteristics
                    const bedjetService = await server.getPrimaryService(BEDJET_SERVICE_UUID);
                    commandCharacteristic = await bedjetService.getCharacteristic(BEDJET_COMMAND_UUID);

                    const statusCharacteristic = await bedjetService.getCharacteristic(BEDJET_STATUS_UUID);
                    await statusCharacteristic.startNotifications();
                    statusCharacteristic.addEventListener('characteristicvaluechanged', handleStatusUpdate);

                    // Get biodata characteristic (optional)
                    try {
                        biodataCharacteristic = await bedjetService.getCharacteristic(BEDJET_BIODATA_UUID);
                    } catch (error) {
                        biodataCharacteristic = null;
                    }

                    // Update UI
                    updateConnectionStatus(true);
                    controls.style.display = 'block';
                    connectBtn.style.display = 'none';
                    reconnectBtn.style.display = 'none';
                    disconnectBtn.style.display = '';

                    // Reset reconnect state
                    reconnectAttempts = 0;
                    isReconnecting = false;

                    logDebug('=== Auto-reconnection Complete ===', 'success');
                } catch (error) {
                    logDebug(`Reconnect attempt ${reconnectAttempts} failed: ${error.message}`, 'error');
                    isReconnecting = false;

                    if (reconnectAttempts < maxReconnectAttempts) {
                        attemptReconnect();
                    } else {
                        logDebug(`Max reconnect attempts (${maxReconnectAttempts}) reached. Giving up.`, 'error');
                        showError('Connection lost. Please reconnect manually.');
                        updateButtonVisibility();
                    }
                }
            }, delayMs);
        }

        function onDisconnected() {
            logDebug('Device disconnected', 'warn');
            logDebug(`Device: ${device?.name || 'Unknown'}`, 'info');
            updateConnectionStatus(false);
            controls.style.display = 'none';
            disconnectBtn.style.display = 'none';
            deviceName.textContent = '';
            currentMode = null;
            updateModeButtons();
            updateButtonVisibility();

            // Attempt auto-reconnect if not user-initiated
            if (!userDisconnected) {
                logDebug('Unexpected disconnect - initiating auto-reconnect', 'warn');
                attemptReconnect();
            } else {
                logDebug('User-initiated disconnect - auto-reconnect disabled', 'info');
            }
        }

        function handleStatusUpdate(event) {
            const data = new Uint8Array(event.target.value.buffer);

            // Update last status timestamp
            lastStatusUpdate = new Date();
            const timeStr = lastStatusUpdate.toLocaleTimeString('en-US', { hour12: false });
            lastUpdateEl.textContent = `Last updated: ${timeStr}`;
            lastUpdateEl.style.color = '#4caf50';

            if (data.length >= 15) {
                const hexData = Array.from(data).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ');
                console.log('Status data:', hexData);

                // Only log status updates if status logging is enabled
                if (statusLoggingEnabled) {
                    logDebug(`‚óÑ Status update (${data.length} bytes): ${hexData}`, 'info');
                }

                // Parse current temperature (byte 7)
                if (data[7] !== 0 && data[7] !== 0x26) {
                    const rawCurrent = data[7] - 0x26;
                    const currentTempF = Math.round((rawCurrent + 66) - (rawCurrent / 9));
                    const displayCurrent = displayTemp(currentTempF);
                    currentTempEl.textContent = displayCurrent;
                    if (statusLoggingEnabled) {
                        logDebug(`  Current temp: ${currentTempF}¬∞F (${fToC(currentTempF)}¬∞C) (byte[7]=0x${data[7].toString(16)})`, 'info');
                    }
                }

                // Parse target temperature (byte 8)
                if (data[8] !== 0 && data[8] !== 0x26) {
                    const rawTarget = data[8] - 0x26;
                    const targetTempF = Math.round((rawTarget + 66) - (rawTarget / 9));
                    const displayTarget = displayTemp(targetTempF);
                    targetTempEl.textContent = displayTarget;
                    if (statusLoggingEnabled) {
                        logDebug(`  Target temp: ${targetTempF}¬∞F (${fToC(targetTempF)}¬∞C) (byte[8]=0x${data[8].toString(16)})`, 'info');
                    }
                }

                // Parse fan speed (byte 10)
                // BedJet formula: fanSpeed = fanByte * 5 + 5
                // fanByte 0 = 5%, fanByte 19 = 100%
                const fanSpeed = data[10] * 5 + 5;
                if (fanSpeed >= 5 && fanSpeed <= 100) {
                    fanSpeedEl.textContent = fanSpeed;
                    if (statusLoggingEnabled) {
                        logDebug(`  Fan speed: ${fanSpeed}% (byte[10]=0x${data[10].toString(16)})`, 'info');
                    }
                }

                // Parse time remaining (bytes 4, 5, 6)
                const hours = data[4];
                const minutes = data[5];
                const seconds = data[6];
                const totalSeconds = hours * 3600 + minutes * 60 + seconds;

                if (totalSeconds > 0) {
                    const h = Math.floor(totalSeconds / 3600);
                    const m = Math.floor((totalSeconds % 3600) / 60);
                    const s = totalSeconds % 60;
                    const timeStr = `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
                    timeRemainingEl.textContent = timeStr;
                    if (statusLoggingEnabled) {
                        logDebug(`  Time remaining: ${timeStr}`, 'info');
                    }
                } else {
                    timeRemainingEl.textContent = '--';
                }

                // Parse mode (bytes 13, 14)
                const byte13 = data[13];
                const byte14 = data[14];

                let detectedMode = null;
                if (byte14 === 0x50 && byte13 === 0x14) {
                    detectedMode = 'off';
                } else if (byte14 === 0x34) {
                    detectedMode = 'cool';
                } else if (byte14 === 0x56) {
                    detectedMode = 'turbo';
                } else if (byte14 === 0x50 && byte13 === 0x2d) {
                    detectedMode = 'heat';
                } else if (byte14 === 0x3e) {
                    detectedMode = 'dry';
                } else if (byte14 === 0x43) {
                    detectedMode = 'ext_ht';
                }

                if (detectedMode) {
                    currentMode = detectedMode;
                    if (statusLoggingEnabled) {
                        logDebug(`  Mode: ${detectedMode.toUpperCase()} (byte[13]=0x${byte13.toString(16)}, byte[14]=0x${byte14.toString(16)})`, 'info');
                    }
                } else {
                    if (statusLoggingEnabled) {
                        logDebug(`  Unknown mode (byte[13]=0x${byte13.toString(16)}, byte[14]=0x${byte14.toString(16)})`, 'warn');
                    }
                }

                updateModeButtons();
            } else {
                if (statusLoggingEnabled) {
                    logDebug(`‚ö† Status update too short: ${data.length} bytes (expected ‚â•15)`, 'warn');
                }
            }
        }

        function updateModeButtons() {
            modeButtons.forEach(btn => {
                if (btn.dataset.mode === currentMode) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        async function sendCommand(command) {
            if (!commandCharacteristic) {
                showError('Not connected to BedJet');
                logDebug('‚ùå Cannot send command: Not connected', 'error');
                return;
            }

            try {
                const commandArray = new Uint8Array(command);
                const hexCommand = Array.from(commandArray).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ');
                console.log('Sending command:', hexCommand);
                logDebug(`‚ñ∫ Sending command: ${hexCommand}`, 'info');

                await commandCharacteristic.writeValue(commandArray);
                logDebug('‚úì Command sent successfully', 'success');

                await new Promise(resolve => setTimeout(resolve, 300));
            } catch (error) {
                console.error('Command failed:', error);
                logDebug(`‚ùå Command failed: ${error.message}`, 'error');
                showError(`Command failed: ${error.message}`);
            }
        }

        async function setMode(mode) {
            logDebug(`Setting mode to: ${mode.toUpperCase()}`, 'info');
            const modeByte = REVERSE_MODE_MAP[mode];
            if (modeByte === undefined) {
                showError(`Invalid mode: ${mode}`);
                logDebug(`‚ùå Invalid mode: ${mode}`, 'error');
                return;
            }
            logDebug(`  Mode byte: 0x${modeByte.toString(16)}`, 'info');
            await sendCommand([0x01, modeByte]);
        }

        async function setTemperature(temp) {
            logDebug(`Setting temperature to: ${temp}¬∞F`, 'info');
            if (temp < 66 || temp > 104) {
                showError(`Temperature ${temp} out of range (66-104¬∞F)`);
                logDebug(`‚ùå Temperature ${temp}¬∞F out of range (66-104¬∞F)`, 'error');
                return;
            }

            // Convert temperature to BedJet format (matches Python implementations)
            // Formula: temp_byte = (temp - 60) / 9 + (temp - 66) + 0x26
            const tempByte = Math.round((temp - 60) / 9 + (temp - 66) + 0x26);
            const clampedByte = Math.max(0, Math.min(255, tempByte));

            console.log(`Setting temperature ${temp}¬∞F (byte: 0x${clampedByte.toString(16)})`);
            logDebug(`  Temp byte: 0x${clampedByte.toString(16)}`, 'info');
            await sendCommand([0x03, clampedByte]);
        }

        async function setFanSpeed(speed) {
            logDebug(`Setting fan speed to: ${speed}%`, 'info');
            if (speed < 5 || speed > 100) {
                showError(`Fan speed ${speed} out of range (5-100%)`);
                logDebug(`‚ùå Fan speed ${speed}% out of range (5-100%)`, 'error');
                return;
            }

            // Convert percentage to BedJet format
            // BedJet formula: actual_speed = fanByte * 5 + 5
            // Therefore: fanByte = (speed - 5) / 5
            const fanByte = Math.round((speed - 5) / 5);
            logDebug(`  Fan byte: 0x${fanByte.toString(16)}`, 'info');
            await sendCommand([0x07, fanByte]);
        }

        async function setRuntime(minutes) {
            logDebug(`Setting runtime to: ${minutes} minutes`, 'info');
            if (minutes < 1 || minutes > 600) {
                showError(`Runtime ${minutes} out of range (1-600 minutes)`);
                logDebug(`‚ùå Runtime ${minutes} min out of range (1-600 min)`, 'error');
                return;
            }

            // Convert minutes to hours and minutes
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;

            logDebug(`  Runtime: ${hours}h ${mins}m`, 'info');
            await sendCommand([0x02, hours, mins]);
        }

        async function incrementTemperature() {
            logDebug('Increment temperature button pressed', 'info');
            await sendCommand([0x01, 0x12]); // TEMP_UP command
        }

        async function decrementTemperature() {
            logDebug('Decrement temperature button pressed', 'info');
            await sendCommand([0x01, 0x13]); // TEMP_DOWN command
        }

        async function incrementFan() {
            logDebug('Increment fan speed button pressed', 'info');
            await sendCommand([0x01, 0x10]); // FAN_UP command
        }

        async function decrementFan() {
            logDebug('Decrement fan speed button pressed', 'info');
            await sendCommand([0x01, 0x11]); // FAN_DOWN command
        }

        async function activatePreset(preset) {
            logDebug(`Activating memory preset: M${preset}`, 'info');
            if (preset < 1 || preset > 3) {
                showError(`Invalid preset: ${preset}`);
                logDebug(`‚ùå Invalid preset: ${preset}`, 'error');
                return;
            }

            const presetByte = 0x20 + (preset - 1);
            logDebug(`  Preset byte: 0x${presetByte.toString(16)}`, 'info');
            await sendCommand([0x01, presetByte]);
        }

        // Biorhythm functions
        function getNextBioTag() {
            currentBioTag = (currentBioTag % 255) + 1;
            return currentBioTag;
        }

        async function requestBioPacket(fragmentID) {
            if (!biodataCharacteristic) {
                showError('Not connected to BedJet biodata');
                logDebug('‚ùå Cannot request biodata: Not connected', 'error');
                return;
            }

            const tag = getNextBioTag();
            const command = new Uint8Array([0x41, fragmentID, tag]);
            const hexCommand = Array.from(command).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ');

            logDebug(`‚ñ∫ Requesting bio packet: fragment=${fragmentID}, tag=${tag}`, 'info');
            logDebug(`  Command: ${hexCommand}`, 'info');

            // Send the request command
            await commandCharacteristic.writeValue(command);
            logDebug('  Command sent, waiting for device to prepare response...', 'info');

            // Wait a bit for the device to prepare the response
            await new Promise(resolve => setTimeout(resolve, 300));

            // Read the biodata characteristic (NOT notifications - the official app uses readValue!)
            logDebug(`  Reading biodata characteristic...`, 'info');
            const dataView = await biodataCharacteristic.readValue();
            const data = new Uint8Array(dataView.buffer);

            const hexData = Array.from(data).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ');
            logDebug(`‚óÑ Biodata read (${data.length} bytes): ${hexData}`, 'info');

            // Verify response matches our request
            if (data[0] === fragmentID && data[1] === tag) {
                logDebug(`‚úì Biodata response matches request (fragment=${fragmentID}, tag=${tag})`, 'success');
                return data;
            } else {
                logDebug(`‚ö† Biodata response mismatch: expected fragment=${fragmentID} tag=${tag}, got fragment=${data[0]} tag=${data[1]}`, 'warn');
                throw new Error(`Biodata response mismatch: expected fragment=${fragmentID} tag=${tag}, got fragment=${data[0]} tag=${data[1]}`);
            }
        }

        function parseBioNames(data) {
            logDebug(`Parsing bio names (${data.length} bytes)`, 'info');

            // Expected: 2 header bytes + 48 bytes for names (3 √ó 16 bytes) = 50 bytes total
            // But BLE MTU limitations may truncate the response to ~20-23 bytes
            // We need at least: 2 (header) + 16 (Bio1) = 18 bytes minimum
            if (data.length < 18) {
                logDebug(`‚ö† Bio names response too short: ${data.length} bytes (need at least 18)`, 'warn');
                return;
            }

            // Skip first 2 bytes (fragmentID and tag), then parse available names (16 bytes each)
            const names = [];
            const maxBios = Math.min(3, Math.floor((data.length - 2) / 16));
            logDebug(`  Can parse ${maxBios} biorhythm name(s) from ${data.length} bytes`, 'info');

            for (let i = 0; i < 3; i++) {
                const offset = 2 + (i * 16);

                // Check if we have enough bytes for this bio slot
                if (offset + 16 > data.length) {
                    logDebug(`  Bio${i + 1}: Not enough data (need ${offset + 16} bytes, have ${data.length})`, 'warn');
                    names.push(null);
                    continue;
                }

                const nameBytes = data.slice(offset, offset + 16);

                if (nameBytes[0] === 0x01) {
                    names.push(null); // Empty slot
                    logDebug(`  Bio${i + 1}: Empty slot`, 'info');
                } else {
                    // Find null terminator or use all 15 chars (first byte may be status, rest is name)
                    let nameStr = '';
                    for (let j = 0; j < 16; j++) {
                        if (nameBytes[j] === 0) break;
                        // Skip non-printable characters
                        if (nameBytes[j] >= 0x20 && nameBytes[j] <= 0x7E) {
                            nameStr += String.fromCharCode(nameBytes[j]);
                        }
                    }
                    names.push(nameStr.trim() || null);
                    logDebug(`  Bio${i + 1}: "${names[i]}"`, 'info');
                }
            }

            biorhythms.bio1.name = names[0];
            biorhythms.bio2.name = names[1];
            biorhythms.bio3.name = names[2];

            updateBiorhythmsUI();
        }

        function parseSequenceStep(bytes, offset) {
            const mode = bytes[offset];
            const fanStep = bytes[offset + 1];
            const temperature = bytes[offset + 2];
            const hoursByte = bytes[offset + 3];
            const minutes = bytes[offset + 4];

            const hours = hoursByte & 0x7F;
            const clocktime = (hoursByte & 0x80) !== 0;

            return {
                mode,
                fanStep,
                temperature,
                hours,
                minutes,
                clocktime
            };
        }

        function parseBioSequence(data, sequenceNum) {
            logDebug(`Parsing bio sequence ${sequenceNum} (${data.length} bytes)`, 'info');

            if (data.length < 3) {
                logDebug(`‚ö† Bio sequence response too short: ${data.length} bytes`, 'warn');
                return;
            }

            const fragmentID = data[0];
            const tag = data[1];
            const stepCount = data[2];

            logDebug(`  Fragment ID: ${fragmentID}, Tag: ${tag}, Step count: ${stepCount}`, 'info');

            const fragmentNum = (fragmentID - 7) & 3;
            const stepOffset = fragmentNum * 8;
            const stepsInFragment = Math.min(8, stepCount - stepOffset);

            logDebug(`  Fragment num: ${fragmentNum}, Step offset: ${stepOffset}, Steps in fragment: ${stepsInFragment}`, 'info');

            const bioKey = `bio${sequenceNum + 1}`;

            for (let i = 0; i < stepsInFragment; i++) {
                const byteOffset = 3 + (i * 5);
                const step = parseSequenceStep(data, byteOffset);

                const globalStepNum = stepOffset + i;
                biorhythms[bioKey].steps[globalStepNum] = step;

                const modeName = BIO_MODE_NAMES[step.mode] || 'UNKNOWN';
                const fanPercent = step.fanStep * 5 + 5;
                const tempC = step.temperature / 2;
                const timeType = step.clocktime ? 'clock' : 'duration';

                logDebug(`    Step ${globalStepNum}: ${modeName}, ${fanPercent}%, ${tempC}¬∞C, ${step.hours}:${step.minutes.toString().padStart(2, '0')} (${timeType})`, 'info');
            }

            biorhythms[bioKey].totalSteps = stepCount;

            return { stepCount, fragmentNum };
        }

        async function loadBiorhythm(sequenceNum) {
            logDebug(`Loading biorhythm ${sequenceNum + 1}...`, 'info');

            const startFragment = (sequenceNum * 4) + 7;
            logDebug(`  Start fragment: ${startFragment}`, 'info');
            biorhythms[`bio${sequenceNum + 1}`].steps = [];

            try {
                let currentFragment = startFragment;
                let stepCount = 0;
                let fragmentNum = 0;
                let fragmentsLoaded = 0;

                do {
                    logDebug(`  Loading fragment ${currentFragment} (fragment ${fragmentsLoaded + 1})...`, 'info');
                    const data = await requestBioPacket(currentFragment);
                    const result = parseBioSequence(data, sequenceNum);

                    if (result) {
                        stepCount = result.stepCount;
                        fragmentNum = result.fragmentNum;
                        fragmentsLoaded++;
                        logDebug(`  ‚úì Fragment ${currentFragment} parsed: ${result.stepCount} total steps, fragment ${fragmentNum}`, 'success');
                    }

                    currentFragment++;

                    const nextFragmentFirstStep = (fragmentNum + 1) * 8;
                    if (stepCount <= nextFragmentFirstStep) {
                        logDebug(`  All steps loaded (${stepCount} <= ${nextFragmentFirstStep}), stopping`, 'info');
                        break;
                    }
                } while (fragmentNum < 3);

                logDebug(`‚úì Biorhythm ${sequenceNum + 1} loaded: ${stepCount} steps from ${fragmentsLoaded} fragment(s)`, 'success');
                updateBiorhythmsUI();
            } catch (error) {
                logDebug(`‚ùå Failed to load biorhythm ${sequenceNum + 1}: ${error.message}`, 'error');
                if (error.stack) {
                    logDebug(`  Stack trace: ${error.stack}`, 'error');
                }
                throw error;
            }
        }

        async function loadAllBiorhythms() {
            logDebug('=== Loading All Biorhythms ===', 'info');

            try {
                // Check if biodata characteristic is available
                if (!biodataCharacteristic) {
                    showError('Biodata characteristic not available. Your BedJet may not support biorhythm data.');
                    logDebug('‚ùå Biodata characteristic not available', 'error');
                    return;
                }

                logDebug('Biodata characteristic ready for reading', 'info');
                logDebug('Note: Using READ operations (not notifications) - matching official BedJet app protocol', 'info');

                // First load names
                logDebug('Requesting biorhythm names...', 'info');
                const namesData = await requestBioPacket(4);
                parseBioNames(namesData);

                // Then load all three sequences
                let loadedCount = 0;
                for (let i = 0; i < 3; i++) {
                    if (biorhythms[`bio${i + 1}`].name) {
                        await loadBiorhythm(i);
                        loadedCount++;
                    } else {
                        logDebug(`Skipping Bio${i + 1} (empty slot)`, 'info');
                    }
                }

                document.getElementById('biorhythmsList').style.display = 'block';
                logDebug(`‚úì Biorhythms list displayed (${loadedCount} biorhythm(s) loaded)`, 'success');
                logDebug('=== All Biorhythms Loaded ===', 'success');
            } catch (error) {
                showError(`Failed to load biorhythms: ${error.message}`);
                logDebug(`‚ùå Failed to load biorhythms: ${error.message}`, 'error');
                if (error.stack) {
                    logDebug(`Stack trace: ${error.stack}`, 'error');
                }
            }
        }

        function formatStepTime(step) {
            if (step.clocktime) {
                return `until ${step.hours}:${step.minutes.toString().padStart(2, '0')}`;
            } else {
                if (step.hours > 0) {
                    return `for ${step.hours}h ${step.minutes}m`;
                } else {
                    return `for ${step.minutes}m`;
                }
            }
        }

        function formatStepTemperature(tempHalfC) {
            const tempC = tempHalfC / 2;
            const tempF = Math.round(tempC * 9 / 5 + 32);
            return useCelsius ? `${tempC}¬∞C` : `${tempF}¬∞F`;
        }

        function updateBiorhythmsUI() {
            logDebug('Updating biorhythms UI...', 'info');
            for (let i = 1; i <= 3; i++) {
                const bioKey = `bio${i}`;
                const bio = biorhythms[bioKey];
                const nameEl = document.getElementById(`${bioKey}Name`);
                const stepsEl = document.getElementById(`${bioKey}Steps`);

                if (bio.name) {
                    nameEl.textContent = `${bio.name} (${bio.steps.length} steps)`;
                    logDebug(`  Bio${i}: "${bio.name}" with ${bio.steps.length} steps`, 'info');

                    // Generate steps HTML
                    let stepsHTML = '<div style="font-size: 12px; color: #666;">';
                    bio.steps.forEach((step, idx) => {
                        if (step) {
                            const modeName = BIO_MODE_NAMES[step.mode] || 'UNKNOWN';
                            const fanPercent = step.fanStep * 5 + 5;
                            const temp = formatStepTemperature(step.temperature);
                            const time = formatStepTime(step);

                            stepsHTML += `<div style="padding: 8px; margin-bottom: 5px; background: #f9f9f9; border-radius: 4px;">`;
                            stepsHTML += `<strong>Step ${idx + 1}:</strong> ${modeName} @ ${temp}, Fan ${fanPercent}%, ${time}`;
                            stepsHTML += `</div>`;
                        }
                    });
                    stepsHTML += '</div>';
                    stepsEl.innerHTML = stepsHTML;
                } else {
                    nameEl.textContent = 'Empty';
                    stepsEl.innerHTML = '<div style="font-size: 12px; color: #999;">No biorhythm configured</div>';
                    logDebug(`  Bio${i}: Empty slot`, 'info');
                }
            }
            logDebug('‚úì Biorhythms UI updated', 'success');
        }

        // Note: handleBiodataUpdate is no longer used
        // The official BedJet app uses READ operations (readCharacteristic), not notifications
        // for biodata. We now use direct readValue() calls in requestBioPacket() instead.

        function updateConnectionStatus(connected) {
            if (connected) {
                statusIndicator.classList.add('connected');
                statusText.textContent = 'Connected';
            } else {
                statusIndicator.classList.remove('connected');
                statusText.textContent = 'Not Connected';
            }
        }

        function showError(message) {
            errorDiv.textContent = message;
            errorDiv.classList.add('show');
            setTimeout(() => hideError(), 5000);
        }

        function hideError() {
            errorDiv.classList.remove('show');
        }

        function updateButtonVisibility() {
            const savedDevice = getSavedDevice();

            if (device && device.gatt && device.gatt.connected) {
                // Currently connected
                connectBtn.style.display = 'none';
                reconnectBtn.style.display = 'none';
                disconnectBtn.style.display = '';
            } else if (savedDevice) {
                // Not connected, but have saved device
                connectBtn.style.display = '';
                reconnectBtn.style.display = '';
                disconnectBtn.style.display = 'none';
                savedDeviceNameEl.textContent = savedDevice.name;
            } else {
                // Not connected, no saved device
                connectBtn.style.display = '';
                reconnectBtn.style.display = 'none';
                disconnectBtn.style.display = 'none';
            }
        }

        // Initialize button visibility on page load
        function initializeApp() {
            // Initialize debug logging checkboxes
            enableDebugLoggingCheckbox.checked = debugLoggingEnabled;
            enableStatusLoggingCheckbox.checked = statusLoggingEnabled;

            const savedDevice = getSavedDevice();
            if (savedDevice) {
                logDebug(`Found saved device: ${savedDevice.name} (${savedDevice.id})`, 'info');
            } else {
                logDebug('No saved device found', 'info');
            }
            updateButtonVisibility();
        }

        // PWA Service Worker Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('bedjet-bluetooth-control-sw.js')
                    .then(registration => {
                        logDebug('‚úì Service Worker registered successfully', 'success');
                        console.log('ServiceWorker registration successful:', registration.scope);
                    })
                    .catch(error => {
                        logDebug(`‚ö† Service Worker registration failed: ${error}`, 'warn');
                        console.log('ServiceWorker registration failed:', error);
                    });

                // Initialize app after page load
                initializeApp();
            });
        } else {
            // Initialize app even if service worker not available
            initializeApp();
        }
    </script>
</body>
</html>
