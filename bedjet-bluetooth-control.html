<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Control your BedJet climate comfort system via Bluetooth LE with real-time status monitoring">
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="JetCommand">
    <link rel="manifest" href="bedjet-bluetooth-control.manifest.json">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='80' font-size='80'>üõèÔ∏è</text></svg>">
    <title>JetCommand</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: linear-gradient(135deg, #9e9e9e 0%, #757575 100%);
            min-height: 100vh;
            padding: 0;
            margin: 0;
            overflow-x: hidden;
            transition: background 0.5s ease;
        }

        .container {
            background: transparent;
            min-height: 100vh;
            width: 100%;
            padding: 0;
            display: flex;
            flex-direction: column;
        }

        /* Hamburger Menu */
        .hamburger {
            position: fixed;
            top: 15px;
            left: 15px;
            width: 40px;
            height: 40px;
            background: #222;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            z-index: 1001;
            transition: all 0.3s ease;
        }

        .hamburger span {
            width: 22px;
            height: 2px;
            background: #ff9800;
            transition: all 0.3s ease;
        }

        .hamburger.active span:nth-child(1) {
            transform: translateY(7px) rotate(45deg);
        }

        .hamburger.active span:nth-child(2) {
            opacity: 0;
        }

        .hamburger.active span:nth-child(3) {
            transform: translateY(-7px) rotate(-45deg);
        }

        .menu-drawer {
            position: fixed;
            top: 0;
            left: -100%;
            width: 280px;
            height: 100vh;
            background: #222;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            transition: left 0.3s ease;
            overflow-y: auto;
            padding: 70px 20px 20px 20px;
        }

        .menu-drawer.open {
            left: 0;
        }

        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .menu-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        .menu-section {
            margin-bottom: 25px;
        }

        .menu-section h3 {
            font-size: 14px;
            color: #777;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
        }

        .back-link {
            display: block;
            color: #888;
            text-decoration: none;
            font-size: 14px;
            padding: 10px 0;
            margin-bottom: 15px;
            border-bottom: 1px solid #333;
        }

        .back-link:hover {
            color: #ff9800;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, #ff9800 0%, #000000 100%);
            padding: 60px 15px 15px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
        }

        .header h1 {
            font-size: 20px;
            font-weight: 700;
            margin: 0;
        }

        .header .status-bar {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
        }

        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            flex-shrink: 0;
        }

        .status-indicator.connected {
            background: #4caf50;
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.8);
        }

        .device-name {
            font-size: 11px;
            opacity: 0.9;
            margin-left: 4px;
        }

        .device-name:not(:empty)::before {
            content: '‚Ä¢ ';
            margin-right: 4px;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        /* Mode Panel */
        .mode-panel {
            margin-bottom: 20px;
        }

        .mode-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 12px;
        }

        .mode-btn {
            padding: 12px 8px;
            border: 2px solid #444;
            background: #222;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #aaa;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
            border-color: #ff9800;
            color: white;
        }

        .time-remaining-display {
            text-align: center;
            padding: 10px;
            background: #222;
            border-radius: 8px;
            font-size: 14px;
            color: #aaa;
        }

        .time-remaining-display .value {
            font-size: 20px;
            font-weight: 700;
            color: #eee;
            margin-left: 8px;
        }

        /* Gauges */
        .gauges-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .gauge-wrapper {
            text-align: center;
        }

        .gauge {
            position: relative;
            width: 140px;
            height: 140px;
            margin: 0 auto 15px auto;
        }

        .gauge-background {
            fill: none;
            stroke: #444;
            stroke-width: 12;
        }

        .gauge-progress {
            fill: none;
            stroke: url(#gaugeGradient);
            stroke-width: 12;
            stroke-linecap: round;
            transition: stroke-dashoffset 0.3s ease;
            transform: rotate(-90deg);
            transform-origin: 50% 50%;
        }

        .gauge-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        .gauge-value {
            font-size: 32px;
            font-weight: 700;
            color: #eee;
            display: block;
        }

        .gauge-unit {
            font-size: 14px;
            color: #aaa;
            display: block;
        }

        .gauge-label {
            font-size: 14px;
            color: #eee;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
        }

        .gauge-sub-value {
            font-size: 12px;
            color: #eee;
            margin-top: 5px;
        }

        .gauge.dirty {
            opacity: 0.7;
        }

        .gauge-actions {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-top: 10px;
        }

        .gauge-actions.hidden {
            display: none;
        }

        .action-btn {
            width: 44px;
            height: 44px;
            border: none;
            border-radius: 8px;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .action-btn.confirm {
            background: #4caf50;
            color: white;
        }

        .action-btn.cancel {
            background: #f44336;
            color: white;
        }

        .control-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin-top: 8px;
        }

        .control-btn {
            width: 48px;
            height: 48px;
            border: 2px solid #ff9800;
            background: #222;
            border-radius: 8px;
            font-size: 20px;
            font-weight: 700;
            color: #ff9800;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .control-btn:active {
            background: #ff9800;
            color: white;
        }

        /* Sliders */
        .slider-wrapper {
            padding: 10px 0;
        }

        input[type="range"] {
            width: 100%;
            height: 10px;
            border-radius: 5px;
            background: linear-gradient(90deg, #ff9800 0%, #f57c00 var(--value), #444 var(--value));
            outline: none;
            -webkit-appearance: none;
            transition: background 0.1s ease;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 26px;
            height: 26px;
            border-radius: 50%;
            background: #222;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(255, 152, 0, 0.4), inset 0 0 0 3px #ff9800;
            transition: all 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 3px 12px rgba(255, 152, 0, 0.6), inset 0 0 0 3px #ff9800;
        }

        input[type="range"]::-webkit-slider-thumb:active {
            transform: scale(1.2);
            box-shadow: 0 4px 16px rgba(255, 152, 0, 0.8), inset 0 0 0 4px #ff9800;
        }

        input[type="range"]::-moz-range-thumb {
            width: 26px;
            height: 26px;
            border-radius: 50%;
            background: #222;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(255, 152, 0, 0.4), inset 0 0 0 3px #ff9800;
            border: none;
            transition: all 0.2s ease;
        }

        input[type="range"]::-moz-range-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 3px 12px rgba(255, 152, 0, 0.6), inset 0 0 0 3px #ff9800;
        }

        input[type="range"]::-moz-range-thumb:active {
            transform: scale(1.2);
            box-shadow: 0 4px 16px rgba(255, 152, 0, 0.8), inset 0 0 0 4px #ff9800;
        }

        input[type="range"]:disabled {
            opacity: 0.5;
        }

        /* Timer Control - Compact Mobile-Friendly Design */
        .timer-control-panel {
            margin-bottom: 15px;
            padding: 12px 15px;
            background: #222;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .timer-info {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .timer-label {
            font-size: 11px;
            color: #aaa;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .timer-value {
            font-size: 18px;
            font-weight: 700;
            color: #eee;
            font-variant-numeric: tabular-nums;
        }

        .timer-value.off {
            color: #777;
        }

        .timer-edit-btn {
            padding: 8px 16px;
            background: #222;
            border: 2px solid #ff9800;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            color: #ff9800;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .timer-edit-btn:active {
            background: #ff9800;
            color: white;
            transform: scale(0.95);
        }

        /* Timer Modal */
        .timer-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: flex-end;
            justify-content: center;
            z-index: 10000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .timer-modal.active {
            opacity: 1;
            pointer-events: auto;
        }

        .timer-modal-content {
            background: #222;
            border-radius: 16px 16px 0 0;
            padding: 20px;
            width: 100%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            transform: translateY(100%);
            transition: transform 0.3s ease;
        }

        .timer-modal.active .timer-modal-content {
            transform: translateY(0);
        }

        .timer-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f0f0f0;
        }

        .timer-modal-title {
            font-size: 18px;
            font-weight: 700;
            color: #eee;
        }

        .timer-modal-close {
            width: 32px;
            height: 32px;
            border: none;
            background: #333;
            border-radius: 50%;
            font-size: 20px;
            color: #aaa;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .timer-modal-close:active {
            background: #444;
            transform: scale(0.9);
        }

        .timer-current-value {
            text-align: center;
            padding: 20px;
            margin-bottom: 20px;
            background: #222;
            border-radius: 8px;
        }

        .timer-current-label {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 5px;
        }

        .timer-current-display {
            font-size: 32px;
            font-weight: 700;
            color: #ff9800;
            font-variant-numeric: tabular-nums;
        }

        .timer-limit-text {
            font-size: 11px;
            color: #777;
            margin-top: 5px;
        }

        .timer-section {
            margin-bottom: 25px;
        }

        .timer-section-title {
            font-size: 13px;
            font-weight: 600;
            color: #aaa;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .timer-presets {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .timer-preset-btn {
            padding: 12px 8px;
            background: #222;
            border: 2px solid #444;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            color: #eee;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .timer-preset-btn:active {
            background: #ff9800;
            border-color: #ff9800;
            color: white;
            transform: scale(0.95);
        }

        .timer-preset-btn.off {
            background: #222;
            color: #777;
        }

        .timer-adjustments {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .timer-adjust-row {
            display: contents;
        }

        .timer-adjust-btn {
            padding: 14px;
            background: #222;
            border: 2px solid #ff9800;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 700;
            color: #ff9800;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .timer-adjust-btn:active {
            background: #ff9800;
            color: white;
            transform: scale(0.95);
        }

        .timer-adjust-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .timer-adjust-btn:disabled:active {
            transform: none;
            background: #222;
            color: #ff9800;
        }

        .timer-adjust-label {
            font-size: 11px;
            opacity: 0.7;
        }

        .timer-modal-actions {
            display: flex;
            gap: 10px;
            margin-top: 25px;
            padding-top: 20px;
            border-top: 2px solid #f0f0f0;
        }

        .timer-modal-btn {
            flex: 1;
            padding: 14px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .timer-modal-btn.cancel {
            background: #333;
            color: #aaa;
        }

        .timer-modal-btn.apply {
            background: #ff9800;
            color: white;
        }

        .timer-modal-btn:active {
            transform: scale(0.95);
        }

        /* Timer Mode Tabs */
        .timer-mode-tabs {
            display: flex;
            gap: 5px;
            background: #333;
            padding: 4px;
            border-radius: 6px;
        }

        .timer-mode-tab {
            padding: 6px 12px;
            background: transparent;
            border: none;
            border-radius: 4px;
            color: #aaa;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .timer-mode-tab.active {
            background: #ff9800;
            color: white;
        }

        /* End Time Picker */
        .endtime-picker-container {
            background: #222;
            border-radius: 8px;
            padding: 15px;
        }

        .endtime-picker-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .endtime-label {
            font-size: 14px;
            color: #aaa;
            font-weight: 600;
            min-width: 60px;
        }

        .endtime-input {
            flex: 1;
            padding: 10px 12px;
            background: #333;
            border: 2px solid #444;
            border-radius: 6px;
            color: #eee;
            font-size: 16px;
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }

        .endtime-input:focus {
            outline: none;
            border-color: #ff9800;
        }

        .endtime-info {
            padding: 10px;
            background: #333;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .endtime-info-label {
            font-size: 12px;
            color: #aaa;
        }

        .endtime-info-value {
            font-size: 16px;
            color: #ff9800;
            font-weight: 700;
        }

        .endtime-warning {
            margin-top: 10px;
            padding: 8px 12px;
            background: rgba(255, 152, 0, 0.15);
            border: 1px solid rgba(255, 152, 0, 0.3);
            border-radius: 6px;
            color: #ff9800;
            font-size: 12px;
            text-align: center;
        }

        /* Mobile-optimized touch targets */
        @media (pointer: coarse) {
            input[type="range"]::-webkit-slider-thumb {
                width: 32px;
                height: 32px;
            }

            input[type="range"]::-moz-range-thumb {
                width: 32px;
                height: 32px;
            }
        }

        /* Memory Presets */
        .memory-section {
            margin: 20px 0;
        }

        .memory-section h2 {
            font-size: 16px;
            color: #eee;
            margin-bottom: 12px;
            font-weight: 600;
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .preset-btn {
            padding: 14px;
            border: 2px solid #444;
            background: #222;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #aaa;
        }

        .preset-btn:active {
            border-color: #764ba2;
            color: #764ba2;
            background: #f5f0ff;
        }

        /* Buttons */
        .btn {
            width: 100%;
            padding: 14px;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-bottom: 12px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
            color: white;
        }

        .btn-danger {
            background: #f44336;
            color: white;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .error {
            background: #ffebee;
            color: #c62828;
            padding: 12px;
            border-radius: 8px;
            margin: 15px 20px;
            font-size: 14px;
            display: none;
        }

        .error.show {
            display: block;
        }

        /* Debug Section */
        .debug-section {
            background: #222;
            border-radius: 10px;
            padding: 15px;
            margin: 20px;
            border: 2px solid #444;
        }

        .debug-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        .debug-title {
            font-size: 16px;
            font-weight: 700;
            color: #eee;
        }

        .debug-toggle {
            font-size: 12px;
            color: #ff9800;
            font-weight: 600;
        }

        .debug-content {
            margin-top: 10px;
            display: none;
        }

        .debug-section:not(.collapsed) .debug-content {
            display: block;
        }

        .debug-section.collapsed .debug-toggle::after {
            content: ' ‚ñº';
        }

        .debug-section:not(.collapsed) .debug-toggle::after {
            content: ' ‚ñ≤';
        }

        .debug-options {
            margin-bottom: 10px;
            padding: 10px;
            background: #222;
            border-radius: 6px;
        }

        .debug-options label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 13px;
            color: #aaa;
            margin-bottom: 8px;
        }

        .debug-options label:last-child {
            margin-bottom: 0;
            margin-left: 20px;
        }

        .debug-options input[type="checkbox"] {
            margin-right: 8px;
            cursor: pointer;
        }

        .debug-buttons {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .debug-btn {
            padding: 8px 12px;
            border: 1px solid #ff9800;
            background: #222;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            color: #ff9800;
            transition: all 0.2s ease;
        }

        .debug-btn:active {
            background: #ff9800;
            color: white;
        }

        .debug-log {
            background: #1e1e1e;
            color: #d4d4d4;
            border-radius: 6px;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            max-height: 250px;
            overflow-y: auto;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            line-height: 1.4;
        }

        .debug-log:empty::before {
            content: "No logs yet. Enable debug logging to collect logs.";
            color: #888;
        }

        .log-entry {
            margin-bottom: 4px;
            padding: 2px 0;
        }

        .log-time {
            color: #858585;
        }

        .log-level-info {
            color: #4ec9b0;
        }

        .log-level-error {
            color: #f48771;
        }

        .log-level-warn {
            color: #dcdcaa;
        }

        .log-level-success {
            color: #89d185;
        }

        /* Empty State */
        .empty-state {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            text-align: center;
            color: #eee;
        }

        .empty-state-content {
            background: rgba(34, 34, 34, 0.6);
            padding: 40px 30px;
            border-radius: 16px;
            max-width: 400px;
            width: 100%;
            border: 2px solid #444;
            backdrop-filter: blur(10px);
        }

        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 20px;
            display: block;
        }

        .empty-state h2 {
            font-size: 24px;
            margin-bottom: 10px;
            color: #ff9800;
        }

        .empty-state p {
            color: #aaa;
            margin-bottom: 30px;
            line-height: 1.5;
        }

        /* Reconnecting Animation */
        .status-indicator.reconnecting {
            background: #ff9800;
            box-shadow: 0 0 8px rgba(255, 152, 0, 0.8);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }

        @media (max-width: 360px) {
            .gauges-container {
                grid-template-columns: 1fr;
            }

            .gauge {
                width: 160px;
                height: 160px;
            }
        }
    </style>
</head>
<body>
    <!-- Hamburger Menu Button -->
    <div class="hamburger" id="hamburger">
        <span></span>
        <span></span>
        <span></span>
    </div>

    <!-- Menu Overlay -->
    <div class="menu-overlay" id="menuOverlay"></div>

    <!-- Menu Drawer -->
    <div class="menu-drawer" id="menuDrawer">
        <a href="index.html" class="back-link">&larr; Tools</a>
        <div class="menu-section">
            <h3>Connection</h3>
            <button id="connectBtn" class="btn btn-primary">Connect to BedJet</button>
            <button id="reconnectBtn" class="btn btn-primary" style="display: none;">Reconnect to <span id="savedDeviceName"></span></button>
            <button id="disconnectBtn" class="btn btn-danger" style="display: none;">Disconnect</button>
        </div>

        <div class="menu-section">
            <h3>Settings</h3>
            <label style="display: flex; align-items: center; cursor: pointer; font-size: 14px; color: #aaa; margin-bottom: 12px;">
                <input type="checkbox" id="showAllDevices" style="margin-right: 8px; cursor: pointer;">
                <span>Show all Bluetooth devices</span>
            </label>
            <label style="display: flex; align-items: center; cursor: pointer; font-size: 14px; color: #aaa; margin-bottom: 12px;">
                <input type="checkbox" id="useCelsius" style="margin-right: 8px; cursor: pointer;">
                <span>Use Fahrenheit (¬∞F)</span>
            </label>
            <label style="display: flex; align-items: center; cursor: pointer; font-size: 14px; color: #aaa; margin-bottom: 12px;">
                <input type="checkbox" id="enableVibration" style="margin-right: 8px; cursor: pointer;">
                <span>Enable haptic feedback</span>
            </label>
            <button id="installBtn" class="btn btn-primary" style="display: none; width: 100%;">Install App</button>
        </div>
    </div>

    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>JetCommand</h1>
            <div class="status-bar">
                <span class="status-indicator" id="statusIndicator"></span>
                <span id="statusText">Not Connected</span>
                <span class="device-name" id="deviceName"></span>
            </div>
        </div>

        <!-- Empty State (Connect Prompt) -->
        <div id="emptyState" class="empty-state">
            <div class="empty-state-content">
                <span class="empty-state-icon">üõèÔ∏è</span>
                <h2>Welcome to JetCommand</h2>
                <p>Connect to your BedJet device to start controlling your sleep comfort.</p>
                <button id="mainConnectBtn" class="btn btn-primary">Connect BedJet</button>
            </div>
        </div>

        <div id="error" class="error"></div>

        <!-- Main Content -->
        <div class="main-content" id="controls" style="display: none;">
            <!-- Mode Panel -->
            <div class="mode-panel">
                <div class="mode-buttons">
                    <button class="mode-btn" data-mode="off">OFF</button>
                    <button class="mode-btn" data-mode="cool">COOL</button>
                    <button class="mode-btn" data-mode="dry">DRY</button>
                    <button class="mode-btn" data-mode="ext_ht">EXT HT</button>
                    <button class="mode-btn" data-mode="heat">HEAT</button>
                    <button class="mode-btn" data-mode="turbo">TURBO</button>
                </div>
                <!-- Compact Timer Control -->
                <div class="timer-control-panel">
                    <div class="timer-info">
                        <span class="timer-label">TIMER</span>
                        <span class="timer-value" id="timeRemaining">--</span>
                    </div>
                    <button class="timer-edit-btn" id="timerEditBtn">Edit</button>
                </div>

                <!-- Timer Modal -->
                <div class="timer-modal" id="timerModal">
                    <div class="timer-modal-content">
                        <div class="timer-modal-header">
                            <div class="timer-modal-title">Set Timer</div>
                            <div class="timer-mode-tabs">
                                <button class="timer-mode-tab active" data-mode="duration">Duration</button>
                                <button class="timer-mode-tab" data-mode="endtime">End Time</button>
                            </div>
                            <button class="timer-modal-close" id="timerModalClose">√ó</button>
                        </div>

                        <div class="timer-current-value">
                            <div class="timer-current-label">CURRENT</div>
                            <div class="timer-current-display" id="timerModalDisplay">--</div>
                            <div class="timer-limit-text" id="timerModalLimit">Max: --</div>
                        </div>

                        <!-- End Time Section (hidden by default) -->
                        <div class="timer-section timer-endtime-section" style="display: none;">
                            <div class="timer-section-title">Set End Time</div>

                            <div class="endtime-picker-container">
                                <div class="endtime-picker-row">
                                    <label class="endtime-label">Time:</label>
                                    <input type="time" id="endTimeInput" class="endtime-input" value="08:00">
                                </div>

                                <div class="endtime-info" id="endTimeInfo">
                                    <div class="endtime-info-label">Timer Duration:</div>
                                    <div class="endtime-info-value" id="endTimeDuration">--</div>
                                </div>

                                <div class="endtime-warning" id="endTimeWarning" style="display: none;">
                                    <span>‚ö†Ô∏è Clamped to max duration</span>
                                </div>
                            </div>
                        </div>

                        <!-- Duration Section (show/hide with tab) -->
                        <div class="timer-section timer-duration-section">
                            <div class="timer-section-title">Quick Presets</div>
                            <div class="timer-presets">
                                <button class="timer-preset-btn off" data-minutes="0">Off</button>
                                <button class="timer-preset-btn" data-minutes="1">1 min</button>
                                <button class="timer-preset-btn" data-minutes="30">30 min</button>
                                <button class="timer-preset-btn" data-minutes="60">1 hour</button>
                                <button class="timer-preset-btn" data-minutes="120">2 hours</button>
                                <button class="timer-preset-btn" data-minutes="180">3 hours</button>
                                <button class="timer-preset-btn" data-minutes="240">4 hours</button>
                                <button class="timer-preset-btn" data-minutes="480">8 hours</button>
                            </div>
                        </div>

                        <div class="timer-section timer-duration-section">
                            <div class="timer-section-title">Fine Tune</div>
                            <div class="timer-adjustments">
                                <button class="timer-adjust-btn" id="timerMinus60">
                                    <span>‚àí1</span>
                                    <span class="timer-adjust-label">hour</span>
                                </button>
                                <button class="timer-adjust-btn" id="timerPlus60">
                                    <span>+1</span>
                                    <span class="timer-adjust-label">hour</span>
                                </button>
                                <button class="timer-adjust-btn" id="timerMinus10">
                                    <span>‚àí10</span>
                                    <span class="timer-adjust-label">min</span>
                                </button>
                                <button class="timer-adjust-btn" id="timerPlus10">
                                    <span>+10</span>
                                    <span class="timer-adjust-label">min</span>
                                </button>
                                <button class="timer-adjust-btn" id="timerMinus1">
                                    <span>‚àí1</span>
                                    <span class="timer-adjust-label">min</span>
                                </button>
                                <button class="timer-adjust-btn" id="timerPlus1">
                                    <span>+1</span>
                                    <span class="timer-adjust-label">min</span>
                                </button>
                            </div>
                        </div>

                        <div class="timer-modal-actions">
                            <button class="timer-modal-btn cancel" id="timerModalCancel">Cancel</button>
                            <button class="timer-modal-btn apply" id="timerModalApply">Apply</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Gauges -->
            <div class="gauges-container">
                <!-- Temperature Gauge -->
                <div class="gauge-wrapper">
                    <div class="gauge-label">TEMPERATURE</div>
                    <div class="gauge" id="tempGauge">
                        <svg width="140" height="140" viewBox="0 0 140 140">
                            <defs>
                                <linearGradient id="gaugeGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#ffb74d;stop-opacity:1" />
                                    <stop offset="100%" style="stop-color:#e65100;stop-opacity:1" />
                                </linearGradient>
                            </defs>
                            <circle class="gauge-background" cx="70" cy="70" r="60"/>
                            <circle class="gauge-progress" id="tempGaugeProgress" cx="70" cy="70" r="60"
                                    stroke-dasharray="377" stroke-dashoffset="377"/>
                        </svg>
                        <div class="gauge-text">
                            <span class="gauge-value" id="targetTemp">--</span>
                            <span class="gauge-unit" id="targetTempUnit">¬∞C</span>
                        </div>
                    </div>
                    <div class="gauge-sub-value">Current: <span id="currentTemp">--</span><span id="currentTempUnit">¬∞C</span></div>
                    <div class="gauge-sub-value" id="tempRangeIndicator" style="font-size: 11px; color: #777; margin-top: 2px;">Range: --</div>
                    <div class="slider-wrapper">
                        <input type="range" id="tempSlider" min="19" max="40" value="22" step="1">
                    </div>
                    <div class="gauge-actions hidden" id="tempActions">
                        <button class="action-btn confirm" id="tempConfirm">‚úì</button>
                        <button class="action-btn cancel" id="tempCancel">‚úó</button>
                    </div>
                    <div class="control-buttons">
                        <button class="control-btn" id="tempDownBtn">‚àí</button>
                        <button class="control-btn" id="tempUpBtn">+</button>
                    </div>
                </div>

                <!-- Fan Gauge -->
                <div class="gauge-wrapper">
                    <div class="gauge-label">FAN SPEED</div>
                    <div class="gauge" id="fanGauge">
                        <svg width="140" height="140" viewBox="0 0 140 140">
                            <circle class="gauge-background" cx="70" cy="70" r="60"/>
                            <circle class="gauge-progress" id="fanGaugeProgress" cx="70" cy="70" r="60"
                                    stroke-dasharray="377" stroke-dashoffset="377"/>
                        </svg>
                        <div class="gauge-text">
                            <span class="gauge-value" id="fanSpeed">--</span>
                            <span class="gauge-unit">%</span>
                        </div>
                    </div>
                    <div class="gauge-sub-value">&nbsp;</div>
                    <div class="gauge-sub-value">&nbsp;</div>
                    <div class="slider-wrapper">
                        <input type="range" id="fanSlider" min="5" max="100" value="50" step="5">
                    </div>
                    <div class="gauge-actions hidden" id="fanActions">
                        <button class="action-btn confirm" id="fanConfirm">‚úì</button>
                        <button class="action-btn cancel" id="fanCancel">‚úó</button>
                    </div>
                    <div class="control-buttons">
                        <button class="control-btn" id="fanDownBtn">‚àí</button>
                        <button class="control-btn" id="fanUpBtn">+</button>
                    </div>
                </div>
            </div>

            <!-- Memory Presets -->
            <div class="memory-section">
                <h2>Memory Presets</h2>
                <div class="preset-buttons">
                    <button class="preset-btn" data-preset="1">M1</button>
                    <button class="preset-btn" data-preset="2">M2</button>
                    <button class="preset-btn" data-preset="3">M3</button>
                </div>
            </div>
        </div>

        <!-- Debug Section -->
        <div class="debug-section collapsed" id="debugSection">
            <div class="debug-header" onclick="toggleDebugLog()">
                <div class="debug-title">üêõ Debug Log</div>
                <div class="debug-toggle"></div>
            </div>
            <div class="debug-content">
                <div class="debug-options">
                    <label>
                        <input type="checkbox" id="enableDebugLogging">
                        <span><strong>Enable debug logging</strong></span>
                    </label>
                    <label>
                        <input type="checkbox" id="enableStatusLogging">
                        <span>Include status notifications</span>
                    </label>
                </div>
                <div class="debug-buttons">
                    <button class="debug-btn" onclick="copyDebugLog()">üìã Copy</button>
                    <button class="debug-btn" onclick="clearDebugLog()">üóëÔ∏è Clear</button>
                    <button class="debug-btn" onclick="downloadDebugLog()">üíæ Download</button>
                </div>
                <div class="debug-log" id="debugLog"></div>
            </div>
        </div>
    </div>

    <script>
        // BedJet Bluetooth UUIDs and Constants
        // Service UUID
        const BEDJET_SERVICE_UUID = '00001000-bed0-0080-aa55-4265644a6574';

        // Characteristic UUIDs (all under the same service)
        const BEDJET_STATUS_UUID = '00002000-bed0-0080-aa55-4265644a6574';
        const BEDJET_NAME_UUID = '00002001-bed0-0080-aa55-4265644a6574';
        const BEDJET_COMMAND_UUID = '00002004-bed0-0080-aa55-4265644a6574';

        const MODE_MAP = {
            0x01: 'off',
            0x02: 'cool',
            0x03: 'heat',
            0x04: 'turbo',
            0x05: 'dry',
            0x06: 'ext_ht'
        };

        const REVERSE_MODE_MAP = {
            'off': 0x01,
            'cool': 0x02,
            'heat': 0x03,
            'turbo': 0x04,
            'dry': 0x05,
            'ext_ht': 0x06
        };

        // Temperature ranges by mode (in Fahrenheit for direct use)
        // Source: https://github.com/markus1189/bedjet-re/blob/main/docs/temperature-ranges.md
        // Note: DRY mode previously attempted dynamic bounds, but byte 13 is the mode indicator (not a temp value).
        // All modes now use static ranges. If dynamic DRY bounds are found in future, update getTempRange().
        const TEMP_RANGES = {
            'heat': { minF: 72, maxF: 104, minC: 22, maxC: 40 },      // Heat: 22-40¬∞C (72-104¬∞F)
            'turbo': { minF: 109, maxF: 109, minC: 43, maxC: 43 },    // Turbo: Fixed 43¬∞C (109.4¬∞F)
            'ext_ht': { minF: 72, maxF: 91, minC: 22, maxC: 33 },     // Extended Heat: 22-33¬∞C (72-91¬∞F)
            'cool': { minF: 66, maxF: 79, minC: 19, maxC: 26 },       // Cool: 19-26¬∞C (66-79¬∞F)
            'dry': { minF: 61, maxF: 88, minC: 16, maxC: 31 },        // Dry: 16-31¬∞C (61-88¬∞F) - static range
            'off': { minF: 66, maxF: 104, minC: 19, maxC: 40 }        // Default range when off
        };

        // Mode-based background colors
        const MODE_COLORS = {
            'off': 'linear-gradient(135deg, #9e9e9e 0%, #757575 100%)',        // Subtle grey
            'cool': 'linear-gradient(135deg, #42a5f5 0%, #1e88e5 100%)',       // Cool blue
            'dry': 'linear-gradient(135deg, #78909c 0%, #546e7a 100%)',        // Neutral blue-grey
            'heat': 'linear-gradient(135deg, #ff9800 0%, #000000 100%)',       // Orange to black (hot)
            'ext_ht': 'linear-gradient(135deg, #ffa726 0%, #000000 100%)',     // Lighter orange to black (extended heat)
            'turbo': 'linear-gradient(135deg, #f57c00 0%, #000000 100%)'       // Darker orange to black (hottest)
        };

        // State
        let device = null;
        let server = null;
        let commandCharacteristic = null;
        let currentMode = null;
        let useCelsius = true;
        let lastStatusUpdate = null;

        // Device-reported dynamic temperature bounds (for DRY mode)
        let deviceMinTemp = null;  // in half-degrees Celsius (raw value from device)
        let deviceMaxTemp = null;  // in half-degrees Celsius (raw value from device)
        let ambientTemp = null;    // in half-degrees Celsius (raw value from device)

        // Gauge/Slider dirty state
        let tempDirty = false;
        let fanDirty = false;
        let tempPendingValue = null;
        let fanPendingValue = null;

        // Timer state
        let timerPendingMinutes = null;  // Store in minutes for easier math
        let deviceMaxHours = null;       // From status byte 10
        let deviceMaxMinutes = null;     // From status byte 11
        let timerMode = 'duration';      // 'duration' or 'endtime'
        let timerEndTime = null;         // Stored as { hours, minutes } when in endtime mode
        let timerClamped = false;        // Track if end time was clamped to max

        // Auto-reconnect state
        let reconnectAttempts = 0;
        let maxReconnectAttempts = 10;
        let reconnectBaseDelay = 3000; // 3 seconds
        let reconnectTimer = null;
        let isReconnecting = false;
        let userDisconnected = false;

        // LocalStorage keys
        const STORAGE_KEY_DEVICE_ID = 'bedjet_device_id';
        const STORAGE_KEY_DEVICE_NAME = 'bedjet_device_name';
        const STORAGE_KEY_DEBUG_LOGGING = 'bedjet_debug_logging_enabled';
        const STORAGE_KEY_STATUS_LOGGING = 'bedjet_status_logging_enabled';
        const STORAGE_KEY_VIBRATION_ENABLED = 'bedjet_vibration_enabled';

        // LocalStorage functions
        function saveDeviceToStorage(deviceId, deviceName) {
            try {
                localStorage.setItem(STORAGE_KEY_DEVICE_ID, deviceId);
                localStorage.setItem(STORAGE_KEY_DEVICE_NAME, deviceName);
                logDebug(`‚úì Device saved to storage: ${deviceName} (${deviceId})`, 'success');
            } catch (error) {
                logDebug(`‚ö† Failed to save device to storage: ${error.message}`, 'warn');
            }
        }

        function getSavedDevice() {
            try {
                const deviceId = localStorage.getItem(STORAGE_KEY_DEVICE_ID);
                const deviceName = localStorage.getItem(STORAGE_KEY_DEVICE_NAME);
                if (deviceId && deviceName) {
                    return { id: deviceId, name: deviceName };
                }
            } catch (error) {
                logDebug(`‚ö† Failed to load device from storage: ${error.message}`, 'warn');
            }
            return null;
        }

        function clearSavedDevice() {
            try {
                localStorage.removeItem(STORAGE_KEY_DEVICE_ID);
                localStorage.removeItem(STORAGE_KEY_DEVICE_NAME);
                logDebug('‚úì Saved device cleared from storage', 'info');
            } catch (error) {
                logDebug(`‚ö† Failed to clear device from storage: ${error.message}`, 'warn');
            }
        }

        function saveDebugLoggingPreference(enabled) {
            try {
                localStorage.setItem(STORAGE_KEY_DEBUG_LOGGING, enabled ? 'true' : 'false');
            } catch (error) {
                console.warn('Failed to save debug logging preference:', error);
            }
        }

        function getDebugLoggingPreference() {
            try {
                const value = localStorage.getItem(STORAGE_KEY_DEBUG_LOGGING);
                return value === 'true';
            } catch (error) {
                return false; // Default to disabled
            }
        }

        function saveStatusLoggingPreference(enabled) {
            try {
                localStorage.setItem(STORAGE_KEY_STATUS_LOGGING, enabled ? 'true' : 'false');
            } catch (error) {
                console.warn('Failed to save status logging preference:', error);
            }
        }

        function getStatusLoggingPreference() {
            try {
                const value = localStorage.getItem(STORAGE_KEY_STATUS_LOGGING);
                return value === 'true';
            } catch (error) {
                return false; // Default to disabled
            }
        }

        function saveVibrationPreference(enabled) {
            try {
                localStorage.setItem(STORAGE_KEY_VIBRATION_ENABLED, enabled ? 'true' : 'false');
            } catch (error) {
                console.warn('Failed to save vibration preference:', error);
            }
        }

        function getVibrationPreference() {
            try {
                const value = localStorage.getItem(STORAGE_KEY_VIBRATION_ENABLED);
                return value === null ? true : value === 'true'; // Default enabled
            } catch (error) {
                return true;
            }
        }

        // Debug logging
        let debugLoggingEnabled = getDebugLoggingPreference(); // Default to disabled
        let statusLoggingEnabled = getStatusLoggingPreference(); // Default to disabled
        let vibrationEnabled = getVibrationPreference(); // Default to enabled
        let debugLogContent = '';
        const debugLogEl = document.getElementById('debugLog');

        /**
         * Trigger haptic feedback if supported and enabled
         * @param {string} pattern - 'success' or 'error'
         */
        function triggerVibration(pattern) {
            if (!vibrationEnabled) return;

            if (!navigator.vibrate) {
                if (debugLoggingEnabled) {
                    logDebug('‚ö† Vibration API not supported', 'warn');
                }
                return;
            }

            const patterns = {
                success: 50,
                error: [50, 100, 50]
            };

            const vibrationPattern = patterns[pattern];
            if (!vibrationPattern) {
                console.warn(`Unknown vibration pattern: ${pattern}`);
                return;
            }

            try {
                navigator.vibrate(vibrationPattern);
                if (debugLoggingEnabled) {
                    logDebug(`üì≥ Vibration: ${pattern}`, 'info');
                }
            } catch (error) {
                if (debugLoggingEnabled) {
                    logDebug(`‚ö† Vibration failed: ${error.message}`, 'warn');
                }
            }
        }

        // Temperature conversion helpers
        function fToC(fahrenheit) {
            return Math.round((fahrenheit - 32) * 5 / 9);
        }

        function cToF(celsius) {
            return Math.round(celsius * 9 / 5 + 32);
        }

        function getTempUnit() {
            return useCelsius ? '¬∞C' : '¬∞F';
        }

        function displayTemp(fahrenheit) {
            return useCelsius ? fToC(fahrenheit) : fahrenheit;
        }

        function inputToFahrenheit(value) {
            return useCelsius ? cToF(value) : value;
        }

        function fahrenheitToInput(fahrenheit) {
            return useCelsius ? fToC(fahrenheit) : fahrenheit;
        }

        function getTempRange(mode = null) {
            const activeMode = mode || currentMode || 'off';
            const range = TEMP_RANGES[activeMode] || TEMP_RANGES['off'];

            // NOTE: Dynamic temperature bounds for DRY mode were previously attempted but could not
            // be reliably identified in the status packet (byte 13 is the mode byte, not a temperature).
            // All modes, including DRY, now use the static ranges defined in TEMP_RANGES.
            // Future: If dynamic bounds are found in a different message or encoding, restore this logic.

            if (useCelsius) {
                return { min: range.minC, max: range.maxC };
            } else {
                return { min: range.minF, max: range.maxF };
            }
        }

        function updateTempSliderRange() {
            const range = getTempRange();
            tempSlider.min = range.min;
            tempSlider.max = range.max;

            // Update range indicator
            const unit = getTempUnit();
            const rangeIndicator = document.getElementById('tempRangeIndicator');
            if (currentMode === 'turbo') {
                rangeIndicator.textContent = `Fixed: ${range.min}${unit}`;
                rangeIndicator.style.color = '#ff9800';
                if (statusLoggingEnabled) {
                    logDebug(`Temperature locked to ${range.min}${unit} for TURBO mode`, 'info');
                }
            } else if (currentMode === 'dry' && ambientTemp !== null && ambientTemp !== 0) {
                // DRY mode - show ambient temperature for reference
                const ambientTempC = Math.round(ambientTemp / 2);
                rangeIndicator.textContent = `Range: ${range.min}-${range.max}${unit} (ambient: ${ambientTempC}¬∞C)`;
                rangeIndicator.style.color = '#999';
                if (statusLoggingEnabled) {
                    logDebug(`Temperature range: ${range.min}-${range.max}${unit} for DRY mode (ambient: ${ambientTempC}¬∞C)`, 'info');
                }
            } else {
                rangeIndicator.textContent = `Range: ${range.min}-${range.max}${unit}`;
                rangeIndicator.style.color = '#999';
                if (statusLoggingEnabled) {
                    logDebug(`Temperature range updated: ${range.min}-${range.max}${unit} for ${(currentMode || 'off').toUpperCase()} mode`, 'info');
                }
            }

            // Clamp current slider value to new range
            const currentValue = parseInt(tempSlider.value);
            if (currentValue < range.min) {
                tempSlider.value = range.min;
                targetTempEl.textContent = range.min;
                logDebug(`Temperature clamped to minimum: ${range.min}${unit}`, 'warn');
            } else if (currentValue > range.max) {
                tempSlider.value = range.max;
                targetTempEl.textContent = range.max;
                logDebug(`Temperature clamped to maximum: ${range.max}${unit}`, 'warn');
            }

            updateSliderFill(tempSlider);

            // Update gauge to reflect current value
            const fahrenheit = inputToFahrenheit(parseInt(tempSlider.value));
            updateTempGauge(fahrenheit);

            // Disable slider for turbo mode (fixed temperature)
            if (currentMode === 'turbo') {
                tempSlider.disabled = true;
                tempSlider.style.opacity = '0.5';
            } else {
                tempSlider.disabled = false;
                tempSlider.style.opacity = '1';
            }
        }

        function logDebug(message, level = 'info') {
            // Always log to console for browser devtools debugging
            const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false, fractionalSecondDigits: 3 });
            console.log(`[${timestamp}] ${message}`);

            // Only collect logs in UI if debug logging is enabled
            if (!debugLoggingEnabled) {
                return;
            }

            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';

            const timeSpan = document.createElement('span');
            timeSpan.className = 'log-time';
            timeSpan.textContent = `[${timestamp}] `;

            const levelSpan = document.createElement('span');
            levelSpan.className = `log-level-${level}`;
            levelSpan.textContent = message;

            logEntry.appendChild(timeSpan);
            logEntry.appendChild(levelSpan);
            debugLogEl.appendChild(logEntry);

            // Auto-scroll to bottom
            debugLogEl.scrollTop = debugLogEl.scrollHeight;

            // Keep text content for copying
            debugLogContent += `[${timestamp}] ${message}\n`;
        }

        function clearDebugLog() {
            debugLogContent = '';
            debugLogEl.innerHTML = '';
            if (debugLoggingEnabled) {
                logDebug('Debug log cleared', 'info');
            }
        }

        function copyDebugLog() {
            if (!debugLogContent) {
                alert('No logs to copy');
                return;
            }

            navigator.clipboard.writeText(debugLogContent).then(() => {
                logDebug('Log copied to clipboard!', 'success');
                setTimeout(() => alert('Debug log copied to clipboard!'), 100);
            }).catch(err => {
                // Fallback for mobile browsers
                const textArea = document.createElement('textarea');
                textArea.value = debugLogContent;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    logDebug('Log copied to clipboard (fallback)!', 'success');
                    alert('Debug log copied to clipboard!');
                } catch (e) {
                    logDebug('Failed to copy: ' + e.message, 'error');
                    alert('Failed to copy. Error: ' + e.message);
                }
                document.body.removeChild(textArea);
            });
        }

        function downloadDebugLog() {
            if (!debugLogContent) {
                alert('No logs to download');
                return;
            }

            const blob = new Blob([debugLogContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `bedjet-debug-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            logDebug('Log downloaded', 'success');
        }

        function toggleDebugLog() {
            const section = document.getElementById('debugSection');
            section.classList.toggle('collapsed');
        }

        // Hamburger menu functions
        function openMenu() {
            hamburger.classList.add('active');
            menuDrawer.classList.add('open');
            menuOverlay.classList.add('active');
        }

        function closeMenu() {
            hamburger.classList.remove('active');
            menuDrawer.classList.remove('open');
            menuOverlay.classList.remove('active');
        }

        function toggleMenu() {
            if (menuDrawer.classList.contains('open')) {
                closeMenu();
            } else {
                openMenu();
            }
        }

        // Gauge update functions
        function updateGauge(gaugeId, value, min, max) {
            const gauge = document.getElementById(gaugeId);
            const circumference = 2 * Math.PI * 60; // r=60
            const percentage = ((value - min) / (max - min)) * 100;
            const offset = circumference - (percentage / 100) * circumference;
            gauge.style.strokeDashoffset = offset;
        }

        function updateTempGauge(tempF) {
            const displayValue = displayTemp(tempF);
            const range = getTempRange();
            updateGauge('tempGaugeProgress', displayValue, range.min, range.max);
        }

        function updateFanGauge(fanPercent) {
            updateGauge('fanGaugeProgress', fanPercent, 5, 100);
        }

        // Timer utility functions
        function getTimerLimits() {
            if (currentMode === 'turbo') {
                return { minMinutes: 1, maxMinutes: 10 };
            }

            // For other modes, use device-reported max
            if (deviceMaxHours !== null && deviceMaxMinutes !== null) {
                const maxMinutes = deviceMaxHours * 60 + deviceMaxMinutes;
                return { minMinutes: 1, maxMinutes: maxMinutes };
            }

            // Fallback if device doesn't report limits
            return { minMinutes: 1, maxMinutes: 600 }; // 10 hours default
        }

        function updateTimerLimitIndicator() {
            // No-op: Timer limits now shown in modal only
            // Kept for backward compatibility with existing calls
        }

        function updateTimerDisplay(minutes) {
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;
            const secs = 0; // User adjustments don't include seconds

            const timeStr = `${hours}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            document.getElementById('timeRemaining').textContent = timeStr;
        }

        function updateTimerButtonStates(currentMinutes, limits) {
            const plus1Btn = document.getElementById('timerPlus1');
            const plus10Btn = document.getElementById('timerPlus10');
            const plus60Btn = document.getElementById('timerPlus60');
            const minus1Btn = document.getElementById('timerMinus1');
            const minus10Btn = document.getElementById('timerMinus10');
            const minus60Btn = document.getElementById('timerMinus60');

            // Disable increment buttons if at or near max
            const atMax = currentMinutes >= limits.maxMinutes;
            plus1Btn.disabled = atMax;
            plus10Btn.disabled = currentMinutes + 10 > limits.maxMinutes;
            plus60Btn.disabled = currentMinutes + 60 > limits.maxMinutes;

            // Disable decrement buttons if at or near min
            const atMin = currentMinutes <= limits.minMinutes;
            minus1Btn.disabled = atMin;
            minus10Btn.disabled = currentMinutes - 10 < limits.minMinutes;
            minus60Btn.disabled = currentMinutes - 60 < limits.minMinutes;
        }

        function adjustTimer(deltaMinutes) {
            // Get current pending value
            let currentMinutes = timerPendingMinutes !== null ? timerPendingMinutes : 0;

            // Apply delta
            let newMinutes = currentMinutes + deltaMinutes;

            // Clamp to limits
            const limits = getTimerLimits();
            newMinutes = Math.max(limits.minMinutes, Math.min(limits.maxMinutes, newMinutes));

            // Update pending value
            timerPendingMinutes = newMinutes;

            // Update modal display immediately (preview)
            updateTimerModalDisplay(newMinutes);

            // Update button states (disable if at limits)
            updateTimerButtonStates(newMinutes, limits);

            // If in end time mode, also update the end time input
            if (timerMode === 'endtime') {
                syncEndTimeInputFromDuration(newMinutes);
            }

            logDebug(`Timer adjusted: ${deltaMinutes > 0 ? '+' : ''}${deltaMinutes} min ‚Üí ${newMinutes} min`, 'info');
        }

        function setTimerPreset(minutes) {
            const limits = getTimerLimits();
            const clampedMinutes = Math.max(limits.minMinutes, Math.min(limits.maxMinutes, minutes));

            timerPendingMinutes = clampedMinutes;
            updateTimerModalDisplay(clampedMinutes);
            updateTimerButtonStates(clampedMinutes, limits);

            logDebug(`Timer preset: ${minutes} min${clampedMinutes !== minutes ? ` (clamped to ${clampedMinutes})` : ''}`, 'info');
        }

        function updateTimerModalDisplay(minutes) {
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;

            let displayStr;
            if (minutes === 0) {
                displayStr = 'Off';
            } else if (hours === 0) {
                displayStr = `${mins} min`;
            } else if (mins === 0) {
                displayStr = `${hours} hour${hours > 1 ? 's' : ''}`;
            } else {
                displayStr = `${hours}h ${mins}m`;
            }

            document.getElementById('timerModalDisplay').textContent = displayStr;
        }

        function openTimerModal() {
            // Initialize pending value from current display
            const timeStr = document.getElementById('timeRemaining').textContent;
            if (timeStr === '--' || timeStr === 'Off') {
                timerPendingMinutes = 0;
            } else {
                const parts = timeStr.split(':');
                timerPendingMinutes = parseInt(parts[0]) * 60 + parseInt(parts[1]);
            }

            // Reset to duration mode by default
            timerMode = 'duration';
            timerClamped = false;
            switchTimerMode('duration');

            // Update modal display and limits
            updateTimerModalDisplay(timerPendingMinutes);
            const limits = getTimerLimits();
            document.getElementById('timerModalLimit').textContent = `Max: ${limits.maxMinutes} min (${Math.floor(limits.maxMinutes / 60)}h)`;
            updateTimerButtonStates(timerPendingMinutes, limits);

            // Show modal
            document.getElementById('timerModal').classList.add('active');
            logDebug('Timer modal opened', 'info');
        }

        function closeTimerModal(apply = false) {
            if (apply && timerPendingMinutes !== null) {
                // Both modes use the same pending minutes value
                setRuntime(timerPendingMinutes);
                logDebug(`Timer applied: ${timerPendingMinutes} min (mode: ${timerMode}${timerClamped ? ', clamped' : ''})`, 'info');
            } else {
                logDebug('Timer modal cancelled', 'info');
            }

            // Reset state
            timerPendingMinutes = null;
            timerClamped = false;

            // Hide modal
            document.getElementById('timerModal').classList.remove('active');
        }

        // UI Elements
        const hamburger = document.getElementById('hamburger');
        const menuDrawer = document.getElementById('menuDrawer');
        const menuOverlay = document.getElementById('menuOverlay');
        const connectBtn = document.getElementById('connectBtn');
        const reconnectBtn = document.getElementById('reconnectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const savedDeviceNameEl = document.getElementById('savedDeviceName');
        const statusIndicator = document.getElementById('statusIndicator');
        const statusText = document.getElementById('statusText');
        const deviceName = document.getElementById('deviceName');
        const controls = document.getElementById('controls');
        const errorDiv = document.getElementById('error');
        const useCelsiusCheckbox = document.getElementById('useCelsius');
        const enableDebugLoggingCheckbox = document.getElementById('enableDebugLogging');
        const enableStatusLoggingCheckbox = document.getElementById('enableStatusLogging');
        const enableVibrationCheckbox = document.getElementById('enableVibration');

        // State displays
        const currentTempEl = document.getElementById('currentTemp');
        const currentTempUnitEl = document.getElementById('currentTempUnit');
        const targetTempEl = document.getElementById('targetTemp');
        const targetTempUnitEl = document.getElementById('targetTempUnit');
        const fanSpeedEl = document.getElementById('fanSpeed');
        const timeRemainingEl = document.getElementById('timeRemaining');

        // Controls
        const modeButtons = document.querySelectorAll('.mode-btn');
        const tempSlider = document.getElementById('tempSlider');
        const tempUpBtn = document.getElementById('tempUpBtn');
        const tempDownBtn = document.getElementById('tempDownBtn');
        const fanSlider = document.getElementById('fanSlider');
        const fanUpBtn = document.getElementById('fanUpBtn');
        const fanDownBtn = document.getElementById('fanDownBtn');
        const presetButtons = document.querySelectorAll('.preset-btn');

        // Check Web Bluetooth support
        if (!navigator.bluetooth) {
            showError('Web Bluetooth API is not supported in this browser. Please use Chrome, Edge, or Opera.');
            connectBtn.disabled = true;
            logDebug('‚ùå Web Bluetooth API not supported in this browser', 'error');
            logDebug('User Agent: ' + navigator.userAgent, 'info');
        } else {
            logDebug('‚úì Web Bluetooth API is available', 'success');
            logDebug('User Agent: ' + navigator.userAgent, 'info');
        }

        // Slider fill update
        function updateSliderFill(slider) {
            const min = parseFloat(slider.min);
            const max = parseFloat(slider.max);
            const value = parseFloat(slider.value);
            const percentage = ((value - min) / (max - min)) * 100;
            slider.style.setProperty('--value', `${percentage}%`);
        }

        // Temperature unit toggle
        function updateTemperatureUI() {
            useCelsius = !useCelsiusCheckbox.checked;
            const unit = getTempUnit();

            // Update all unit displays
            currentTempUnitEl.textContent = unit;
            targetTempUnitEl.textContent = unit;

            // Update temperature slider range based on current mode and unit
            updateTempSliderRange();

            logDebug(`Temperature unit changed to: ${unit}`, 'info');
        }

        // Event Listeners
        hamburger.addEventListener('click', toggleMenu);
        menuOverlay.addEventListener('click', closeMenu);

        connectBtn.addEventListener('click', () => {
            connectToBedJet();
            closeMenu();
        });
        
        // Empty state main connect button
        document.getElementById('mainConnectBtn').addEventListener('click', () => {
            connectToBedJet();
        });

        reconnectBtn.addEventListener('click', () => {
            reconnectToSavedDevice();
            closeMenu();
        });
        disconnectBtn.addEventListener('click', () => {
            disconnect();
            closeMenu();
        });
        useCelsiusCheckbox.addEventListener('change', updateTemperatureUI);
        enableDebugLoggingCheckbox.addEventListener('change', (e) => {
            debugLoggingEnabled = e.target.checked;
            saveDebugLoggingPreference(debugLoggingEnabled);
            if (debugLoggingEnabled) {
                logDebug('‚úì Debug logging enabled', 'success');
            } else {
                console.log('Debug logging disabled');
            }
        });

        enableStatusLoggingCheckbox.addEventListener('change', (e) => {
            statusLoggingEnabled = e.target.checked;
            saveStatusLoggingPreference(statusLoggingEnabled);
            if (debugLoggingEnabled) {
                logDebug(`Status notification logging ${statusLoggingEnabled ? 'enabled' : 'disabled'}`, 'info');
            } else {
                console.log(`Status notification logging ${statusLoggingEnabled ? 'enabled' : 'disabled'}`);
            }
        });

        enableVibrationCheckbox.addEventListener('change', (e) => {
            vibrationEnabled = e.target.checked;
            saveVibrationPreference(vibrationEnabled);
            if (debugLoggingEnabled) {
                logDebug(`Haptic feedback ${vibrationEnabled ? 'enabled' : 'disabled'}`, 'info');
            } else {
                console.log(`Haptic feedback ${vibrationEnabled ? 'enabled' : 'disabled'}`);
            }
        });

        modeButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                const mode = btn.dataset.mode;
                setMode(mode);
            });
        });

        tempSlider.addEventListener('input', (e) => {
            const sliderValue = parseInt(e.target.value);
            document.getElementById('targetTemp').textContent = sliderValue;
            updateSliderFill(e.target);

            // Mark as dirty - user is changing value
            if (!tempDirty) {
                tempDirty = true;
                tempPendingValue = sliderValue;
                document.getElementById('tempActions').classList.remove('hidden');
                document.getElementById('tempGauge').classList.add('dirty');
            } else {
                tempPendingValue = sliderValue;
            }

            // Update gauge visual
            const fahrenheit = inputToFahrenheit(sliderValue);
            updateTempGauge(fahrenheit);
        });

        document.getElementById('tempConfirm').addEventListener('click', () => {
            if (tempDirty && tempPendingValue !== null) {
                const fahrenheit = inputToFahrenheit(tempPendingValue);
                setTemperature(fahrenheit);
                tempDirty = false;
                tempPendingValue = null;
                document.getElementById('tempActions').classList.add('hidden');
                document.getElementById('tempGauge').classList.remove('dirty');
            }
        });

        document.getElementById('tempCancel').addEventListener('click', () => {
            if (tempDirty) {
                // Revert to last known value from status
                const currentValue = document.getElementById('targetTemp').textContent;
                if (currentValue !== '--') {
                    tempSlider.value = currentValue;
                    updateSliderFill(tempSlider);
                }
                tempDirty = false;
                tempPendingValue = null;
                document.getElementById('tempActions').classList.add('hidden');
                document.getElementById('tempGauge').classList.remove('dirty');
            }
        });

        fanSlider.addEventListener('input', (e) => {
            const sliderValue = parseInt(e.target.value);
            document.getElementById('fanSpeed').textContent = sliderValue;
            updateSliderFill(e.target);

            // Mark as dirty - user is changing value
            if (!fanDirty) {
                fanDirty = true;
                fanPendingValue = sliderValue;
                document.getElementById('fanActions').classList.remove('hidden');
                document.getElementById('fanGauge').classList.add('dirty');
            } else {
                fanPendingValue = sliderValue;
            }

            // Update gauge visual
            updateFanGauge(sliderValue);
        });

        document.getElementById('fanConfirm').addEventListener('click', () => {
            if (fanDirty && fanPendingValue !== null) {
                setFanSpeed(fanPendingValue);
                fanDirty = false;
                fanPendingValue = null;
                document.getElementById('fanActions').classList.add('hidden');
                document.getElementById('fanGauge').classList.remove('dirty');
            }
        });

        document.getElementById('fanCancel').addEventListener('click', () => {
            if (fanDirty) {
                // Revert to last known value from status
                const currentValue = document.getElementById('fanSpeed').textContent;
                if (currentValue !== '--') {
                    fanSlider.value = currentValue;
                    updateSliderFill(fanSlider);
                }
                fanDirty = false;
                fanPendingValue = null;
                document.getElementById('fanActions').classList.add('hidden');
                document.getElementById('fanGauge').classList.remove('dirty');
            }
        });

        // Initialize slider fills
        updateSliderFill(tempSlider);
        updateSliderFill(fanSlider);

        // Initialize temperature slider range based on default mode
        updateTempSliderRange();

        tempUpBtn.addEventListener('click', () => {
            incrementTemperature();
        });

        tempDownBtn.addEventListener('click', () => {
            decrementTemperature();
        });

        fanUpBtn.addEventListener('click', () => {
            incrementFan();
        });

        fanDownBtn.addEventListener('click', () => {
            decrementFan();
        });

        // Timer modal controls
        document.getElementById('timerEditBtn').addEventListener('click', () => {
            openTimerModal();
        });

        document.getElementById('timerModalClose').addEventListener('click', () => {
            closeTimerModal(false);
        });

        document.getElementById('timerModalCancel').addEventListener('click', () => {
            closeTimerModal(false);
        });

        document.getElementById('timerModalApply').addEventListener('click', () => {
            closeTimerModal(true);
        });

        // Close modal on backdrop click
        document.getElementById('timerModal').addEventListener('click', (e) => {
            if (e.target.id === 'timerModal') {
                closeTimerModal(false);
            }
        });

        // Timer preset buttons
        document.querySelectorAll('.timer-preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const minutes = parseInt(btn.dataset.minutes);
                setTimerPreset(minutes);
            });
        });

        // Timer adjustment buttons
        document.getElementById('timerPlus1').addEventListener('click', () => {
            adjustTimer(1);
        });

        document.getElementById('timerPlus10').addEventListener('click', () => {
            adjustTimer(10);
        });

        document.getElementById('timerPlus60').addEventListener('click', () => {
            adjustTimer(60);
        });

        document.getElementById('timerMinus1').addEventListener('click', () => {
            adjustTimer(-1);
        });

        document.getElementById('timerMinus10').addEventListener('click', () => {
            adjustTimer(-10);
        });

        document.getElementById('timerMinus60').addEventListener('click', () => {
            adjustTimer(-60);
        });

        presetButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                const preset = parseInt(btn.dataset.preset);
                activatePreset(preset);
            });
        });

        // Timer mode tab switching
        document.querySelectorAll('.timer-mode-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const mode = tab.dataset.mode;
                switchTimerMode(mode);
            });
        });

        // End time input change listener
        document.getElementById('endTimeInput').addEventListener('input', () => {
            updateEndTimeDuration();
        });

        function switchTimerMode(mode) {
            timerMode = mode;

            // Update tab visual state
            document.querySelectorAll('.timer-mode-tab').forEach(t => {
                t.classList.toggle('active', t.dataset.mode === mode);
            });

            // Show/hide sections
            const durationSections = document.querySelectorAll('.timer-duration-section');
            const endTimeSections = document.querySelectorAll('.timer-endtime-section');

            if (mode === 'duration') {
                durationSections.forEach(s => s.style.display = '');
                endTimeSections.forEach(s => s.style.display = 'none');
            } else {
                durationSections.forEach(s => s.style.display = 'none');
                endTimeSections.forEach(s => s.style.display = '');

                // Initialize end time input if switching to this mode
                initializeEndTimeInput();
            }

            logDebug(`Timer mode switched to: ${mode}`, 'info');
        }

        function initializeEndTimeInput() {
            const now = new Date();
            const currentMinutes = timerPendingMinutes !== null ? timerPendingMinutes : 60; // Default 1 hour

            // Calculate end time based on current pending duration
            const endTime = new Date(now.getTime() + currentMinutes * 60000);
            const hours = endTime.getHours().toString().padStart(2, '0');
            const minutes = endTime.getMinutes().toString().padStart(2, '0');

            document.getElementById('endTimeInput').value = `${hours}:${minutes}`;
            updateEndTimeDuration();
        }

        function updateEndTimeDuration() {
            const endTimeInput = document.getElementById('endTimeInput').value;
            if (!endTimeInput) {
                document.getElementById('endTimeDuration').textContent = '--';
                return;
            }

            const [hours, minutes] = endTimeInput.split(':').map(Number);
            const now = new Date();
            const endTime = new Date();
            endTime.setHours(hours, minutes, 0, 0);

            // If end time is before current time, assume it's tomorrow
            let isTomorrow = false;
            if (endTime <= now) {
                endTime.setDate(endTime.getDate() + 1);
                isTomorrow = true;
            }

            // Calculate duration in minutes
            const durationMs = endTime - now;
            let durationMinutes = Math.ceil(durationMs / 60000); // Round up to nearest minute

            // Get device limits and clamp if needed
            const limits = getTimerLimits();
            timerClamped = false;

            if (durationMinutes > limits.maxMinutes) {
                durationMinutes = limits.maxMinutes;
                timerClamped = true;
                document.getElementById('endTimeWarning').style.display = '';
                logDebug(`End time clamped to max duration: ${limits.maxMinutes} min`, 'warn');
            } else if (durationMinutes < limits.minMinutes) {
                durationMinutes = limits.minMinutes;
                timerClamped = true;
                document.getElementById('endTimeWarning').style.display = '';
                logDebug(`End time clamped to min duration: ${limits.minMinutes} min`, 'warn');
            } else {
                document.getElementById('endTimeWarning').style.display = 'none';
            }

            // Update pending minutes
            timerPendingMinutes = durationMinutes;

            // Format duration display
            const durationHours = Math.floor(durationMinutes / 60);
            const durationMins = durationMinutes % 60;

            let durationText = '';
            if (durationHours > 0) {
                durationText = `${durationHours}h ${durationMins}m`;
            } else {
                durationText = `${durationMins} min`;
            }

            if (isTomorrow) {
                durationText += ' (tomorrow)';
            }

            document.getElementById('endTimeDuration').textContent = durationText;

            // Update main modal display
            updateTimerModalDisplay(durationMinutes);
        }

        function syncEndTimeInputFromDuration(durationMinutes) {
            const now = new Date();
            const endTime = new Date(now.getTime() + durationMinutes * 60000);
            const hours = endTime.getHours().toString().padStart(2, '0');
            const minutes = endTime.getMinutes().toString().padStart(2, '0');

            document.getElementById('endTimeInput').value = `${hours}:${minutes}`;
            // Don't call updateEndTimeDuration() to avoid circular updates
        }

        async function connectToBedJet() {
            try {
                hideError();
                statusText.textContent = 'Scanning...';

                // Reset reconnect state
                userDisconnected = false;
                reconnectAttempts = 0;
                if (reconnectTimer) {
                    clearTimeout(reconnectTimer);
                    reconnectTimer = null;
                }

                const showAll = document.getElementById('showAllDevices').checked;
                logDebug('=== Starting BedJet Connection ===', 'info');
                logDebug(`Show all devices mode: ${showAll}`, 'info');

                // Request BedJet device with fallback options
                const requestOptions = {
                    optionalServices: [
                        BEDJET_SERVICE_UUID
                    ]
                };

                if (showAll) {
                    // Fallback: show all devices (useful if service UUIDs aren't advertised)
                    requestOptions.acceptAllDevices = true;
                    logDebug('Using acceptAllDevices mode (fallback)', 'warn');
                } else {
                    // Default: filter by service UUIDs and name prefix
                    requestOptions.filters = [
                        { services: [BEDJET_SERVICE_UUID] },
                        { namePrefix: 'BedJet' },
                        { namePrefix: 'BEDJET' }
                    ];
                    logDebug('Scanning with filters:', 'info');
                    logDebug(`  - Service UUID: ${BEDJET_SERVICE_UUID}`, 'info');
                    logDebug(`  - Name prefixes: BedJet, BEDJET`, 'info');
                }

                logDebug('Requesting Bluetooth device...', 'info');
                device = await navigator.bluetooth.requestDevice(requestOptions);

                logDebug(`‚úì Device selected: ${device.name || 'Unknown'}`, 'success');
                logDebug(`  Device ID: ${device.id}`, 'info');
                logDebug(`  Device GATT connected: ${device.gatt.connected}`, 'info');

                statusText.textContent = 'Connecting...';
                device.addEventListener('gattserverdisconnected', onDisconnected);

                logDebug('Connecting to GATT server...', 'info');
                server = await device.gatt.connect();
                logDebug('‚úì Connected to GATT server', 'success');

                // Get the BedJet service (all characteristics are under this one service)
                logDebug(`Getting BedJet service (${BEDJET_SERVICE_UUID})...`, 'info');
                const bedjetService = await server.getPrimaryService(BEDJET_SERVICE_UUID);
                logDebug('‚úì Got BedJet service', 'success');

                // Get command characteristic (for sending commands)
                logDebug(`Getting command characteristic (${BEDJET_COMMAND_UUID})...`, 'info');
                commandCharacteristic = await bedjetService.getCharacteristic(BEDJET_COMMAND_UUID);
                logDebug('‚úì Got command characteristic', 'success');
                logDebug(`  Properties: ${Array.from(commandCharacteristic.properties).join(', ')}`, 'info');

                // Get status characteristic (for receiving status updates)
                logDebug(`Getting status characteristic (${BEDJET_STATUS_UUID})...`, 'info');
                const statusCharacteristic = await bedjetService.getCharacteristic(BEDJET_STATUS_UUID);
                logDebug('‚úì Got status characteristic', 'success');
                logDebug(`  Properties: ${Array.from(statusCharacteristic.properties).join(', ')}`, 'info');

                // Subscribe to status notifications
                logDebug('Starting notifications...', 'info');
                await statusCharacteristic.startNotifications();
                statusCharacteristic.addEventListener('characteristicvaluechanged', handleStatusUpdate);
                logDebug('‚úì Notifications enabled', 'success');

                // Read device name
                try {
                    logDebug(`Getting name characteristic (${BEDJET_NAME_UUID})...`, 'info');
                    const nameCharacteristic = await bedjetService.getCharacteristic(BEDJET_NAME_UUID);
                    const nameValue = await nameCharacteristic.readValue();
                    const name = new TextDecoder().decode(nameValue);
                    deviceName.textContent = name || device.name;
                    logDebug(`‚úì Device name: ${name || device.name}`, 'success');
                } catch (err) {
                    deviceName.textContent = device.name;
                    logDebug(`‚ö† Could not read device name: ${err.message}`, 'warn');
                }

                // Save device to localStorage
                const finalDeviceName = deviceName.textContent || device.name;
                saveDeviceToStorage(device.id, finalDeviceName);

                // Update UI
                updateConnectionStatus(true);
                controls.style.display = 'block';
                document.getElementById('emptyState').style.display = 'none';
                connectBtn.style.display = 'none';
                reconnectBtn.style.display = 'none';
                disconnectBtn.style.display = '';

                logDebug('=== Connection Complete ===', 'success');
                triggerVibration('success');

            } catch (error) {
                console.error('Connection failed:', error);
                logDebug(`‚ùå Connection failed: ${error.name} - ${error.message}`, 'error');
                if (error.stack) {
                    logDebug(`Stack: ${error.stack}`, 'error');
                }
                showError(`Failed to connect: ${error.message}`);
                updateConnectionStatus(false);
            }
        }

        async function reconnectToSavedDevice() {
            try {
                hideError();
                statusText.textContent = 'Reconnecting...';
                statusIndicator.className = 'status-indicator reconnecting';

                // Reset reconnect state
                userDisconnected = false;
                reconnectAttempts = 0;
                if (reconnectTimer) {
                    clearTimeout(reconnectTimer);
                    reconnectTimer = null;
                }

                const savedDevice = getSavedDevice();
                if (!savedDevice) {
                    showError('No saved device found. Please connect manually.');
                    logDebug('‚ùå No saved device found', 'error');
                    return;
                }

                logDebug('=== Reconnecting to Saved Device ===', 'info');
                logDebug(`Saved device: ${savedDevice.name} (${savedDevice.id})`, 'info');

                // Check if we still have the device object in memory
                if (device && device.id === savedDevice.id && device.gatt) {
                    logDebug('Using existing device object from memory', 'info');
                } else {
                    // Device object lost (page reload) - need to request again with user gesture
                    // This will show the device picker, which should remember the previously paired device
                    logDebug('Device object not in memory, requesting device selection...', 'info');

                    const showAll = document.getElementById('showAllDevices').checked;
                    const requestOptions = {
                        optionalServices: [BEDJET_SERVICE_UUID]
                    };

                    if (showAll) {
                        requestOptions.acceptAllDevices = true;
                    } else {
                        requestOptions.filters = [
                            { services: [BEDJET_SERVICE_UUID] },
                            { namePrefix: 'BedJet' },
                            { namePrefix: 'BEDJET' }
                        ];
                    }

                    device = await navigator.bluetooth.requestDevice(requestOptions);
                    logDebug(`‚úì Device selected: ${device.name || 'Unknown'}`, 'success');
                }

                logDebug(`  Device ID: ${device.id}`, 'info');

                device.addEventListener('gattserverdisconnected', onDisconnected);

                logDebug('Connecting to GATT server...', 'info');
                server = await device.gatt.connect();
                logDebug('‚úì Connected to GATT server', 'success');

                // Get the BedJet service
                logDebug(`Getting BedJet service (${BEDJET_SERVICE_UUID})...`, 'info');
                const bedjetService = await server.getPrimaryService(BEDJET_SERVICE_UUID);
                logDebug('‚úì Got BedJet service', 'success');

                // Get command characteristic
                logDebug(`Getting command characteristic (${BEDJET_COMMAND_UUID})...`, 'info');
                commandCharacteristic = await bedjetService.getCharacteristic(BEDJET_COMMAND_UUID);
                logDebug('‚úì Got command characteristic', 'success');

                // Get status characteristic
                logDebug(`Getting status characteristic (${BEDJET_STATUS_UUID})...`, 'info');
                const statusCharacteristic = await bedjetService.getCharacteristic(BEDJET_STATUS_UUID);
                logDebug('‚úì Got status characteristic', 'success');

                // Subscribe to status notifications
                logDebug('Starting notifications...', 'info');
                await statusCharacteristic.startNotifications();
                statusCharacteristic.addEventListener('characteristicvaluechanged', handleStatusUpdate);
                logDebug('‚úì Notifications enabled', 'success');

                // Read device name
                try {
                    logDebug(`Getting name characteristic (${BEDJET_NAME_UUID})...`, 'info');
                    const nameCharacteristic = await bedjetService.getCharacteristic(BEDJET_NAME_UUID);
                    const nameValue = await nameCharacteristic.readValue();
                    const name = new TextDecoder().decode(nameValue);
                    deviceName.textContent = name || device.name;
                    logDebug(`‚úì Device name: ${name || device.name}`, 'success');
                } catch (err) {
                    deviceName.textContent = device.name;
                    logDebug(`‚ö† Could not read device name: ${err.message}`, 'warn');
                }

                // Update saved device info (in case it changed)
                const finalDeviceName = deviceName.textContent || device.name;
                saveDeviceToStorage(device.id, finalDeviceName);

                // Update UI
                updateConnectionStatus(true);
                controls.style.display = 'block';
                document.getElementById('emptyState').style.display = 'none';
                connectBtn.style.display = 'none';
                reconnectBtn.style.display = 'none';
                disconnectBtn.style.display = '';

                logDebug('=== Reconnection Complete ===', 'success');
                triggerVibration('success');

            } catch (error) {
                console.error('Reconnection failed:', error);
                logDebug(`‚ùå Reconnection failed: ${error.name} - ${error.message}`, 'error');
                if (error.stack) {
                    logDebug(`Stack: ${error.stack}`, 'error');
                }
                showError(`Failed to reconnect: ${error.message}`);
                updateConnectionStatus(false);
                updateButtonVisibility();
            }
        }

        async function disconnect() {
            logDebug('User requested disconnect', 'info');
            userDisconnected = true;

            // Clear any pending reconnect attempts
            if (reconnectTimer) {
                clearTimeout(reconnectTimer);
                reconnectTimer = null;
            }

            if (device && device.gatt.connected) {
                device.gatt.disconnect();
                logDebug('Disconnect command sent', 'info');
                triggerVibration('success');
            } else {
                logDebug('No active connection to disconnect', 'warn');
            }
        }

        async function attemptReconnect() {
            if (userDisconnected || isReconnecting) {
                return;
            }

            // Auto-reconnect only works if we still have the device object in memory
            // (Web Bluetooth doesn't allow reconnecting without user gesture after page reload)
            if (!device || !device.gatt) {
                logDebug('‚ùå Cannot auto-reconnect: device object not in memory (page was reloaded)', 'error');
                showError('Connection lost. Please click Reconnect button.');
                updateButtonVisibility();
                return;
            }

            isReconnecting = true;
            reconnectAttempts++;
            
            // Show pulsing orange status
            statusIndicator.className = 'status-indicator reconnecting';
            statusText.textContent = `Reconnecting (${reconnectAttempts}/${maxReconnectAttempts})...`;

            const delayMs = reconnectBaseDelay * reconnectAttempts; // Linear backoff
            logDebug(`Reconnect attempt ${reconnectAttempts}/${maxReconnectAttempts} in ${delayMs/1000}s...`, 'warn');

            reconnectTimer = setTimeout(async () => {
                try {
                    logDebug(`Attempting to reconnect to ${device.name}...`, 'info');

                    server = await device.gatt.connect();
                    logDebug('‚úì Reconnected to GATT server', 'success');

                    // Re-establish characteristics
                    const bedjetService = await server.getPrimaryService(BEDJET_SERVICE_UUID);
                    commandCharacteristic = await bedjetService.getCharacteristic(BEDJET_COMMAND_UUID);

                    const statusCharacteristic = await bedjetService.getCharacteristic(BEDJET_STATUS_UUID);
                    await statusCharacteristic.startNotifications();
                    statusCharacteristic.addEventListener('characteristicvaluechanged', handleStatusUpdate);

                    // Update UI
                    updateConnectionStatus(true);
                    controls.style.display = 'block';
                    document.getElementById('emptyState').style.display = 'none';
                    connectBtn.style.display = 'none';
                    reconnectBtn.style.display = 'none';
                    disconnectBtn.style.display = '';

                    // Reset reconnect state
                    reconnectAttempts = 0;
                    isReconnecting = false;

                    logDebug('=== Auto-reconnection Complete ===', 'success');
                    triggerVibration('success');
                } catch (error) {
                    logDebug(`Reconnect attempt ${reconnectAttempts} failed: ${error.message}`, 'error');
                    isReconnecting = false;

                    if (reconnectAttempts < maxReconnectAttempts) {
                        attemptReconnect();
                    } else {
                        logDebug(`Max reconnect attempts (${maxReconnectAttempts}) reached. Giving up.`, 'error');
                        showError('Connection lost. Please reconnect manually.');
                        updateButtonVisibility();
                    }
                }
            }, delayMs);
        }

        function onDisconnected() {
            logDebug('Device disconnected', 'warn');
            logDebug(`Device: ${device?.name || 'Unknown'}`, 'info');
            updateConnectionStatus(false);
            controls.style.display = 'none';
            document.getElementById('emptyState').style.display = 'flex';
            disconnectBtn.style.display = 'none';
            deviceName.textContent = '';
            currentMode = null;
            updateBackgroundColor();
            updateModeButtons();
            updateButtonVisibility();

            // Attempt auto-reconnect if not user-initiated
            if (!userDisconnected) {
                logDebug('Unexpected disconnect - initiating auto-reconnect', 'warn');
                attemptReconnect();
            } else {
                logDebug('User-initiated disconnect - auto-reconnect disabled', 'info');
            }
        }

        function handleStatusUpdate(event) {
            const data = new Uint8Array(event.target.value.buffer);

            if (data.length >= 18) {  // Need at least 18 bytes to read ambient temp at byte 17
                const hexData = Array.from(data).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ');
                console.log('Status data:', hexData);

                // Only log status updates if status logging is enabled
                if (statusLoggingEnabled) {
                    logDebug(`‚óÑ Status update (${data.length} bytes): ${hexData}`, 'info');
                }

                // Parse ambient temperature (byte 17)
                // BedJet uses half-degrees Celsius format: value 35 = 17.5¬∞C
                const newAmbientTemp = data[17];

                if (ambientTemp !== newAmbientTemp) {
                    ambientTemp = newAmbientTemp;
                    if (statusLoggingEnabled && ambientTemp !== 0) {
                        const ambientTempC = Math.round(ambientTemp / 2);
                        logDebug(`  Ambient temp: ${ambientTempC}¬∞C (raw byte[17]=${ambientTemp}, half-deg-C=${(ambientTemp/2).toFixed(1)}¬∞C)`, 'info');
                    }
                }

                // NOTE: Dynamic temperature bounds for DRY mode are not reliably identified in the status packet.
                // The code previously read bytes 12-13, but byte 13 is actually the mode indicator byte.
                // DRY mode will use the static temperature range defined in TEMP_RANGES instead.
                // If dynamic bounds are needed, they may be in a different message or use a different encoding.
                deviceMinTemp = null;
                deviceMaxTemp = null;

                // Parse current temperature (byte 7)
                // BedJet uses half-degrees Celsius format: value 80 = 40.0¬∞C
                if (data[7] !== 0) {
                    const rawCurrent = data[7];  // Half-degree Celsius value
                    const currentTempF = Math.round(((rawCurrent * 9) / 10) + 32);
                    const displayCurrent = displayTemp(currentTempF);
                    currentTempEl.textContent = displayCurrent;
                    if (statusLoggingEnabled) {
                        logDebug(`  Current temp: ${currentTempF}¬∞F (${fToC(currentTempF)}¬∞C) (raw=${data[7]}, half-deg-C=${(data[7]/2).toFixed(1)}¬∞C)`, 'info');
                    }
                }

                // Parse target temperature (byte 8)
                // BedJet uses half-degrees Celsius format: value 80 = 40.0¬∞C
                if (data[8] !== 0) {
                    const rawTarget = data[8];  // Half-degree Celsius value
                    const targetTempF = Math.round(((rawTarget * 9) / 10) + 32);
                    const displayTarget = displayTemp(targetTempF);

                    // Only update if not dirty (user hasn't changed slider)
                    if (!tempDirty) {
                        targetTempEl.textContent = displayTarget;
                        tempSlider.value = displayTarget;
                        updateSliderFill(tempSlider);
                        updateTempGauge(targetTempF);
                    }

                    if (statusLoggingEnabled) {
                        logDebug(`  Target temp: ${targetTempF}¬∞F (${fToC(targetTempF)}¬∞C) (raw=${data[8]}, half-deg-C=${(data[8]/2).toFixed(1)}¬∞C)`, 'info');
                    }
                }

                // Parse fan speed (byte 10)
                // BedJet formula: fanSpeed = fanByte * 5 + 5
                // fanByte 0 = 5%, fanByte 19 = 100%
                const fanSpeed = data[10] * 5 + 5;
                if (fanSpeed >= 5 && fanSpeed <= 100) {
                    // Only update if not dirty (user hasn't changed slider)
                    if (!fanDirty) {
                        fanSpeedEl.textContent = fanSpeed;
                        fanSlider.value = fanSpeed;
                        updateSliderFill(fanSlider);
                        updateFanGauge(fanSpeed);
                    }

                    if (statusLoggingEnabled) {
                        logDebug(`  Fan speed: ${fanSpeed}% (byte[10]=0x${data[10].toString(16)})`, 'info');
                    }
                }

                // NOTE: Maximum runtime limits are not reliably identified in the status packet.
                // The code previously read bytes 10-11, but byte 10 is actually the fan speed byte.
                // Timer limits are hardcoded in getTimerLimits() function based on mode instead.
                // If dynamic runtime limits are needed, they may be in a different message or use different bytes.

                // Parse time remaining (bytes 4, 5, 6)
                const hours = data[4];
                const minutes = data[5];
                const seconds = data[6];
                const totalSeconds = hours * 3600 + minutes * 60 + seconds;

                // Only update if modal is not open (user isn't editing timer)
                const modalOpen = document.getElementById('timerModal').classList.contains('active');
                if (!modalOpen) {
                    if (totalSeconds > 0) {
                        const h = Math.floor(totalSeconds / 3600);
                        const m = Math.floor((totalSeconds % 3600) / 60);
                        const s = totalSeconds % 60;
                        const timeStr = `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
                        timeRemainingEl.textContent = timeStr;
                        if (statusLoggingEnabled) {
                            logDebug(`  Time remaining: ${timeStr}`, 'info');
                        }
                    } else {
                        timeRemainingEl.textContent = '--';
                    }
                }

                // Parse mode (bytes 13, 14)
                const byte13 = data[13];
                const byte14 = data[14];

                let detectedMode = null;
                if (byte14 === 0x50 && byte13 === 0x14) {
                    detectedMode = 'off';
                } else if (byte14 === 0x34) {
                    detectedMode = 'cool';
                } else if (byte14 === 0x56) {
                    detectedMode = 'turbo';
                } else if (byte14 === 0x50 && byte13 === 0x2d) {
                    detectedMode = 'heat';
                } else if (byte14 === 0x3e) {
                    detectedMode = 'dry';
                } else if (byte14 === 0x43) {
                    detectedMode = 'ext_ht';
                }

                if (detectedMode) {
                    currentMode = detectedMode;
                    updateBackgroundColor();
                    if (statusLoggingEnabled) {
                        logDebug(`  Mode: ${detectedMode.toUpperCase()} (byte[13]=0x${byte13.toString(16)}, byte[14]=0x${byte14.toString(16)})`, 'info');
                    }
                } else {
                    if (statusLoggingEnabled) {
                        logDebug(`  Unknown mode (byte[13]=0x${byte13.toString(16)}, byte[14]=0x${byte14.toString(16)})`, 'warn');
                    }
                }

                // Update display for OFF state
                if (currentMode === 'off') {
                    // Show fan as OFF
                    fanSpeedEl.textContent = 'OFF';

                    // Show no target temp when off (only current temp is relevant)
                    targetTempEl.textContent = '--';
                }

                updateModeButtons();
            } else {
                if (statusLoggingEnabled) {
                    logDebug(`‚ö† Status update too short: ${data.length} bytes (expected ‚â•15)`, 'warn');
                }
            }
        }

        function updateModeButtons() {
            modeButtons.forEach(btn => {
                if (btn.dataset.mode === currentMode) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            // Update temperature slider range when mode changes
            updateTempSliderRange();
            updateBackgroundColor();

            // Update timer limits when mode changes
            updateTimerLimitIndicator();

            // Check if current timer exceeds new mode's limit
            // If modal is open and timer exceeds new mode's limit, clamp it
            const modalOpen = document.getElementById('timerModal').classList.contains('active');
            if (modalOpen && timerPendingMinutes !== null) {
                const limits = getTimerLimits();
                if (timerPendingMinutes > limits.maxMinutes) {
                    timerPendingMinutes = limits.maxMinutes;
                    updateTimerModalDisplay(timerPendingMinutes);
                    updateTimerButtonStates(timerPendingMinutes, limits);
                    document.getElementById('timerModalLimit').textContent = `Max: ${limits.maxMinutes} min (${Math.floor(limits.maxMinutes / 60)}h)`;
                    logDebug(`Timer clamped to ${limits.maxMinutes} min for ${currentMode.toUpperCase()} mode`, 'warn');
                }
            }
        }

        function updateBackgroundColor() {
            const color = MODE_COLORS[currentMode] || MODE_COLORS['off'];
            const header = document.querySelector('.header');
            if (header) {
                header.style.background = color;
            }
        }

        async function sendCommand(command) {
            if (!commandCharacteristic) {
                showError('Not connected to BedJet');
                logDebug('‚ùå Cannot send command: Not connected', 'error');
                triggerVibration('error');
                return;
            }

            try {
                const commandArray = new Uint8Array(command);
                const hexCommand = Array.from(commandArray).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ');
                console.log('Sending command:', hexCommand);
                logDebug(`‚ñ∫ Sending command: ${hexCommand}`, 'info');

                await commandCharacteristic.writeValue(commandArray);
                logDebug('‚úì Command sent successfully', 'success');
                triggerVibration('success');

                await new Promise(resolve => setTimeout(resolve, 300));
            } catch (error) {
                console.error('Command failed:', error);
                logDebug(`‚ùå Command failed: ${error.message}`, 'error');
                showError(`Command failed: ${error.message}`);
                triggerVibration('error');
            }
        }

        async function setMode(mode) {
            logDebug(`Setting mode to: ${mode.toUpperCase()}`, 'info');
            const modeByte = REVERSE_MODE_MAP[mode];
            if (modeByte === undefined) {
                showError(`Invalid mode: ${mode}`);
                logDebug(`‚ùå Invalid mode: ${mode}`, 'error');
                return;
            }
            logDebug(`  Mode byte: 0x${modeByte.toString(16)}`, 'info');
            await sendCommand([0x01, modeByte]);
        }

        async function setTemperature(temp) {
            logDebug(`Setting temperature to: ${temp}¬∞F`, 'info');
            if (temp < 66 || temp > 104) {
                showError(`Temperature ${temp} out of range (66-104¬∞F)`);
                logDebug(`‚ùå Temperature ${temp}¬∞F out of range (66-104¬∞F)`, 'error');
                return;
            }

            // Convert temperature to BedJet half-degrees Celsius format (official encoding)
            // Formula: ceil(((¬∞F - 32) √ó 10) / 9) ‚Üí value 80 = 40.0¬∞C
            // Reference: https://github.com/markus1189/bedjet-re/blob/main/docs/temperature-ranges.md
            const tempByte = Math.ceil(((temp - 32) * 10) / 9);
            const clampedByte = Math.max(0, Math.min(255, tempByte));

            console.log(`Setting temperature ${temp}¬∞F (byte: 0x${clampedByte.toString(16)})`);
            logDebug(`  Temp byte: ${clampedByte} (0x${clampedByte.toString(16)}, half-deg-C: ${(clampedByte/2).toFixed(1)}¬∞C)`, 'info');
            await sendCommand([0x03, clampedByte]);
        }

        async function setFanSpeed(speed) {
            logDebug(`Setting fan speed to: ${speed}%`, 'info');
            if (speed < 5 || speed > 100) {
                showError(`Fan speed ${speed} out of range (5-100%)`);
                logDebug(`‚ùå Fan speed ${speed}% out of range (5-100%)`, 'error');
                return;
            }

            // Convert percentage to BedJet format
            // BedJet formula: actual_speed = fanByte * 5 + 5
            // Therefore: fanByte = (speed - 5) / 5
            const fanByte = Math.round((speed - 5) / 5);
            logDebug(`  Fan byte: 0x${fanByte.toString(16)}`, 'info');
            await sendCommand([0x07, fanByte]);
        }

        async function setRuntime(minutes) {
            logDebug(`Setting runtime to: ${minutes} minutes`, 'info');
            if (minutes < 1 || minutes > 600) {
                showError(`Runtime ${minutes} out of range (1-600 minutes)`);
                logDebug(`‚ùå Runtime ${minutes} min out of range (1-600 min)`, 'error');
                return;
            }

            // Convert minutes to hours and minutes
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;

            logDebug(`  Runtime: ${hours}h ${mins}m`, 'info');
            await sendCommand([0x02, hours, mins]);
        }

        async function incrementTemperature() {
            logDebug('Increment temperature button pressed', 'info');
            await sendCommand([0x01, 0x12]); // TEMP_UP command
        }

        async function decrementTemperature() {
            logDebug('Decrement temperature button pressed', 'info');
            await sendCommand([0x01, 0x13]); // TEMP_DOWN command
        }

        async function incrementFan() {
            logDebug('Increment fan speed button pressed', 'info');
            await sendCommand([0x01, 0x10]); // FAN_UP command
        }

        async function decrementFan() {
            logDebug('Decrement fan speed button pressed', 'info');
            await sendCommand([0x01, 0x11]); // FAN_DOWN command
        }

        async function activatePreset(preset) {
            logDebug(`Activating memory preset: M${preset}`, 'info');
            if (preset < 1 || preset > 3) {
                showError(`Invalid preset: ${preset}`);
                logDebug(`‚ùå Invalid preset: ${preset}`, 'error');
                return;
            }

            const presetByte = 0x20 + (preset - 1);
            logDebug(`  Preset byte: 0x${presetByte.toString(16)}`, 'info');
            await sendCommand([0x01, presetByte]);
        }

        function updateConnectionStatus(connected) {
            // Reset to base class to remove 'reconnecting' animation
            statusIndicator.className = 'status-indicator';
            
            if (connected) {
                statusIndicator.classList.add('connected');
                statusText.textContent = 'Connected';
            } else {
                statusText.textContent = 'Not Connected';
            }
        }

        function showError(message) {
            errorDiv.textContent = message;
            errorDiv.classList.add('show');
            setTimeout(() => hideError(), 5000);
        }

        function hideError() {
            errorDiv.classList.remove('show');
        }

        function updateButtonVisibility() {
            const savedDevice = getSavedDevice();

            if (device && device.gatt && device.gatt.connected) {
                // Currently connected
                connectBtn.style.display = 'none';
                reconnectBtn.style.display = 'none';
                disconnectBtn.style.display = '';
            } else if (savedDevice) {
                // Not connected, but have saved device
                connectBtn.style.display = '';
                reconnectBtn.style.display = '';
                disconnectBtn.style.display = 'none';
                savedDeviceNameEl.textContent = savedDevice.name;
            } else {
                // Not connected, no saved device
                connectBtn.style.display = '';
                reconnectBtn.style.display = 'none';
                disconnectBtn.style.display = 'none';
            }
        }

        // Initialize button visibility on page load
        function initializeApp() {
            // Initialize debug logging checkboxes
            enableDebugLoggingCheckbox.checked = debugLoggingEnabled;
            enableStatusLoggingCheckbox.checked = statusLoggingEnabled;
            enableVibrationCheckbox.checked = vibrationEnabled;

            const savedDevice = getSavedDevice();
            if (savedDevice) {
                logDebug(`Found saved device: ${savedDevice.name} (${savedDevice.id})`, 'info');
            } else {
                logDebug('No saved device found', 'info');
            }
            updateButtonVisibility();

            // Initialize timer limit indicator
            updateTimerLimitIndicator();
        }

        // PWA Install Prompt Handling
        let deferredPrompt;
        const installBtn = document.getElementById('installBtn');

        window.addEventListener('beforeinstallprompt', (e) => {
            // Prevent the mini-infobar from appearing on mobile
            e.preventDefault();
            // Stash the event so it can be triggered later
            deferredPrompt = e;
            // Show the install button
            installBtn.style.display = 'block';
            logDebug('‚úì PWA install prompt available', 'success');
        });

        installBtn.addEventListener('click', async () => {
            if (!deferredPrompt) {
                return;
            }
            // Show the install prompt
            deferredPrompt.prompt();
            // Wait for the user to respond to the prompt
            const { outcome } = await deferredPrompt.userChoice;
            logDebug(`PWA install prompt outcome: ${outcome}`, outcome === 'accepted' ? 'success' : 'info');
            // Clear the deferredPrompt so it can't be used again
            deferredPrompt = null;
            // Hide the install button
            installBtn.style.display = 'none';
        });

        window.addEventListener('appinstalled', () => {
            // Hide the install button after successful installation
            installBtn.style.display = 'none';
            deferredPrompt = null;
            logDebug('‚úì PWA installed successfully', 'success');
        });

        // PWA Service Worker Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('bedjet-bluetooth-control-sw.js')
                    .then(registration => {
                        logDebug('‚úì Service Worker registered successfully', 'success');
                        console.log('ServiceWorker registration successful:', registration.scope);
                    })
                    .catch(error => {
                        logDebug(`‚ö† Service Worker registration failed: ${error}`, 'warn');
                        console.log('ServiceWorker registration failed:', error);
                    });

                // Initialize app after page load
                initializeApp();
            });
        } else {
            // Initialize app even if service worker not available
            initializeApp();
        }
    </script>
</body>
</html>
