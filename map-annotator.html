<!DOCTYPE html>
<!--
BSD 2-Clause License
Copyright 2025 Gabriel Nyman
https://github.com/gnyman/mapdraw

Adapted for self-contained use with inline SVG icons.
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Map Drawing & Sharing</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            height: 100vh;
            overflow: hidden;
        }

        #map {
            width: 100%;
            height: 100vh;
            position: relative;
        }

        .drawing-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        .drawing-overlay.drawing-mode {
            pointer-events: all;
        }

        .drawing-overlay.freehand-mode {
            cursor: crosshair;
        }

        .drawing-overlay.line-mode {
            cursor: crosshair;
        }

        .drawing-overlay.circle-mode {
            cursor: crosshair;
        }

        .drawing-overlay.arrow-mode {
            cursor: crosshair;
        }

        .drawing-overlay.rectangle-mode {
            cursor: crosshair;
        }

        .drawing-overlay.pan-mode {
            cursor: grab;
        }

        .drawing-overlay.pan-mode.panning {
            cursor: grabbing;
        }

        .controls {
            position: absolute;
            top: 12px;
            right: 12px;
            left: auto;
            transform: none;
            z-index: 1001;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            box-shadow: 0 4px 30px rgba(0,0,0,0.12);
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
            max-width: calc(100% - 32px);
        }


        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toolbar-group + .toolbar-group {
            border-left: 1px solid #e5e5ea;
            padding-left: 12px;
        }

        .toolbar-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 6px 10px;
            border: 1px solid #d1d1d6;
            border-radius: 10px;
            background: linear-gradient(180deg, #fcfcfe 0%, #e9e9f1 100%);
            color: #1c1c1e;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: background 0.2s, border-color 0.2s, color 0.2s, box-shadow 0.2s;
            white-space: nowrap;
            box-shadow: 0 1px 2px rgba(0,0,0,0.08);
            min-height: 32px;
            text-decoration: none;
        }

        .toolbar-btn:hover {
            background: linear-gradient(180deg, #ffffff 0%, #f1f1f6 100%);
            border-color: #bfbfc7;
            box-shadow: 0 2px 4px rgba(0,0,0,0.12);
        }

        .toolbar-btn:disabled {
            background: linear-gradient(180deg, #f5f5f7 0%, #ececf1 100%);
            border-color: #e0e0e6;
            color: #b0b0b9;
            cursor: not-allowed;
            box-shadow: none;
            opacity: 0.8;
        }

        .toolbar-btn.active {
            background: linear-gradient(180deg, rgba(0, 122, 255, 0.2) 0%, rgba(0, 122, 255, 0.05) 100%);
            border-color: #007AFF;
            color: #0056B3;
            box-shadow: 0 3px 10px rgba(0, 122, 255, 0.25);
        }

        .toolbar-btn .icon {
            width: 18px;
            height: 18px;
            display: block;
        }

        .toolbar-btn .icon img,
        .toolbar-btn .icon svg {
            width: 100%;
            height: 100%;
        }

        .btn-label {
            font-size: 11px;
            letter-spacing: 0.01em;
        }

        .location-btn {
            color: #1c1c1e;
        }

        .location-btn.active {
            background: linear-gradient(180deg, #34C759 0%, #2bb755 100%);
            border-color: #2BB755;
            color: #fff;
            box-shadow: 0 3px 10px rgba(52, 199, 89, 0.35);
        }

        .tool-btn {
            min-width: 32px;
        }

        .stroke-picker {
            position: relative;
        }

        .stroke-visual {
            width: 36px;
            height: 20px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .stroke-visual::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: calc(100% - 8px);
            height: var(--stroke-width, 4px);
            border-radius: 999px;
            background-color: var(--stroke-color, #007AFF);
            transform: translate(-50%, -50%);
        }

        .stroke-popover {
            position: absolute;
            top: 0;
            left: 0;
            background: white;
            border: 1px solid #d0d0d7;
            border-radius: 10px;
            padding: 10px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.18);
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 1002;
            min-width: 140px;
        }

        .stroke-option {
            display: flex;
            align-items: center;
            gap: 10px;
            border: 1px solid transparent;
            border-radius: 8px;
            padding: 6px 8px;
            background: transparent;
            font-size: 12px;
            font-weight: 600;
            color: #1c1c1e;
            cursor: pointer;
            transition: background 0.2s, border-color 0.2s;
        }

        .stroke-option:hover,
        .stroke-option:focus-visible {
            background: #f2f2f7;
            border-color: #d0d0d7;
            outline: none;
        }

        .stroke-option.active {
            border-color: #007AFF;
            background: rgba(0, 122, 255, 0.12);
        }

        .stroke-option-line {
            width: 40px;
            height: 20px;
            position: relative;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .stroke-option-line::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: calc(100% - 8px);
            height: var(--stroke-width, 4px);
            border-radius: 999px;
            background-color: var(--stroke-color, #007AFF);
            transform: translate(-50%, -50%);
        }

        .color-picker {
            position: relative;
        }

        .color-preview {
            width: auto;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            border: 1px solid #c7c7ce;
            border-radius: 10px;
            background-color: #f5f5fa;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            color: #1c1c1e;
            box-shadow: 0 1px 2px rgba(0,0,0,0.08);
        }

        .color-preview.active {
            border-color: #007AFF;
            box-shadow: 0 3px 10px rgba(0, 122, 255, 0.25);
        }

        .color-preview:focus-visible {
            outline: 2px solid #007AFF;
            outline-offset: 2px;
        }

        .color-swatch {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 1px solid rgba(0,0,0,0.2);
            flex-shrink: 0;
        }

        .color-name {
            font-size: 11px;
        }

        .color-popover {
            position: absolute;
            top: 0;
            left: 0;
            background-color: #f5f5fa;
            border: 1px solid #d0d0d7;
            border-radius: 10px;
            padding: 12px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.15);
            display: grid;
            grid-template-columns: repeat(4, 24px);
            gap: 10px;
            z-index: 1002;
        }

        .color-option {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
        }

        .color-option.active {
            border-color: #000;
        }

        .color-option:focus-visible {
            outline: 2px solid #007AFF;
            outline-offset: 2px;
        }

        .picker-overlay {
            position: fixed;
            inset: 0;
            background: transparent;
            z-index: 1001;
        }


        .url-container {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            z-index: 1001;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 12px;
            display: none;
        }

        .url-container.show {
            display: block;
        }

        .url-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }

        .url-input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 11px;
            margin-bottom: 8px;
            font-family: monospace;
        }

        .status {
            position: absolute;
            z-index: 1001;
            background: rgba(0,0,0,0.85);
            color: white;
            padding: 8px 12px;
            border-radius: 10px;
            font-size: 12px;
            display: none;
            max-width: 260px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.25);
            pointer-events: none;
        }

        .status.show {
            display: block;
        }

        .status.error {
            background: rgba(255, 59, 48, 0.9);
        }

        .status.success {
            background: rgba(52, 199, 89, 0.9);
        }

        .preview-line {
            stroke-width: 2;
            fill: none;
            stroke-dasharray: 5,5;
            pointer-events: none;
        }

        .preview-circle {
            stroke-width: 2;
            fill: none;
            stroke-dasharray: 5,5;
            pointer-events: none;
        }

        .preview-arrow {
            stroke-width: 2;
            fill: none;
            stroke-dasharray: 5,5;
            pointer-events: none;
        }

        .preview-rectangle {
            stroke-width: 2;
            fill: none;
            stroke-dasharray: 5,5;
            pointer-events: none;
        }

        label {
            font-size: 11px;
            color: #666;
        }

        .search-container {
            position: relative;
            display: flex;
            align-items: center;
        }

        .search-input {
            width: 200px;
            padding: 6px 10px;
            border: 1px solid #d1d1d6;
            border-radius: 10px;
            font-size: 12px;
            background: white;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .search-input:focus {
            outline: none;
            border-color: #007AFF;
            box-shadow: 0 2px 8px rgba(0, 122, 255, 0.2);
        }

        .search-results {
            position: absolute;
            top: calc(100% + 4px);
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #d1d1d6;
            border-radius: 10px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.18);
            max-height: 300px;
            overflow-y: auto;
            z-index: 1003;
            display: none;
        }

        .search-results.show {
            display: block;
        }

        .search-result-item {
            padding: 10px 12px;
            cursor: pointer;
            font-size: 12px;
            border-bottom: 1px solid #f0f0f5;
            transition: background 0.2s;
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .search-result-item:hover {
            background: #f2f2f7;
        }

        .search-result-item:active {
            background: #e5e5ea;
        }

        .search-loading {
            padding: 10px 12px;
            font-size: 12px;
            color: #8e8e93;
            text-align: center;
        }

        @media (max-width: 768px) {
            .search-input {
                width: 150px;
                font-size: 11px;
                padding: 5px 8px;
            }

            .controls {
                position: fixed;
                top: auto;
                bottom: 8px;
                left: 8px;
                right: 8px;
                transform: none;
                padding: 6px 8px;
                justify-content: center;
                gap: 8px;
                border-radius: 12px;
            }

            .toolbar-group {
                flex: 1 1 auto;
                justify-content: center;
                gap: 6px;
                border-left: none !important;
                padding-left: 0;
            }

            .btn-label {
                display: none;
            }

            .toolbar-btn {
                padding: 8px;
                min-width: 36px;
            }

            .color-preview {
                padding: 8px;
            }

            .color-name {
                display: none;
            }

            .stroke-popover {
                min-width: 120px;
            }

            .url-container {
                bottom: 72px;
                left: 8px;
                right: 8px;
            }
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <svg class="drawing-overlay" id="drawingOverlay">
        <defs id="arrowMarkers"></defs>
        <g id="drawingGroup"></g>
        <g id="previewGroup"></g>
    </svg>
    
    <div class="controls" role="toolbar" aria-label="Drawing controls">
        <div class="toolbar-group">
            <a href="index.html" class="toolbar-btn" title="Back to tools" aria-label="Back to tools">
                <span class="icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="19" y1="12" x2="5" y2="12"/><polyline points="12 19 5 12 12 5"/></svg>
                </span>
            </a>
            <button id="locationBtn" class="toolbar-btn location-btn" aria-pressed="false" aria-label="Toggle location tracking">
                <span class="icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"/><circle cx="12" cy="12" r="10"/><line x1="12" y1="2" x2="12" y2="6"/><line x1="12" y1="18" x2="12" y2="22"/><line x1="2" y1="12" x2="6" y2="12"/><line x1="18" y1="12" x2="22" y2="12"/></svg>
                </span>
            </button>
            <button id="shareBtn" class="toolbar-btn" aria-pressed="false" aria-label="Share drawing">
                <span class="icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                </span>
            </button>
            <button id="searchToggleBtn" class="toolbar-btn" aria-pressed="false" aria-label="Search location">
                <span class="icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/></svg>
                </span>
            </button>
            <div class="search-container" id="searchContainer" style="display: none;">
                <input type="text" id="searchInput" class="search-input" placeholder="Search location..." aria-label="Search for a location">
                <div id="searchResults" class="search-results" role="listbox"></div>
            </div>
        </div>
        <div class="toolbar-group">
            <button id="undoBtn" class="toolbar-btn" title="Undo" aria-label="Undo">
                <span class="icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/></svg>
                </span>
                <span class="btn-label">Undo</span>
            </button>
            <button id="redoBtn" class="toolbar-btn" title="Redo" aria-label="Redo">
                <span class="icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"/><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"/></svg>
                </span>
                <span class="btn-label">Redo</span>
            </button>
            <button id="clearBtn" class="toolbar-btn" title="Clear drawing" aria-label="Clear drawing">
                <span class="icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>
                </span>
                <span class="btn-label">Clear</span>
            </button>
            <button id="exportBtn" class="toolbar-btn" title="Export as GeoJSON" aria-label="Export as GeoJSON">
                <span class="icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                </span>
                <span class="btn-label">Export</span>
            </button>
            <button id="importBtn" class="toolbar-btn" title="Import GeoJSON" aria-label="Import GeoJSON">
                <span class="icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
                </span>
                <span class="btn-label">Import</span>
            </button>
        </div>
        <div class="toolbar-group">
            <button id="panBtn" class="toolbar-btn tool-btn" title="Pan" aria-label="Pan tool">
                <span class="icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="5 9 2 12 5 15"/><polyline points="9 5 12 2 15 5"/><polyline points="15 19 12 22 9 19"/><polyline points="19 9 22 12 19 15"/><line x1="2" y1="12" x2="22" y2="12"/><line x1="12" y1="2" x2="12" y2="22"/></svg>
                </span>
                <span class="btn-label">Pan</span>
            </button>
            <button id="freehandBtn" class="toolbar-btn tool-btn active" title="Freehand" aria-label="Freehand tool">
                <span class="icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="M2 2l7.586 7.586"/></svg>
                </span>
                <span class="btn-label">Freehand</span>
            </button>
            <button id="lineBtn" class="toolbar-btn tool-btn" title="Line" aria-label="Line tool">
                <span class="icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="19" x2="19" y2="5"/></svg>
                </span>
                <span class="btn-label">Line</span>
            </button>
            <button id="circleBtn" class="toolbar-btn tool-btn" title="Circle" aria-label="Circle tool">
                <span class="icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/></svg>
                </span>
                <span class="btn-label">Circle</span>
            </button>
            <button id="arrowBtn" class="toolbar-btn tool-btn" title="Arrow" aria-label="Arrow tool">
                <span class="icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12 5 19 12 12 19"/></svg>
                </span>
                <span class="btn-label">Arrow</span>
            </button>
            <button id="rectangleBtn" class="toolbar-btn tool-btn" title="Rectangle" aria-label="Rectangle tool">
                <span class="icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/></svg>
                </span>
                <span class="btn-label">Rectangle</span>
            </button>
        </div>
        <div class="toolbar-group">
            <div class="stroke-picker">
                <button type="button" class="toolbar-btn" id="strokePickerBtn" aria-haspopup="true" aria-expanded="false" aria-label="Stroke width">
                    <span class="icon stroke-visual" id="strokePickerLine" aria-hidden="true"></span>
                    <span class="btn-label" id="strokePickerLabel">Standard</span>
                </button>
            </div>
            <div class="color-picker">
                <button type="button" class="color-preview" id="colorPreviewBtn" aria-haspopup="true" aria-expanded="false">
                    <span class="color-swatch" id="colorPreviewSwatch"></span>
                    <span class="color-name" id="colorPreviewLabel">Red</span>
                </button>
            </div>
        </div>
    </div>
    
    <div class="url-container" id="urlContainer">
        <input type="text" class="url-input" id="shareUrl" readonly>
        <div class="url-actions">
            <button type="button" class="toolbar-btn" onclick="copyUrl()">Copy</button>
            <button type="button" class="toolbar-btn" onclick="hideShare()">Close</button>
        </div>
    </div>
    
    <div class="status" id="status"></div>

    <input type="file" id="geojsonFileInput" accept=".json,.geojson" style="display: none;">

    <!-- Leaflet JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/uzip@0.20201231.0/UZIP.min.js"></script>
    
    <script>
        class MapDrawingApp {
            constructor() {
                this.map = null;
                this.drawingMode = false;
                this.currentTool = 'freehand';
                this.currentPath = null;
                this.widthOptions = [2, 4, 6, 10];
                this.widthOptionLabels = ['Fine', 'Standard', 'Bold', 'Heavy'];
                this.currentWidthIndex = 1;
                this.currentStroke = this.widthOptions[this.currentWidthIndex];
                this.paths = [];
                this.undoStack = [];
                this.redoStack = [];
                this.isDrawing = false;
                this.startPoint = null;
                this.previewElement = null;
                this.lastLocation = { lat: 37.7749, lng: -122.4194, zoom: 13 };
                this.autoSaveTimer = null;
                this.pendingUndoSnapshot = null;
                this.didMutatePaths = false;
                this.cachedCompressedDrawing = '';
                this.drawingSerializationDirty = true;
                this.compressInFlight = null;
                this.compressionGeneration = 0;
                this.colorPalette = [
                    '#FF3B30', '#FF9500', '#FFCC00', '#4CD964',
                    '#007AFF', '#5856D6', '#FF2D55', '#8E8E93'
                ];
                this.colorNames = [
                    'Red', 'Orange', 'Yellow', 'Lime',
                    'Blue', 'Indigo', 'Pink', 'Gray'
                ];
                this.currentColorIndex = 0;
                this.activeDrawingColorIndex = 0;
                this.pendingShapeColorIndex = null;
                this.colorPreviewBtn = null;
                this.colorPreviewSwatch = null;
                this.colorPreviewLabel = null;
                this.colorPopover = null;
                this.colorOverlay = null;
                this.boundColorPopoverKeyHandler = null;
                this.boundColorPopoverResize = null;
                this.boundColorPopoverScroll = null;
                this.strokePickerBtn = null;
                this.strokePickerLine = null;
                this.strokePickerLabel = null;
                this.strokePopover = null;
                this.strokeOverlay = null;
                this.boundStrokePopoverKeyHandler = null;
                this.boundStrokePopoverResize = null;
                this.boundStrokePopoverScroll = null;
                this.locationMarker = null;
                this.locationAccuracyCircle = null;
                this.locationWatchId = null;
                this.isTrackingLocation = false;
                this.hasCenteredOnLocation = false;
                this.lastLocationUpdate = 0;
                this.shareOpen = false;
                this.statusAnchor = null;
                this.statusHideTimer = null;
                this.locationButton = null;
                this.shareButton = null;
                this.clearButton = null;
                this.undoButton = null;
                this.redoButton = null;
                this.searchInput = null;
                this.searchResults = null;
                this.searchDebounceTimer = null;
                this.lastSearchTime = 0;
                this.searchMarker = null;
                this.searchMarkerTimer = null;
                this.spacebarPressed = false;
                this.toolBeforeSpacebar = null;
                this.initMarkers();

                this.init();
            }

            init() {
                this.loadLastState();
                this.initMap();
                this.initControls();
                this.initDrawing();
                this.initKeyboardShortcuts();
                this.loadFromUrl();
                this.startAutoSave();
            }

            loadLastState() {
                // Try to load from memory (session-based storage)
                // Note: localStorage is not available in Claude.ai artifacts
                try {
                    const saved = window.sessionData || {};
                    if (saved.lastLocation) {
                        this.lastLocation = saved.lastLocation;
                    }
                    if (saved.lastDrawing) {
                        // Will be loaded after map initializes
                        this.savedDrawing = saved.lastDrawing;
                    }
                } catch (e) {
                    console.log('Session storage not available, using defaults');
                }
            }

            saveState() {
                try {
                    window.sessionData = window.sessionData || {};
                    window.sessionData.lastLocation = {
                        lat: this.map.getCenter().lat,
                        lng: this.map.getCenter().lng,
                        zoom: this.map.getZoom()
                    };
                    this.compressDrawing().then(drawing => {
                        window.sessionData.lastDrawing = drawing;
                    }).catch(() => {
                        // Ignore compression errors during auto-save
                    });
                } catch (e) {
                    console.log('Could not save state');
                }
            }

            initMap() {
                // Initialize map with last known location
                this.map = L.map('map').setView([this.lastLocation.lat, this.lastLocation.lng], this.lastLocation.zoom);
                
                // Add OpenStreetMap tiles
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: 'Â© OpenStreetMap contributors'
                }).addTo(this.map);

                // Handle map events
                this.map.on('moveend', () => {
                    this.updateUrl();
                    this.saveState();
                });
                this.map.on('zoomend', () => {
                    this.updateUrl();
                    this.saveState();
                });
                this.map.on('move', () => {
                    this.redrawPaths();
                });
                this.map.on('zoom', () => {
                    this.redrawPaths();
                });

                // Load saved drawing if available
                if (this.savedDrawing) {
                    setTimeout(() => {
                        this.decompressDrawing(this.savedDrawing);
                        delete this.savedDrawing;
                    }, 100);
                }
            }

            initControls() {
                const attachButton = (id, handler) => {
                    const el = document.getElementById(id);
                    if (!el) return null;
                    el.addEventListener('click', (event) => {
                        this.statusAnchor = event.currentTarget;
                        handler(event);
                    });
                    return el;
                };

                // Action buttons
                this.locationButton = attachButton('locationBtn', () => this.goToLocation());
                this.shareButton = attachButton('shareBtn', () => this.showShare());
                this.clearButton = attachButton('clearBtn', () => this.clearDrawing());
                this.undoButton = attachButton('undoBtn', () => this.undo());
                this.redoButton = attachButton('redoBtn', () => this.redo());
                this.exportButton = attachButton('exportBtn', () => this.exportGeoJSON());
                this.importButton = attachButton('importBtn', () => this.importGeoJSON());

                // Tool buttons
                attachButton('panBtn', () => this.setTool('pan'));
                attachButton('freehandBtn', () => this.setTool('freehand'));
                attachButton('lineBtn', () => this.setTool('line'));
                attachButton('circleBtn', () => this.setTool('circle'));
                attachButton('arrowBtn', () => this.setTool('arrow'));
                attachButton('rectangleBtn', () => this.setTool('rectangle'));

                // Stroke width options
                this.initWidthControls();

                // Color palette
                this.initColorControls();

                // Search controls
                this.initSearchControls();

                if (!this.statusAnchor) {
                    this.statusAnchor = this.shareButton || this.locationButton || this.clearButton;
                }

                this.updateToolButtons();
                this.updateUndoRedoButtons();
                this.updateColorButtons();
                this.updateWidthButtons();
                this.updateLocationButtonState();
            }

            setTool(tool) {
                if (this.currentTool === tool && this.drawingMode) {
                    this.toggleDrawingMode(false);
                    return;
                }

                this.currentTool = tool;
                this.updateToolButtons();

                if (!this.drawingMode) {
                    this.toggleDrawingMode(true);
                }
            }

            updateToolButtons() {
                const buttons = document.querySelectorAll('.tool-btn');
                buttons.forEach(btn => btn.classList.remove('active'));
                
                const activeBtn = document.getElementById(this.currentTool + 'Btn');
                if (activeBtn && this.drawingMode) activeBtn.classList.add('active');

                // Update overlay cursor class
                const overlay = document.getElementById('drawingOverlay');
                overlay.setAttribute('class', 'drawing-overlay');
                if (this.drawingMode) {
                    overlay.classList.add('drawing-mode', this.currentTool + '-mode');
                }
            }

            toggleDrawingMode(enable = null) {
                this.drawingMode = enable !== null ? enable : !this.drawingMode;

                const overlay = document.getElementById('drawingOverlay');
                const isPanMode = this.currentTool === 'pan';

                if (this.drawingMode) {
                    overlay.classList.add('drawing-mode');
                    if (isPanMode) {
                        // Pan mode: enable map interaction
                        this.map.dragging.enable();
                        this.map.scrollWheelZoom.enable();
                        this.map.doubleClickZoom.enable();
                    } else {
                        // Drawing modes: disable map interaction
                        this.map.dragging.disable();
                        this.map.scrollWheelZoom.disable();
                        this.map.doubleClickZoom.disable();
                    }
                } else {
                    overlay.classList.remove('drawing-mode');
                    this.map.dragging.enable();
                    this.map.scrollWheelZoom.enable();
                    this.map.doubleClickZoom.enable();
                }

                this.updateToolButtons();
            }

            initDrawing() {
                const overlay = document.getElementById('drawingOverlay');

                // Mouse events
                overlay.addEventListener('mousedown', (e) => this.handleDrawStart(e));
                overlay.addEventListener('mousemove', (e) => this.handleDrawMove(e));
                overlay.addEventListener('mouseup', (e) => this.handleDrawEnd(e));

                // Touch events
                overlay.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.handleDrawStart(e);
                });
                overlay.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.handleDrawMove(e);
                });
                overlay.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.handleDrawEnd(e);
                });

                // Prevent context menu
                overlay.addEventListener('contextmenu', (e) => e.preventDefault());
            }

            initKeyboardShortcuts() {
                // Spacebar for temporary pan mode
                document.addEventListener('keydown', (e) => {
                    // Ignore if typing in an input field
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                        return;
                    }

                    // Spacebar activates temporary pan mode
                    if (e.code === 'Space' && !this.spacebarPressed) {
                        e.preventDefault();
                        this.spacebarPressed = true;

                        // Switch to pan mode if not already in it
                        if (this.currentTool !== 'pan') {
                            this.toolBeforeSpacebar = this.currentTool;
                            const wasInDrawingMode = this.drawingMode;
                            this.setTool('pan');
                            // If we weren't in drawing mode, the pan tool won't be active yet
                            if (!wasInDrawingMode) {
                                this.toggleDrawingMode(true);
                            }
                        }
                    }
                });

                document.addEventListener('keyup', (e) => {
                    // Ignore if typing in an input field
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                        return;
                    }

                    // Release spacebar returns to previous tool
                    if (e.code === 'Space' && this.spacebarPressed) {
                        e.preventDefault();
                        this.spacebarPressed = false;

                        // Return to previous tool if we have one
                        if (this.toolBeforeSpacebar) {
                            this.setTool(this.toolBeforeSpacebar);
                            this.toolBeforeSpacebar = null;
                        } else {
                            // If there was no previous tool, just exit drawing mode
                            this.toggleDrawingMode(false);
                        }
                    }
                });
            }

            handleDrawStart(event) {
                if (!this.drawingMode) return;

                // Pan mode doesn't draw, just pans
                if (this.currentTool === 'pan') {
                    const overlay = document.getElementById('drawingOverlay');
                    overlay.classList.add('panning');
                    return;
                }

                this.closeStrokePopover();
                this.closeColorPopover();

                this.captureUndoSnapshot();
                this.didMutatePaths = false;
                this.redoStack = [];
                this.updateUndoRedoButtons();

                this.activeDrawingColorIndex = this.currentColorIndex;
                this.pendingShapeColorIndex = null;

                this.isDrawing = true;
                this.startPoint = this.getDrawingPoint(event);

                if (this.currentTool === 'freehand') {
                    this.startFreehandPath(this.startPoint, this.activeDrawingColorIndex);
                } else {
                    this.pendingShapeColorIndex = this.activeDrawingColorIndex;
                    this.startShapePath(this.startPoint);
                }
            }

            handleDrawMove(event) {
                if (!this.drawingMode || !this.isDrawing) return;
                
                const point = this.getDrawingPoint(event);

                if (this.currentTool === 'freehand') {
                    this.continueFreehandPath(point);
                } else {
                    this.updateShapePreview(this.startPoint, point);
                }
            }

            handleDrawEnd(event) {
                // Remove panning cursor class if in pan mode
                if (this.currentTool === 'pan') {
                    const overlay = document.getElementById('drawingOverlay');
                    overlay.classList.remove('panning');
                }

                if (!this.isDrawing) return;

                const point = this.getDrawingPoint(event);
                this.isDrawing = false;

                if (this.currentTool === 'freehand') {
                    this.endFreehandPath();
                } else {
                    this.endShapePath(this.startPoint, point);
                }

                this.pendingShapeColorIndex = null;
                this.clearPreview();
                this.commitUndoSnapshot();
                this.updateUrl();
                this.scheduleAutoSave();
            }

            getDrawingPoint(event) {
                const pointer = event.touches && event.touches.length
                    ? event.touches[0]
                    : event.changedTouches && event.changedTouches.length
                        ? event.changedTouches[0]
                        : event;
                const rect = this.map.getContainer().getBoundingClientRect();
                const x = pointer.clientX - rect.left;
                const y = pointer.clientY - rect.top;
                const latLng = this.map.containerPointToLatLng([x, y]);
                return {
                    lat: latLng.lat,
                    lng: latLng.lng,
                    x,
                    y
                };
            }

            startFreehandPath(point, colorIndex) {
                this.currentPath = {
                    points: [{ lat: point.lat, lng: point.lng }],
                    strokeWidth: this.currentStroke,
                    type: 'freehand',
                    colorIndex
                };

                const path = this.createPathElement(colorIndex, this.currentStroke);
                path.setAttribute('d', this.latLngsToPathData(this.currentPath.points));

                document.getElementById('drawingGroup').appendChild(path);
                this.currentPath.element = path;
            }

            continueFreehandPath(point) {
                if (!this.currentPath) return;
                
                this.currentPath.points.push({ lat: point.lat, lng: point.lng });
                const pathData = this.latLngsToPathData(this.currentPath.points);
                this.currentPath.element.setAttribute('d', pathData);
            }

            endFreehandPath() {
                if (this.currentPath && this.currentPath.points.length > 1) {
                    this.paths.push({
                        points: this.currentPath.points.map(p => ({ lat: p.lat, lng: p.lng })),
                        strokeWidth: this.currentPath.strokeWidth,
                        type: 'freehand',
                        colorIndex: this.currentPath.colorIndex
                    });
                    this.markPathsMutated();
                }
                this.currentPath = null;
            }

            startShapePath(point) {
                this.pendingShapeColorIndex = this.pendingShapeColorIndex ?? this.currentColorIndex;
            }

            updateShapePreview(startPoint, currentPoint) {
                this.clearPreview();
                
                const preview = document.getElementById('previewGroup');
                let element;
                const startContainer = this.map.latLngToContainerPoint([startPoint.lat, startPoint.lng]);
                const currentContainer = this.map.latLngToContainerPoint([currentPoint.lat, currentPoint.lng]);

                switch (this.currentTool) {
                    case 'line':
                        element = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        element.setAttribute('class', 'preview-line');
                        element.setAttribute('x1', startContainer.x);
                        element.setAttribute('y1', startContainer.y);
                        element.setAttribute('x2', currentContainer.x);
                        element.setAttribute('y2', currentContainer.y);
                        element.setAttribute('stroke-width', this.currentStroke);
                        break;

                    case 'circle':
                        const radius = Math.sqrt(
                            Math.pow(currentContainer.x - startContainer.x, 2) +
                            Math.pow(currentContainer.y - startContainer.y, 2)
                        );
                        element = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        element.setAttribute('class', 'preview-circle');
                        element.setAttribute('cx', startContainer.x);
                        element.setAttribute('cy', startContainer.y);
                        element.setAttribute('r', radius);
                        element.setAttribute('stroke-width', this.currentStroke);
                        break;

                    case 'rectangle':
                        const minX = Math.min(startContainer.x, currentContainer.x);
                        const minY = Math.min(startContainer.y, currentContainer.y);
                        const width = Math.abs(currentContainer.x - startContainer.x);
                        const height = Math.abs(currentContainer.y - startContainer.y);
                        element = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        element.setAttribute('class', 'preview-rectangle');
                        element.setAttribute('x', minX);
                        element.setAttribute('y', minY);
                        element.setAttribute('width', width);
                        element.setAttribute('height', height);
                        element.setAttribute('stroke-width', this.currentStroke);
                        break;

                    case 'arrow':
                        element = this.createArrowElement(startContainer, currentContainer, true, this.activeDrawingColorIndex ?? this.currentColorIndex, this.currentStroke);
                        break;
                }

                if (element) {
                    const color = this.getColorHex(this.activeDrawingColorIndex ?? this.currentColorIndex);
                    element.setAttribute('stroke', color);
                    if (element.tagName === 'circle') {
                        element.setAttribute('fill', 'none');
                    }
                    preview.appendChild(element);
                    this.previewElement = element;
                }
            }

            endShapePath(startPoint, endPoint) {
                const colorIndex = this.pendingShapeColorIndex ?? this.currentColorIndex;
                const points = [
                    { lat: startPoint.lat, lng: startPoint.lng },
                    { lat: endPoint.lat, lng: endPoint.lng }
                ];
                let pathData = null;

                switch (this.currentTool) {
                    case 'line':
                        pathData = this.latLngsToPathData(points);
                        break;

                    case 'circle':
                        pathData = this.circlePathFromLatLng(points[0], points[1]);
                        break;

                    case 'rectangle':
                        pathData = this.rectanglePathFromLatLng(points[0], points[1]);
                        break;

                    case 'arrow':
                        pathData = this.latLngsToPathData(points);
                        break;
                }

                if (pathData) {
                    const element = this.createPathElement(colorIndex, this.currentStroke);
                    element.setAttribute('d', pathData);

                    if (this.currentTool === 'arrow') {
                        element.setAttribute('marker-end', `url(#arrowhead-${colorIndex})`);
                    }

                    document.getElementById('drawingGroup').appendChild(element);

                    this.paths.push({
                        points: this.currentTool === 'circle'
                            ? [points[0], points[1]]
                            : points,
                        strokeWidth: this.currentStroke,
                        type: this.currentTool,
                        colorIndex
                    });
                    this.markPathsMutated();
                }
            }

            createPathElement(colorIndex = this.currentColorIndex, strokeWidth = this.currentStroke) {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke', this.getColorHex(colorIndex));
                path.setAttribute('stroke-width', strokeWidth);
                path.setAttribute('stroke-linecap', 'round');
                path.setAttribute('stroke-linejoin', 'round');
                return path;
            }

            createArrowElement(start, end, isPreview = false, colorIndex = this.currentColorIndex, strokeWidth = this.currentStroke) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('class', isPreview ? 'preview-arrow' : '');
                line.setAttribute('x1', start.x);
                line.setAttribute('y1', start.y);
                line.setAttribute('x2', end.x);
                line.setAttribute('y2', end.y);
                line.setAttribute('stroke-width', strokeWidth);
                line.setAttribute('stroke', this.getColorHex(colorIndex));
                line.setAttribute('fill', 'none');
                if (!isPreview) {
                    line.setAttribute('marker-end', `url(#arrowhead-${colorIndex})`);
                }
                return line;
            }

            circleToPath(cx, cy, r) {
                return `M${cx-r},${cy} A${r},${r} 0 1,0 ${cx+r},${cy} A${r},${r} 0 1,0 ${cx-r},${cy}`;
            }

            clearPreview() {
                const preview = document.getElementById('previewGroup');
                preview.innerHTML = '';
                this.previewElement = null;
            }

            latLngsToPathData(points) {
                if (!points || points.length === 0) return '';

                const first = this.map.latLngToContainerPoint([points[0].lat, points[0].lng]);
                let d = `M${first.x},${first.y}`;
                for (let i = 1; i < points.length; i++) {
                    const pt = this.map.latLngToContainerPoint([points[i].lat, points[i].lng]);
                    d += ` L${pt.x},${pt.y}`;
                }
                return d;
            }

            circlePathFromLatLng(center, edge) {
                if (!center || !edge) return '';
                const centerPoint = this.map.latLngToContainerPoint([center.lat, center.lng]);
                const edgePoint = this.map.latLngToContainerPoint([edge.lat, edge.lng]);
                const radius = Math.sqrt(
                    Math.pow(edgePoint.x - centerPoint.x, 2) +
                    Math.pow(edgePoint.y - centerPoint.y, 2)
                );
                return this.circleToPath(centerPoint.x, centerPoint.y, radius);
            }

            rectanglePathFromLatLng(corner1, corner2) {
                if (!corner1 || !corner2) return '';
                const pt1 = this.map.latLngToContainerPoint([corner1.lat, corner1.lng]);
                const pt2 = this.map.latLngToContainerPoint([corner2.lat, corner2.lng]);
                const minX = Math.min(pt1.x, pt2.x);
                const minY = Math.min(pt1.y, pt2.y);
                const maxX = Math.max(pt1.x, pt2.x);
                const maxY = Math.max(pt1.y, pt2.y);
                return `M${minX},${minY} L${maxX},${minY} L${maxX},${maxY} L${minX},${maxY} Z`;
            }

            captureUndoSnapshot() {
                this.pendingUndoSnapshot = JSON.parse(JSON.stringify(this.paths));
            }

            markPathsMutated() {
                this.didMutatePaths = true;
                this.drawingSerializationDirty = true;
                this.cachedCompressedDrawing = '';
                this.compressInFlight = null;
                this.compressionGeneration += 1;
            }

            commitUndoSnapshot() {
                if (this.didMutatePaths && this.pendingUndoSnapshot) {
                    this.undoStack.push(this.pendingUndoSnapshot);
                    if (this.undoStack.length > 20) {
                        this.undoStack.shift();
                    }
                }
                this.pendingUndoSnapshot = null;
                this.didMutatePaths = false;
                this.updateUndoRedoButtons();
            }

            undo() {
                if (this.undoStack.length === 0) return;

                this.redoStack.push(JSON.parse(JSON.stringify(this.paths)));
                this.paths = this.undoStack.pop();
                this.pendingUndoSnapshot = null;
                this.didMutatePaths = false;
                this.drawingSerializationDirty = true;
                this.cachedCompressedDrawing = '';
                this.compressInFlight = null;
                this.compressionGeneration += 1;

                this.redrawPaths();
                this.updateUndoRedoButtons();
                this.updateUrl();
                this.scheduleAutoSave();
            }

            redo() {
                if (this.redoStack.length === 0) return;

                this.undoStack.push(JSON.parse(JSON.stringify(this.paths)));
                this.paths = this.redoStack.pop();
                this.pendingUndoSnapshot = null;
                this.didMutatePaths = false;
                this.drawingSerializationDirty = true;
                this.cachedCompressedDrawing = '';
                this.compressInFlight = null;
                this.compressionGeneration += 1;

                this.redrawPaths();
                this.updateUndoRedoButtons();
                this.updateUrl();
                this.scheduleAutoSave();
            }

            updateUndoRedoButtons() {
                if (this.undoButton) {
                    this.undoButton.disabled = this.undoStack.length === 0;
                }
                if (this.redoButton) {
                    this.redoButton.disabled = this.redoStack.length === 0;
                }
            }

            clearDrawing() {
                if (this.paths.length > 0) {
                    this.captureUndoSnapshot();
                    this.markPathsMutated();
                }
                this.redoStack = [];
                document.getElementById('drawingGroup').innerHTML = '';
                this.paths = [];
                this.commitUndoSnapshot();
                this.updateUrl();
                this.scheduleAutoSave();
                this.showStatus('Drawing cleared', 'success', this.clearButton);
            }

            goToLocation() {
                if (this.isTrackingLocation) {
                    this.stopLocationTracking();
                } else {
                    this.startLocationTracking();
                }
            }

            startLocationTracking() {
                if (!navigator.geolocation) {
                    this.showStatus('Geolocation not supported by this browser', 'error', this.locationButton);
                    return;
                }

                if (this.isTrackingLocation) return;

                this.isTrackingLocation = true;
                this.hasCenteredOnLocation = false;
                this.lastLocationUpdate = 0;
                this.updateLocationButtonState();
                this.showStatus('Tracking your location...', '', this.locationButton);

                const options = {
                    enableHighAccuracy: true,
                    timeout: 15000,
                    maximumAge: 15000
                };

                this.locationWatchId = navigator.geolocation.watchPosition(
                    (position) => this.handleLocationUpdate(position),
                    (error) => {
                        let message = 'Could not get location: ';
                        switch (error.code) {
                            case error.PERMISSION_DENIED: message += 'Location access denied by user'; break;
                            case error.POSITION_UNAVAILABLE: message += 'Location information unavailable'; break;
                            case error.TIMEOUT: message += 'Location request timed out'; break;
                            default: message += 'Unknown error occurred'; break;
                        }
                        this.showStatus(message, 'error', this.locationButton);
                        this.stopLocationTracking(true);
                    },
                    options
                );
            }

            stopLocationTracking(silent = false) {
                if (this.locationWatchId !== null && navigator.geolocation) {
                    navigator.geolocation.clearWatch(this.locationWatchId);
                    this.locationWatchId = null;
                }
                if (this.locationMarker) {
                    this.map.removeLayer(this.locationMarker);
                    this.locationMarker = null;
                }
                if (this.locationAccuracyCircle) {
                    this.map.removeLayer(this.locationAccuracyCircle);
                    this.locationAccuracyCircle = null;
                }
                const wasTracking = this.isTrackingLocation;
                this.isTrackingLocation = false;
                this.hasCenteredOnLocation = false;
                this.lastLocationUpdate = 0;
                this.updateLocationButtonState();
                if (wasTracking && !silent) {
                    this.showStatus('Location tracking disabled', '', this.locationButton);
                }
            }

            handleLocationUpdate(position) {
                if (!this.isTrackingLocation) return;

                const now = Date.now();
                if (now - this.lastLocationUpdate < 3000) {
                    return;
                }
                this.lastLocationUpdate = now;

                const lat = position.coords.latitude;
                const lng = position.coords.longitude;
                const accuracy = position.coords.accuracy || 0;
                const latLng = [lat, lng];

                if (!this.locationMarker) {
                    this.locationMarker = L.circleMarker(latLng, {
                        radius: 6,
                        color: '#007AFF',
                        fillColor: '#007AFF',
                        fillOpacity: 0.9,
                        weight: 2,
                        opacity: 0.9
                    }).addTo(this.map);
                } else {
                    this.locationMarker.setLatLng(latLng);
                }

                if (accuracy > 0) {
                    if (!this.locationAccuracyCircle) {
                        this.locationAccuracyCircle = L.circle(latLng, {
                            radius: Math.max(accuracy, 20),
                            color: '#007AFF',
                            fillColor: '#007AFF',
                            fillOpacity: 0.1,
                            weight: 1,
                            opacity: 0.2
                        }).addTo(this.map);
                    } else {
                        this.locationAccuracyCircle.setLatLng(latLng);
                        this.locationAccuracyCircle.setRadius(Math.max(accuracy, 20));
                    }
                } else if (this.locationAccuracyCircle) {
                    this.locationAccuracyCircle.setLatLng(latLng);
                    this.locationAccuracyCircle.setRadius(20);
                }

                if (!this.hasCenteredOnLocation) {
                    this.map.setView(latLng, Math.max(this.map.getZoom(), 15), { animate: true });
                    this.hasCenteredOnLocation = true;
                    this.showStatus('Location found!', 'success', this.locationButton);
                }
            }

            updateLocationButtonState() {
                if (!this.locationButton) return;
                this.locationButton.classList.toggle('active', this.isTrackingLocation);
                this.locationButton.setAttribute('aria-pressed', String(this.isTrackingLocation));
            }

            startAutoSave() {
                this.stopAutoSave();
                this.autoSaveTimer = setInterval(() => {
                    this.saveState();
                }, 30000);
            }

            stopAutoSave() {
                if (this.autoSaveTimer) {
                    clearInterval(this.autoSaveTimer);
                    this.autoSaveTimer = null;
                }
            }

            scheduleAutoSave() {
                clearTimeout(this.quickSaveTimer);
                this.quickSaveTimer = setTimeout(() => {
                    this.saveState();
                }, 1000);
            }

            getColorHex(index) {
                return this.colorPalette[index] || this.colorPalette[0];
            }

            initColorControls() {
                const previewBtn = document.getElementById('colorPreviewBtn');
                const swatch = document.getElementById('colorPreviewSwatch');
                const label = document.getElementById('colorPreviewLabel');
                if (!previewBtn || !swatch || !label) return;

                this.colorPreviewBtn = previewBtn;
                this.colorPreviewSwatch = swatch;
                this.colorPreviewLabel = label;

                previewBtn.addEventListener('click', (event) => {
                    this.statusAnchor = event.currentTarget;
                    this.toggleColorPopover();
                });
                previewBtn.setAttribute('aria-expanded', 'false');
                previewBtn.setAttribute('aria-haspopup', 'true');

                this.renderColorPreview();
            }

            updateColorButtons() {
                this.renderColorPreview();
                if (this.colorPopover) {
                    const options = this.colorPopover.querySelectorAll('.color-option');
                    options.forEach((option, index) => {
                        option.classList.toggle('active', index === this.currentColorIndex);
                    });
                }
            }

            renderColorPreview() {
                const color = this.getColorHex(this.currentColorIndex);
                const name = this.colorNames[this.currentColorIndex] || 'Color';
                if (this.colorPreviewSwatch) {
                    this.colorPreviewSwatch.style.backgroundColor = color;
                }
                if (this.colorPreviewLabel) {
                    this.colorPreviewLabel.textContent = name;
                }
                if (this.colorPreviewBtn) {
                    this.colorPreviewBtn.setAttribute('aria-label', `Current color ${name}`);
                    this.colorPreviewBtn.setAttribute('title', `Current color ${name}`);
                }
                this.updateWidthPreview();
            }

            toggleColorPopover() {
                if (this.colorPopover) {
                    this.closeColorPopover();
                } else {
                    this.openColorPopover();
                }
            }

            openColorPopover() {
                if (!this.colorPreviewBtn || this.colorPopover) return;

                this.closeStrokePopover();

                const overlay = document.createElement('div');
                overlay.className = 'picker-overlay';
                overlay.addEventListener('click', () => this.closeColorPopover());
                document.body.appendChild(overlay);
                this.colorOverlay = overlay;

                const popover = document.createElement('div');
                popover.className = 'color-popover';
                popover.style.position = 'absolute';
                this.colorPalette.forEach((hex, index) => {
                    const option = document.createElement('button');
                    option.type = 'button';
                    option.className = 'color-option';
                    option.style.background = hex;
                    option.style.backgroundColor = hex;
                    const name = this.colorNames[index] || `Color ${index + 1}`;
                    option.setAttribute('aria-label', `Choose ${name}`);
                    option.setAttribute('title', name);
                    if (index === this.currentColorIndex) {
                        option.classList.add('active');
                    }
                    option.addEventListener('click', () => {
                        this.setColor(index);
                        this.closeColorPopover();
                    });
                    popover.appendChild(option);
                });
                document.body.appendChild(popover);
                this.colorPopover = popover;

                this.positionColorPopover();

                this.boundColorPopoverResize = () => this.positionColorPopover();
                this.boundColorPopoverKeyHandler = (event) => {
                    if (event.key === 'Escape') {
                        event.preventDefault();
                        this.closeColorPopover();
                    }
                };
                window.addEventListener('resize', this.boundColorPopoverResize);
                document.addEventListener('keydown', this.boundColorPopoverKeyHandler, true);
                this.boundColorPopoverScroll = () => this.positionColorPopover();
                window.addEventListener('scroll', this.boundColorPopoverScroll, true);

                this.colorPreviewBtn.classList.add('active');
                this.colorPreviewBtn.setAttribute('aria-expanded', 'true');
            }

            positionColorPopover() {
                if (!this.colorPopover || !this.colorPreviewBtn) return;
                const rect = this.colorPreviewBtn.getBoundingClientRect();
                const popover = this.colorPopover;
                popover.style.visibility = 'hidden';
                popover.style.left = '0px';
                popover.style.top = '0px';
                popover.style.bottom = 'auto';
                const popRect = popover.getBoundingClientRect();
                const viewportTop = window.scrollY + 8;
                const viewportBottom = window.scrollY + window.innerHeight - 8;
                let top = rect.bottom + window.scrollY + 8;
                if (top + popRect.height > viewportBottom) {
                    top = rect.top + window.scrollY - popRect.height - 8;
                    if (top < viewportTop) {
                        top = Math.max(viewportTop, viewportBottom - popRect.height);
                    }
                }
                let left = rect.left + rect.width / 2 + window.scrollX - popRect.width / 2;
                const minLeft = window.scrollX + 8;
                const maxLeft = window.scrollX + window.innerWidth - popRect.width - 8;
                if (left < minLeft) left = minLeft;
                if (left > maxLeft) left = maxLeft;
                popover.style.top = `${top}px`;
                popover.style.left = `${left}px`;
                popover.style.visibility = 'visible';
            }

            closeColorPopover() {
                if (this.colorOverlay) {
                    this.colorOverlay.remove();
                    this.colorOverlay = null;
                }
                if (this.colorPopover) {
                    this.colorPopover.remove();
                    this.colorPopover = null;
                }
                if (this.boundColorPopoverResize) {
                    window.removeEventListener('resize', this.boundColorPopoverResize);
                    this.boundColorPopoverResize = null;
                }
                if (this.boundColorPopoverScroll) {
                    window.removeEventListener('scroll', this.boundColorPopoverScroll, true);
                    this.boundColorPopoverScroll = null;
                }
                if (this.boundColorPopoverKeyHandler) {
                    document.removeEventListener('keydown', this.boundColorPopoverKeyHandler, true);
                    this.boundColorPopoverKeyHandler = null;
                }
                if (this.colorPreviewBtn) {
                    this.colorPreviewBtn.classList.remove('active');
                    this.colorPreviewBtn.setAttribute('aria-expanded', 'false');
                }
            }

            setColor(index) {
                if (index < 0 || index >= this.colorPalette.length) return;
                this.currentColorIndex = index;
                this.activeDrawingColorIndex = this.currentColorIndex;
                this.updateColorButtons();
            }

            initWidthControls() {
                const pickerBtn = document.getElementById('strokePickerBtn');
                const line = document.getElementById('strokePickerLine');
                const label = document.getElementById('strokePickerLabel');

                this.strokePickerBtn = pickerBtn || null;
                this.strokePickerLine = line || null;
                this.strokePickerLabel = label || null;

                if (pickerBtn) {
                    pickerBtn.addEventListener('click', (event) => {
                        this.statusAnchor = event.currentTarget;
                        this.toggleStrokePopover();
                    });
                    pickerBtn.setAttribute('aria-haspopup', 'true');
                    pickerBtn.setAttribute('aria-expanded', 'false');
                }

                this.updateWidthButtons();
            }

            updateWidthButtons() {
                const label = this.widthOptionLabels[this.currentWidthIndex] || `${this.currentStroke}px`;
                if (this.strokePickerLabel) {
                    this.strokePickerLabel.textContent = label;
                }
                if (this.strokePickerBtn) {
                    this.strokePickerBtn.setAttribute('aria-label', `Stroke width ${label}`);
                    this.strokePickerBtn.setAttribute('title', `Stroke width ${label}`);
                    this.strokePickerBtn.setAttribute('aria-expanded', this.strokePopover ? 'true' : 'false');
                }
                this.updateWidthPreview();
            }

            updateWidthPreview() {
                const color = this.getColorHex(this.currentColorIndex);
                if (this.strokePickerLine) {
                    this.strokePickerLine.style.setProperty('--stroke-width', `${this.currentStroke}px`);
                    this.strokePickerLine.style.setProperty('--stroke-color', color);
                }
                if (this.strokePopover) {
                    const lines = this.strokePopover.querySelectorAll('.stroke-option-line');
                    lines.forEach((lineEl) => {
                        const idx = parseInt(lineEl.dataset.index || '0', 10);
                        const widthValue = this.widthOptions[idx] || this.currentStroke;
                        lineEl.style.setProperty('--stroke-width', `${widthValue}px`);
                        lineEl.style.setProperty('--stroke-color', color);
                    });
                    const options = this.strokePopover.querySelectorAll('.stroke-option');
                    options.forEach((option, idx) => {
                        option.classList.toggle('active', idx === this.currentWidthIndex);
                    });
                }
            }

            toggleStrokePopover() {
                if (this.strokePopover) {
                    this.closeStrokePopover();
                } else {
                    this.openStrokePopover();
                }
            }

            openStrokePopover() {
                if (!this.strokePickerBtn || this.strokePopover) return;

                this.closeColorPopover();

                const overlay = document.createElement('div');
                overlay.className = 'picker-overlay';
                overlay.addEventListener('click', () => this.closeStrokePopover());
                document.body.appendChild(overlay);
                this.strokeOverlay = overlay;

                const popover = document.createElement('div');
                popover.className = 'stroke-popover';
                this.widthOptions.forEach((value, index) => {
                    const option = document.createElement('button');
                    option.type = 'button';
                    option.className = 'stroke-option';
                    const name = this.widthOptionLabels[index] || `${value}px`;
                    option.setAttribute('aria-label', `Select ${name} stroke`);
                    option.setAttribute('title', `${name} stroke`);
                    if (index === this.currentWidthIndex) {
                        option.classList.add('active');
                    }

                    const line = document.createElement('span');
                    line.className = 'stroke-option-line';
                    line.dataset.index = String(index);
                    line.style.setProperty('--stroke-width', `${value}px`);
                    line.style.setProperty('--stroke-color', this.getColorHex(this.currentColorIndex));
                    line.setAttribute('aria-hidden', 'true');

                    const text = document.createElement('span');
                    text.textContent = name;

                    option.appendChild(line);
                    option.appendChild(text);

                    option.addEventListener('click', () => {
                        this.setStrokeWidth(index);
                        this.closeStrokePopover();
                    });

                    popover.appendChild(option);
                });
                document.body.appendChild(popover);
                this.strokePopover = popover;

                this.positionStrokePopover();

                this.boundStrokePopoverResize = () => this.positionStrokePopover();
                window.addEventListener('resize', this.boundStrokePopoverResize);

                this.boundStrokePopoverScroll = () => this.positionStrokePopover();
                window.addEventListener('scroll', this.boundStrokePopoverScroll, true);

                this.boundStrokePopoverKeyHandler = (event) => {
                    if (event.key === 'Escape') {
                        event.stopPropagation();
                        this.closeStrokePopover();
                    }
                };
                document.addEventListener('keydown', this.boundStrokePopoverKeyHandler, true);

                this.strokePickerBtn.classList.add('active');
                this.strokePickerBtn.setAttribute('aria-expanded', 'true');
            }

            positionStrokePopover() {
                if (!this.strokePopover || !this.strokePickerBtn) return;

                const rect = this.strokePickerBtn.getBoundingClientRect();
                const popover = this.strokePopover;
                popover.style.visibility = 'hidden';
                popover.style.left = '0px';
                popover.style.top = '0px';
                popover.style.bottom = 'auto';
                const popoverRect = popover.getBoundingClientRect();
                const viewportTop = window.scrollY + 8;
                const viewportBottom = window.scrollY + window.innerHeight - 8;
                let top = rect.bottom + window.scrollY + 8;
                if (top + popoverRect.height > viewportBottom) {
                    top = rect.top + window.scrollY - popoverRect.height - 8;
                    if (top < viewportTop) {
                        top = Math.max(viewportTop, viewportBottom - popoverRect.height);
                    }
                }
                let left = rect.left + rect.width / 2 + window.scrollX - popoverRect.width / 2;
                const minLeft = window.scrollX + 8;
                const maxLeft = window.scrollX + window.innerWidth - popoverRect.width - 8;
                if (left < minLeft) left = minLeft;
                if (left > maxLeft) left = maxLeft;
                popover.style.top = `${top}px`;
                popover.style.left = `${left}px`;
                popover.style.visibility = 'visible';
            }

            closeStrokePopover() {
                if (this.strokeOverlay) {
                    this.strokeOverlay.remove();
                    this.strokeOverlay = null;
                }
                if (this.strokePopover) {
                    this.strokePopover.remove();
                    this.strokePopover = null;
                }
                if (this.boundStrokePopoverResize) {
                    window.removeEventListener('resize', this.boundStrokePopoverResize);
                    this.boundStrokePopoverResize = null;
                }
                if (this.boundStrokePopoverScroll) {
                    window.removeEventListener('scroll', this.boundStrokePopoverScroll, true);
                    this.boundStrokePopoverScroll = null;
                }
                if (this.boundStrokePopoverKeyHandler) {
                    document.removeEventListener('keydown', this.boundStrokePopoverKeyHandler, true);
                    this.boundStrokePopoverKeyHandler = null;
                }
                if (this.strokePickerBtn) {
                    this.strokePickerBtn.classList.remove('active');
                    this.strokePickerBtn.setAttribute('aria-expanded', 'false');
                }
            }

            setStrokeWidth(index) {
                if (index < 0 || index >= this.widthOptions.length) return;
                this.currentWidthIndex = index;
                this.currentStroke = this.widthOptions[index];
                if (this.strokePopover) {
                    this.closeStrokePopover();
                }
                this.updateWidthButtons();
            }

            initSearchControls() {
                this.searchInput = document.getElementById('searchInput');
                this.searchResults = document.getElementById('searchResults');
                const searchToggleBtn = document.getElementById('searchToggleBtn');
                const searchContainer = document.getElementById('searchContainer');

                if (!this.searchInput || !this.searchResults || !searchToggleBtn || !searchContainer) return;

                // Toggle search visibility
                searchToggleBtn.addEventListener('click', () => {
                    const isVisible = searchContainer.style.display !== 'none';
                    if (isVisible) {
                        searchContainer.style.display = 'none';
                        searchToggleBtn.setAttribute('aria-pressed', 'false');
                        this.hideSearchResults();
                    } else {
                        searchContainer.style.display = '';
                        searchToggleBtn.setAttribute('aria-pressed', 'true');
                        this.searchInput.focus();
                    }
                });

                // Hide search when map moves
                this.map.on('movestart', () => {
                    if (searchContainer.style.display !== 'none') {
                        searchContainer.style.display = 'none';
                        searchToggleBtn.setAttribute('aria-pressed', 'false');
                        this.hideSearchResults();
                    }
                });

                this.searchInput.addEventListener('input', (e) => {
                    this.handleSearchInput(e.target.value);
                });

                this.searchInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        this.hideSearchResults();
                        this.searchInput.blur();
                        searchContainer.style.display = 'none';
                        searchToggleBtn.setAttribute('aria-pressed', 'false');
                    }
                });

                // Close results when clicking outside
                document.addEventListener('click', (e) => {
                    if (!this.searchInput.contains(e.target) && !this.searchResults.contains(e.target) && e.target !== searchToggleBtn) {
                        this.hideSearchResults();
                    }
                });
            }

            handleSearchInput(query) {
                clearTimeout(this.searchDebounceTimer);

                if (!query || query.trim().length < 2) {
                    this.hideSearchResults();
                    return;
                }

                this.searchDebounceTimer = setTimeout(() => {
                    this.performSearch(query.trim());
                }, 500);
            }

            async performSearch(query) {
                // Rate limiting: 1 request per second
                const now = Date.now();
                const timeSinceLastSearch = now - this.lastSearchTime;
                if (timeSinceLastSearch < 1000) {
                    const delay = 1000 - timeSinceLastSearch;
                    setTimeout(() => this.performSearch(query), delay);
                    return;
                }
                this.lastSearchTime = now;

                this.showSearchLoading();

                try {
                    const url = new URL('https://nominatim.openstreetmap.org/search');
                    url.searchParams.set('format', 'json');
                    url.searchParams.set('q', query);
                    url.searchParams.set('limit', '5');
                    url.searchParams.set('addressdetails', '1');

                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 5000);

                    const response = await fetch(url.toString(), {
                        headers: {
                            'User-Agent': 'MapAnnotator/1.0 (https://github.com/gnyman/mapdraw)'
                        },
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId);

                    if (!response.ok) {
                        throw new Error('Search request failed');
                    }

                    const results = await response.json();
                    this.displaySearchResults(results);

                } catch (error) {
                    if (error.name === 'AbortError') {
                        this.showSearchError('Search timed out');
                    } else {
                        this.showSearchError('Search unavailable');
                    }
                }
            }

            showSearchLoading() {
                this.searchResults.innerHTML = '<div class="search-loading">Searching...</div>';
                this.searchResults.classList.add('show');
            }

            displaySearchResults(results) {
                if (!results || results.length === 0) {
                    this.searchResults.innerHTML = '<div class="search-loading">No results found</div>';
                    return;
                }

                this.searchResults.innerHTML = '';

                results.forEach(result => {
                    const item = document.createElement('div');
                    item.className = 'search-result-item';
                    item.textContent = result.display_name;
                    item.setAttribute('role', 'option');
                    item.setAttribute('tabindex', '0');

                    item.addEventListener('click', () => {
                        this.selectSearchResult(result);
                    });

                    item.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            this.selectSearchResult(result);
                        }
                    });

                    this.searchResults.appendChild(item);
                });

                this.searchResults.classList.add('show');
            }

            showSearchError(message) {
                this.searchResults.innerHTML = `<div class="search-loading">${message}</div>`;
                this.searchResults.classList.add('show');
            }

            hideSearchResults() {
                this.searchResults.classList.remove('show');
                this.searchResults.innerHTML = '';
            }

            selectSearchResult(result) {
                const lat = parseFloat(result.lat);
                const lng = parseFloat(result.lon);

                if (!Number.isFinite(lat) || !Number.isFinite(lng)) return;

                // Remove previous search marker
                this.removeSearchMarker();

                // Pan and zoom to location
                this.map.setView([lat, lng], 16, { animate: true });

                // Add temporary marker with inline SVG
                const markerIcon = L.icon({
                    iconUrl: 'data:image/svg+xml;base64,' + btoa(`
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 36">
                            <path fill="#007AFF" d="M12 0C5.4 0 0 5.4 0 12c0 9 12 24 12 24s12-15 12-24c0-6.6-5.4-12-12-12z"/>
                            <circle fill="white" cx="12" cy="12" r="4"/>
                        </svg>
                    `),
                    iconSize: [24, 36],
                    iconAnchor: [12, 36]
                });

                this.searchMarker = L.marker([lat, lng], { icon: markerIcon }).addTo(this.map);

                // Auto-remove marker after 10 seconds
                clearTimeout(this.searchMarkerTimer);
                this.searchMarkerTimer = setTimeout(() => {
                    this.removeSearchMarker();
                }, 10000);

                // Hide results and clear input
                this.hideSearchResults();
                this.searchInput.value = '';
                this.searchInput.blur();
            }

            removeSearchMarker() {
                if (this.searchMarker) {
                    this.map.removeLayer(this.searchMarker);
                    this.searchMarker = null;
                }
                if (this.searchMarkerTimer) {
                    clearTimeout(this.searchMarkerTimer);
                    this.searchMarkerTimer = null;
                }
            }

            initMarkers() {
                const defs = document.getElementById('arrowMarkers');
                if (!defs) return;

                defs.innerHTML = '';
                this.colorPalette.forEach((color, index) => {
                    const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                    marker.setAttribute('id', `arrowhead-${index}`);
                    marker.setAttribute('markerWidth', '10');
                    marker.setAttribute('markerHeight', '7');
                    marker.setAttribute('refX', '9');
                    marker.setAttribute('refY', '3.5');
                    marker.setAttribute('orient', 'auto');
                    marker.setAttribute('markerUnits', 'strokeWidth');

                    const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    polygon.setAttribute('points', '0 0, 10 3.5, 0 7');
                    polygon.setAttribute('fill', color);
                    marker.appendChild(polygon);

                    defs.appendChild(marker);
                });
            }

            writeVarUint(target, value) {
                let v = value >>> 0;
                while (v >= 0x80) {
                    target.push((v & 0x7f) | 0x80);
                    v >>>= 7;
                }
                target.push(v & 0x7f);
            }

            writeVarInt(target, value) {
                let zigzag = ((value << 1) ^ (value >> 31)) >>> 0;
                while (zigzag >= 0x80) {
                    target.push((zigzag & 0x7f) | 0x80);
                    zigzag >>>= 7;
                }
                target.push(zigzag & 0x7f);
            }

            readVarUint(bytes, cursor) {
                let result = 0;
                let shift = 0;
                while (true) {
                    if (cursor.index >= bytes.length || shift > 35) {
                        throw new Error('Corrupt drawing payload');
                    }
                    const byte = bytes[cursor.index++];
                    result |= (byte & 0x7f) << shift;
                    if ((byte & 0x80) === 0) {
                        return result >>> 0;
                    }
                    shift += 7;
                }
            }

            readVarInt(bytes, cursor) {
                const raw = this.readVarUint(bytes, cursor);
                const value = (raw >>> 1) ^ -(raw & 1);
                return value | 0;
            }

            toUrlSafeBase64(bytes) {
                let binary = '';
                const chunkSize = 0x8000;
                for (let i = 0; i < bytes.length; i += chunkSize) {
                    const chunk = bytes.subarray(i, i + chunkSize);
                    binary += String.fromCharCode.apply(null, chunk);
                }
                return btoa(binary).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
            }

            fromUrlSafeBase64(str) {
                const base64 = str.replace(/-/g, '+').replace(/_/g, '/');
                const padded = base64 + '='.repeat((4 - base64.length % 4) % 4);
                const binary = atob(padded);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                }
                return bytes;
            }

            normalizePathPoints(rawPoints, requireTwoPoints = false) {
                const normalized = [];
                let lastLat = null;
                let lastLng = null;

                (rawPoints || []).forEach(point => {
                    if (!Number.isFinite(point.lat) || !Number.isFinite(point.lng)) return;
                    const latInt = Math.round(point.lat * 1e6);
                    const lngInt = Math.round(point.lng * 1e6);
                    if (normalized.length === 0 || latInt !== lastLat || lngInt !== lastLng) {
                        normalized.push({ lat: latInt, lng: lngInt });
                        lastLat = latInt;
                        lastLng = lngInt;
                    }
                });

                if (requireTwoPoints && normalized.length < 2) {
                    return [];
                }

                return normalized;
            }

            getClosestWidthIndex(value) {
                let bestIndex = 0;
                let bestDiff = Number.POSITIVE_INFINITY;
                this.widthOptions.forEach((width, index) => {
                    const diff = Math.abs(width - value);
                    if (diff < bestDiff) {
                        bestDiff = diff;
                        bestIndex = index;
                    }
                });
                return bestIndex;
            }

            encodePathsToBinary() {
                const typeToCode = { freehand: 0, line: 1, circle: 2, arrow: 3, rectangle: 4 };
                const prepared = [];

                this.paths.forEach(path => {
                    const requiresTwoPoints = path.type === 'circle' || path.type === 'line' || path.type === 'arrow' || path.type === 'rectangle';
                    const normalized = this.normalizePathPoints(path.points, requiresTwoPoints);
                    if (normalized.length === 0) return;

                    const colorIndex = Math.max(0, Math.min(7, Number.isInteger(path.colorIndex) ? path.colorIndex : 0)) % this.colorPalette.length;
                    const widthIndex = this.getClosestWidthIndex(path.strokeWidth || this.widthOptions[this.currentWidthIndex]);
                    const snappedWidth = this.widthOptions[widthIndex];
                    const typeCode = typeToCode[path.type] ?? typeToCode.freehand;

                    path.colorIndex = colorIndex;
                    path.strokeWidth = snappedWidth;

                    prepared.push({
                        typeCode,
                        widthIndex,
                        colorIndex,
                        points: normalized
                    });
                });

                const bytes = [];
                bytes.push(3); // version
                this.writeVarUint(bytes, prepared.length);

                prepared.forEach(path => {
                    const meta = ((path.typeCode & 0x07) << 5) | ((path.widthIndex & 0x03) << 3) | (path.colorIndex & 0x07);
                    bytes.push(meta & 0xff);
                    this.writeVarUint(bytes, path.points.length);

                    let prevLat = 0;
                    let prevLng = 0;
                    path.points.forEach((point, index) => {
                        const lat = point.lat | 0;
                        const lng = point.lng | 0;
                        if (index === 0) {
                            this.writeVarInt(bytes, lat);
                            this.writeVarInt(bytes, lng);
                        } else {
                            this.writeVarInt(bytes, lat - prevLat);
                            this.writeVarInt(bytes, lng - prevLng);
                        }
                        prevLat = lat;
                        prevLng = lng;
                    });
                });

                return new Uint8Array(bytes);
            }

            decodePathsFromBinary(bytes) {
                if (!bytes || bytes.length < 2) {
                    throw new Error('Corrupt drawing payload');
                }

                const cursor = { index: 0 };
                const version = bytes[cursor.index++];
                if (version !== 3) {
                    throw new Error('Unsupported drawing format');
                }

                const pathCount = this.readVarUint(bytes, cursor);
                const codeToType = ['freehand', 'line', 'circle', 'arrow', 'rectangle'];
                const paths = [];

                for (let i = 0; i < pathCount; i++) {
                    if (cursor.index >= bytes.length) {
                        throw new Error('Corrupt drawing payload');
                    }

                    const meta = bytes[cursor.index++];
                    const typeCode = (meta >> 5) & 0x07;
                    const widthIndex = (meta >> 3) & 0x03;
                    const colorIndex = meta & 0x07;

                    const pointCount = this.readVarUint(bytes, cursor);
                    const points = [];
                    let lat = 0;
                    let lng = 0;
                    for (let p = 0; p < pointCount; p++) {
                        const deltaLat = this.readVarInt(bytes, cursor);
                        const deltaLng = this.readVarInt(bytes, cursor);
                        if (p === 0) {
                            lat = deltaLat;
                            lng = deltaLng;
                        } else {
                            lat += deltaLat;
                            lng += deltaLng;
                        }
                        points.push({ lat: lat / 1e6, lng: lng / 1e6 });
                    }

                    const strokeWidth = this.widthOptions[widthIndex] ?? this.widthOptions[0];

                    paths.push({
                        type: codeToType[typeCode] || 'freehand',
                        strokeWidth,
                        colorIndex: colorIndex % this.colorPalette.length,
                        points
                    });
                }

                return paths;
            }

            compressDrawing() {
                if (this.paths.length === 0) {
                    this.cachedCompressedDrawing = '';
                    this.drawingSerializationDirty = false;
                    this.compressInFlight = null;
                    return Promise.resolve('');
                }

                if (!this.drawingSerializationDirty && this.cachedCompressedDrawing && !this.compressInFlight) {
                    return Promise.resolve(this.cachedCompressedDrawing);
                }

                if (this.compressInFlight) {
                    return this.compressInFlight;
                }

                if (!window.UZIP || typeof window.UZIP.deflateRaw !== 'function') {
                    return Promise.reject(new Error('UZIP library unavailable'));
                }

                const targetGeneration = this.compressionGeneration;

                this.compressInFlight = new Promise((resolve, reject) => {
                    try {
                        const binary = this.encodePathsToBinary();
                        const compressed = window.UZIP.deflateRaw(binary);
                        const compressedBytes = compressed instanceof Uint8Array ? compressed : new Uint8Array(compressed);
                        const encoded = this.toUrlSafeBase64(compressedBytes);

                        if (this.compressionGeneration === targetGeneration) {
                            this.cachedCompressedDrawing = encoded;
                            this.drawingSerializationDirty = false;
                        }

                        resolve(encoded);
                    } catch (error) {
                        reject(error);
                    }
                }).finally(() => {
                    this.compressInFlight = null;
                });

                return this.compressInFlight;
            }

            decompressDrawing(encoded) {
                if (!encoded) return;

                if (!window.UZIP || typeof window.UZIP.inflateRaw !== 'function') {
                    console.error('UZIP library unavailable');
                    this.showStatus('Failed to load drawing', 'error', this.shareButton);
                    return;
                }

                try {
                    this.initMarkers();
                    const compressedBytes = this.fromUrlSafeBase64(encoded);
                    const inflated = window.UZIP.inflateRaw(compressedBytes);
                    const binary = inflated instanceof Uint8Array ? inflated : new Uint8Array(inflated);
                    const paths = this.decodePathsFromBinary(binary);

                    this.paths = paths;
                    this.undoStack = [];
                    this.redoStack = [];
                    this.pendingUndoSnapshot = null;
                    this.didMutatePaths = false;
                    this.drawingSerializationDirty = false;
                    this.cachedCompressedDrawing = encoded;
                    this.compressInFlight = null;
                    this.compressionGeneration += 1;
                    this.pendingShapeColorIndex = null;

                    this.redrawPaths();
                    this.updateUndoRedoButtons();
                    this.updateToolButtons();
                    this.updateColorButtons();
                    this.updateWidthButtons();
                    this.showStatus('Drawing loaded', 'success', this.shareButton);
                } catch (error) {
                    console.error('Failed to decompress drawing:', error);
                    this.showStatus('Failed to load drawing', 'error', this.shareButton);
                }
            }

            haversineDistance(lat1, lng1, lat2, lng2) {
                const R = 6371000; // Earth radius in meters
                const Ï1 = lat1 * Math.PI / 180;
                const Ï2 = lat2 * Math.PI / 180;
                const ÎÏ = (lat2 - lat1) * Math.PI / 180;
                const ÎÎ» = (lng2 - lng1) * Math.PI / 180;
                const a = Math.sin(ÎÏ/2) * Math.sin(ÎÏ/2) +
                          Math.cos(Ï1) * Math.cos(Ï2) *
                          Math.sin(ÎÎ»/2) * Math.sin(ÎÎ»/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                return R * c;
            }

            exportGeoJSON() {
                if (this.paths.length === 0) {
                    this.showStatus('No drawing to export', 'error', this.exportButton);
                    return;
                }

                const features = [];

                this.paths.forEach(path => {
                    const color = this.getColorHex(path.colorIndex);
                    const properties = {
                        'stroke': color,
                        'stroke-width': path.strokeWidth,
                        'shape_type': path.type
                    };

                    let geometry;

                    switch (path.type) {
                        case 'freehand':
                        case 'line':
                            // GeoJSON uses [lng, lat] order!
                            geometry = {
                                type: 'LineString',
                                coordinates: path.points.map(p => [p.lng, p.lat])
                            };
                            break;

                        case 'arrow':
                            geometry = {
                                type: 'LineString',
                                coordinates: path.points.slice(0, 2).map(p => [p.lng, p.lat])
                            };
                            properties.arrowhead = true;
                            break;

                        case 'circle':
                            if (path.points.length < 2) return;
                            const center = path.points[0];
                            const edge = path.points[1];
                            const radius = this.haversineDistance(center.lat, center.lng, edge.lat, edge.lng);

                            geometry = {
                                type: 'Point',
                                coordinates: [center.lng, center.lat]  // [lng, lat]!
                            };
                            properties.radius_meters = radius;
                            break;

                        case 'rectangle':
                            if (path.points.length < 2) return;
                            const p1 = path.points[0];
                            const p2 = path.points[1];
                            // Create closed polygon ring [sw, se, ne, nw, sw]
                            geometry = {
                                type: 'Polygon',
                                coordinates: [[
                                    [p1.lng, p1.lat],
                                    [p2.lng, p1.lat],
                                    [p2.lng, p2.lat],
                                    [p1.lng, p2.lat],
                                    [p1.lng, p1.lat]  // Close the ring
                                ]]
                            };
                            break;

                        default:
                            return;
                    }

                    features.push({
                        type: 'Feature',
                        geometry: geometry,
                        properties: properties
                    });
                });

                const geojson = {
                    type: 'FeatureCollection',
                    features: features
                };

                // Download as file
                const blob = new Blob([JSON.stringify(geojson, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `map-drawing-${Date.now()}.geojson`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                this.showStatus(`Exported ${features.length} features`, 'success', this.exportButton);
            }

            importGeoJSON() {
                const fileInput = document.getElementById('geojsonFileInput');
                if (!fileInput) return;

                fileInput.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    // Validate file size (max 10MB)
                    if (file.size > 10 * 1024 * 1024) {
                        this.showStatus('File too large (max 10MB)', 'error', this.importButton);
                        fileInput.value = '';
                        return;
                    }

                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const geojson = JSON.parse(event.target.result);
                            this.processGeoJSONImport(geojson);
                        } catch (error) {
                            this.showStatus('Invalid JSON file', 'error', this.importButton);
                        }
                    };
                    reader.readAsText(file);
                    fileInput.value = ''; // Reset for re-import
                };

                fileInput.click();
            }

            processGeoJSONImport(geojson) {
                if (!geojson || geojson.type !== 'FeatureCollection') {
                    this.showStatus('Not a valid GeoJSON FeatureCollection', 'error', this.importButton);
                    return;
                }

                const newPaths = [];
                let skipped = 0;

                (geojson.features || []).forEach(feature => {
                    if (!feature.geometry || !feature.geometry.type) {
                        skipped++;
                        return;
                    }

                    const props = feature.properties || {};
                    const shapeType = props.shape_type || this.inferShapeType(feature.geometry.type, props);

                    // Find closest color
                    const strokeColor = props.stroke || '#FF3B30';
                    const colorIndex = this.findClosestColorIndex(strokeColor);

                    // Find closest width
                    const strokeWidth = props['stroke-width'] || 4;
                    const widthIndex = this.getClosestWidthIndex(strokeWidth);

                    let points = [];

                    switch (feature.geometry.type) {
                        case 'LineString':
                            // Convert GeoJSON [lng,lat] to Leaflet {lat,lng}
                            points = feature.geometry.coordinates.map(c => ({ lng: c[0], lat: c[1] }));
                            break;

                        case 'Point':
                            // Circle: convert radius back to edge point
                            const centerLng = feature.geometry.coordinates[0];
                            const centerLat = feature.geometry.coordinates[1];
                            const radiusMeters = props.radius_meters || 100;

                            // Approximate edge point (simple method, good enough for small radii)
                            const R = 6371000; // Earth radius in meters
                            const latOffset = (radiusMeters / R) * (180 / Math.PI);
                            const edgeLat = centerLat + latOffset;

                            points = [
                                { lng: centerLng, lat: centerLat },
                                { lng: centerLng, lat: edgeLat }
                            ];
                            break;

                        case 'Polygon':
                            // Rectangle: extract first 2 diagonal corners
                            const ring = feature.geometry.coordinates[0];
                            if (ring && ring.length >= 4) {
                                points = [
                                    { lng: ring[0][0], lat: ring[0][1] },
                                    { lng: ring[2][0], lat: ring[2][1] }
                                ];
                            }
                            break;

                        default:
                            skipped++;
                            return;
                    }

                    if (points.length === 0) {
                        skipped++;
                        return;
                    }

                    newPaths.push({
                        type: shapeType,
                        points: points,
                        strokeWidth: this.widthOptions[widthIndex],
                        colorIndex: colorIndex
                    });
                });

                if (newPaths.length === 0) {
                    this.showStatus('No compatible features found', 'error', this.importButton);
                    return;
                }

                // Ask user: merge or replace
                const shouldMerge = confirm(`Import ${newPaths.length} features.\n\nOK = Merge with existing\nCancel = Replace existing`);

                this.captureUndoSnapshot();

                if (shouldMerge) {
                    this.paths.push(...newPaths);
                } else {
                    this.paths = newPaths;
                }

                this.markPathsMutated();
                this.commitUndoSnapshot();
                this.redrawPaths();
                this.updateUrl();
                this.scheduleAutoSave();

                const msg = skipped > 0
                    ? `Imported ${newPaths.length} features (${skipped} skipped)`
                    : `Imported ${newPaths.length} features`;
                this.showStatus(msg, 'success', this.importButton);
            }

            inferShapeType(geometryType, props) {
                if (props.shape_type) return props.shape_type;
                if (geometryType === 'Point') return 'circle';
                if (geometryType === 'Polygon') return 'rectangle';
                if (props.arrowhead) return 'arrow';
                return 'freehand';
            }

            findClosestColorIndex(hexColor) {
                // Simple color matching - finds closest by RGB distance
                const parseHex = (hex) => {
                    const clean = hex.replace('#', '');
                    return {
                        r: parseInt(clean.substr(0, 2), 16),
                        g: parseInt(clean.substr(2, 2), 16),
                        b: parseInt(clean.substr(4, 2), 16)
                    };
                };

                const target = parseHex(hexColor);
                let bestIndex = 0;
                let bestDistance = Infinity;

                this.colorPalette.forEach((paletteColor, index) => {
                    const c = parseHex(paletteColor);
                    const dist = Math.sqrt(
                        Math.pow(c.r - target.r, 2) +
                        Math.pow(c.g - target.g, 2) +
                        Math.pow(c.b - target.b, 2)
                    );
                    if (dist < bestDistance) {
                        bestDistance = dist;
                        bestIndex = index;
                    }
                });

                return bestIndex;
            }

            redrawPaths() {
                const group = document.getElementById('drawingGroup');
                group.innerHTML = '';
                
                this.paths.forEach(path => {
                    const colorIndex = Math.max(0, Math.min(7, Number.isInteger(path.colorIndex) ? path.colorIndex : 0)) % this.colorPalette.length;
                    const widthIndex = this.getClosestWidthIndex(path.strokeWidth || this.widthOptions[this.currentWidthIndex]);
                    const strokeWidth = this.widthOptions[widthIndex];
                    path.colorIndex = colorIndex;
                    path.strokeWidth = strokeWidth;
                    const pathElement = this.createPathElement(colorIndex, strokeWidth);
                    let pathData = '';

                    switch (path.type) {
                        case 'freehand':
                            pathData = this.latLngsToPathData(path.points);
                            break;
                        case 'circle':
                            if (path.points && path.points.length >= 2) {
                                pathData = this.circlePathFromLatLng(path.points[0], path.points[1]);
                            }
                            break;
                        case 'rectangle':
                            if (path.points && path.points.length >= 2) {
                                pathData = this.rectanglePathFromLatLng(path.points[0], path.points[1]);
                            }
                            break;
                        case 'arrow':
                        case 'line':
                            if (path.points && path.points.length >= 2) {
                                pathData = this.latLngsToPathData(path.points.slice(0, 2));
                            }
                            break;
                    }

                    if (path.type === 'arrow') {
                        pathElement.setAttribute('marker-end', `url(#arrowhead-${colorIndex})`);
                    }

                    if (pathData) {
                        pathElement.setAttribute('d', pathData);
                        group.appendChild(pathElement);
                    }
                });
            }

            async updateUrl() {
                try {
                    const center = this.map.getCenter();
                    const zoom = this.map.getZoom();
                    const drawing = await this.compressDrawing();
                    
                    const params = new URLSearchParams();
                    params.set('l', `${center.lat.toFixed(6)},${center.lng.toFixed(6)}`);
                    params.set('z', zoom.toString());
                    if (drawing) params.set('d', drawing);
                    
                    const newUrl = `${window.location.origin}${window.location.pathname}#${params.toString()}`;
                    history.replaceState(null, '', newUrl);

                    if (this.shareOpen) {
                        const shareUrl = document.getElementById('shareUrl');
                        if (shareUrl) {
                            shareUrl.value = newUrl;
                        }
                        const shareBtn = document.getElementById('shareBtn');
                        if (shareBtn) {
                            shareBtn.classList.add('active');
                            shareBtn.setAttribute('aria-pressed', 'true');
                        }
                    }

                    return newUrl;
                } catch (e) {
                    console.error('Failed to update URL:', e);
                    return undefined;
                }
            }

            loadFromUrl() {
                const hash = window.location.hash.substring(1);
                if (!hash) return;
                
                try {
                    const params = new URLSearchParams(hash);
                    const loc = params.get('l') || '';
                    const [latStr, lngStr] = loc.split(',');
                    let lat = parseFloat(latStr);
                    let lng = parseFloat(lngStr);
                    if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
                        lat = parseFloat(params.get('lat'));
                        lng = parseFloat(params.get('lng'));
                    }
                    const zoomStr = params.get('z') ?? params.get('zoom');
                    const zoom = zoomStr ? parseInt(zoomStr) : undefined;
                    const drawing = params.get('d') || params.get('drawing');
                    
                    if (Number.isFinite(lat) && Number.isFinite(lng) && Number.isFinite(zoom)) {
                        this.map.setView([lat, lng], zoom);
                    } else if (Number.isFinite(lat) && Number.isFinite(lng)) {
                        this.map.setView([lat, lng], this.map.getZoom());
                    }
                    
                    if (drawing) {
                        setTimeout(() => {
                            this.decompressDrawing(drawing);
                        }, 200);
                    }
                } catch (e) {
                    console.error('Failed to load from URL:', e);
                }
            }

            async showShare() {
                this.closeColorPopover();
                this.closeStrokePopover();
                const shareBtn = document.getElementById('shareBtn');
                if (shareBtn) {
                    this.statusAnchor = shareBtn;
                }

                const updated = await this.updateUrl();
                const url = updated || window.location.href;

                // Copy to clipboard directly
                try {
                    await navigator.clipboard.writeText(url);
                    const length = url.length;
                    this.showStatus(`URL copied to clipboard (${length} characters)`, length < 2000 ? 'success' : 'error', shareBtn);
                } catch (err) {
                    this.showStatus('Failed to copy URL to clipboard', 'error', shareBtn);
                }
            }

            showStatus(message, type = '', anchor = null) {
                const status = document.getElementById('status');
                if (!status) return;
                if (this.statusHideTimer) {
                    clearTimeout(this.statusHideTimer);
                    this.statusHideTimer = null;
                }
                status.textContent = message;
                status.className = 'status show';
                if (type) status.classList.add(type);

                status.style.opacity = '0';
                status.style.visibility = 'hidden';
                status.style.removeProperty('top');
                status.style.removeProperty('left');
                status.style.removeProperty('bottom');
                status.style.removeProperty('transform');

                requestAnimationFrame(() => {
                    const isMobile = window.innerWidth <= 768;
                    const controls = document.querySelector('.controls');
                    const shareContainer = document.getElementById('urlContainer');
                    const shareVisible = shareContainer && shareContainer.classList.contains('show');
                    const statusRect = status.getBoundingClientRect();

                    if (isMobile) {
                        let hostRect = null;
                        if (shareVisible) {
                            hostRect = shareContainer.getBoundingClientRect();
                        } else if (controls) {
                            hostRect = controls.getBoundingClientRect();
                        }
                        if (hostRect) {
                            let top = hostRect.top + window.scrollY - statusRect.height - 12;
                            const minTop = window.scrollY + 16;
                            if (top < minTop) {
                                top = minTop;
                            }
                            const left = window.scrollX + window.innerWidth / 2;
                            status.style.top = `${top}px`;
                            status.style.left = `${left}px`;
                            status.style.transform = 'translateX(-50%)';
                            status.style.bottom = 'auto';
                        } else {
                            status.style.left = '50%';
                            status.style.bottom = '96px';
                            status.style.transform = 'translateX(-50%)';
                        }
                    } else {
                        if (controls) {
                            const rect = controls.getBoundingClientRect();
                            const left = rect.left + rect.width / 2 + window.scrollX;
                            const top = rect.bottom + window.scrollY + 12;
                            status.style.top = `${top}px`;
                            status.style.left = `${left}px`;
                            status.style.transform = 'translateX(-50%)';
                            status.style.bottom = 'auto';
                        } else {
                            status.style.left = '50%';
                            status.style.bottom = '80px';
                            status.style.transform = 'translateX(-50%)';
                        }
                    }

                    status.style.visibility = 'visible';
                    status.style.opacity = '1';
                });

                this.statusHideTimer = setTimeout(() => {
                    status.classList.remove('show');
                    status.style.visibility = 'hidden';
                    status.style.opacity = '0';
                }, 3000);
            }
        }

        // Global functions
        function copyUrl() {
            const shareUrl = document.getElementById('shareUrl');
            if (!shareUrl) return;

            const anchor = app && app.shareButton ? app.shareButton : document.getElementById('shareBtn');

            const performCopy = () => {
                shareUrl.select();
                shareUrl.setSelectionRange(0, 99999);
                try {
                    document.execCommand('copy');
                    if (app) {
                        app.showStatus('URL copied to clipboard!', 'success', anchor);
                    }
                } catch (e) {
                    if (app) {
                        app.showStatus('Failed to copy URL', 'error', anchor);
                    }
                }
            };

            if (app) {
                Promise.resolve(app.updateUrl()).finally(performCopy);
            } else {
                performCopy();
            }
        }

        function hideShare() {
            const container = document.getElementById('urlContainer');
            if (container) {
                container.classList.remove('show');
            }
            if (app) {
                app.shareOpen = false;
                app.closeColorPopover();
                app.closeStrokePopover();
                const shareBtn = document.getElementById('shareBtn');
                if (shareBtn) {
                    shareBtn.classList.remove('active');
                    shareBtn.setAttribute('aria-pressed', 'false');
                }
            }
        }

        // Initialize app
        let app;
        window.addEventListener('DOMContentLoaded', () => {
            app = new MapDrawingApp();
        });

        // Handle page visibility for auto-save
        document.addEventListener('visibilitychange', () => {
            if (app && document.visibilityState === 'hidden') {
                app.saveState();
            }
        });

        // Handle page unload
        window.addEventListener('beforeunload', () => {
            if (app) {
                app.stopLocationTracking(true);
                app.removeSearchMarker();
                app.saveState();
            }
        });
    </script>
</body>
</html>
