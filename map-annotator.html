<!DOCTYPE html>
<!--
BSD 2-Clause License
Copyright 2025 Gabriel Nyman
https://github.com/gnyman/mapdraw

Adapted for self-contained use with inline SVG icons.
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Annotate maps with drawings, shapes, and markers, shareable via link">
    <title>Map Drawing & Sharing</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            height: 100vh;
            overflow: hidden;
        }

        #map {
            width: 100%;
            height: 100vh;
            position: relative;
        }

        .drawing-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        .drawing-overlay.drawing-mode {
            pointer-events: all;
        }

        .drawing-overlay.freehand-mode {
            cursor: crosshair;
        }

        .drawing-overlay.line-mode {
            cursor: crosshair;
        }

        .drawing-overlay.circle-mode {
            cursor: crosshair;
        }

        .drawing-overlay.arrow-mode {
            cursor: crosshair;
        }

        .controls {
            position: absolute;
            top: 12px;
            right: 12px;
            left: auto;
            transform: none;
            z-index: 1001;
            background: rgba(20, 20, 20, 0.95);
            border-radius: 12px;
            box-shadow: 0 4px 30px rgba(0,0,0,0.5);
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
            max-width: calc(100% - 32px);
        }


        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toolbar-group + .toolbar-group {
            border-left: 1px solid #444;
            padding-left: 12px;
        }

        .toolbar-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 6px 10px;
            border: 1px solid #555;
            border-radius: 10px;
            background: linear-gradient(180deg, #2a2a2a 0%, #1a1a1a 100%);
            color: #fff;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: background 0.2s, border-color 0.2s, color 0.2s, box-shadow 0.2s;
            white-space: nowrap;
            box-shadow: 0 1px 2px rgba(0,0,0,0.3);
            min-height: 32px;
            text-decoration: none;
        }

        .toolbar-btn:hover {
            background: linear-gradient(180deg, #3a3a3a 0%, #2a2a2a 100%);
            border-color: #ff8c00;
            box-shadow: 0 2px 4px rgba(255, 140, 0, 0.3);
        }

        .toolbar-btn:disabled {
            background: linear-gradient(180deg, #2a2a2a 0%, #1a1a1a 100%);
            border-color: #333;
            color: #666;
            cursor: not-allowed;
            box-shadow: none;
            opacity: 0.5;
        }

        .toolbar-btn.active {
            background: linear-gradient(180deg, rgba(255, 140, 0, 0.3) 0%, rgba(255, 140, 0, 0.1) 100%);
            border-color: #ff8c00;
            color: #ffa500;
            box-shadow: 0 3px 10px rgba(255, 140, 0, 0.4);
        }

        .toolbar-btn .icon {
            width: 18px;
            height: 18px;
            display: block;
        }

        .toolbar-btn .icon img,
        .toolbar-btn .icon svg {
            width: 100%;
            height: 100%;
        }

        .btn-label {
            font-size: 11px;
            letter-spacing: 0.01em;
        }

        .location-btn {
            color: #fff;
        }

        .location-btn.active {
            background: linear-gradient(180deg, rgba(255, 140, 0, 0.4) 0%, rgba(255, 140, 0, 0.2) 100%);
            border-color: #ff8c00;
            color: #ffa500;
            box-shadow: 0 3px 10px rgba(255, 140, 0, 0.5);
        }

        .tool-btn {
            min-width: 32px;
        }

        .stroke-picker {
            position: relative;
        }

        .stroke-visual {
            width: 36px;
            height: 20px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .stroke-visual::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: calc(100% - 8px);
            height: var(--stroke-width, 4px);
            border-radius: 999px;
            background-color: var(--stroke-color, #007AFF);
            transform: translate(-50%, -50%);
        }

        .stroke-popover {
            position: absolute;
            top: 0;
            left: 0;
            background: #1a1a1a;
            border: 1px solid #555;
            border-radius: 10px;
            padding: 10px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 1002;
            min-width: 140px;
        }

        .stroke-option {
            display: flex;
            align-items: center;
            gap: 10px;
            border: 1px solid transparent;
            border-radius: 8px;
            padding: 6px 8px;
            background: transparent;
            font-size: 12px;
            font-weight: 600;
            color: #fff;
            cursor: pointer;
            transition: background 0.2s, border-color 0.2s;
        }

        .stroke-option:hover,
        .stroke-option:focus-visible {
            background: #2a2a2a;
            border-color: #ff8c00;
            outline: none;
        }

        .stroke-option.active {
            border-color: #ff8c00;
            background: rgba(255, 140, 0, 0.2);
        }

        .stroke-option-line {
            width: 40px;
            height: 20px;
            position: relative;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .stroke-option-line::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: calc(100% - 8px);
            height: var(--stroke-width, 4px);
            border-radius: 999px;
            background-color: var(--stroke-color, #007AFF);
            transform: translate(-50%, -50%);
        }

        .color-picker {
            position: relative;
        }

        .color-preview {
            width: auto;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            border: 1px solid #555;
            border-radius: 10px;
            background-color: #2a2a2a;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            color: #fff;
            box-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        .color-preview.active {
            border-color: #ff8c00;
            box-shadow: 0 3px 10px rgba(255, 140, 0, 0.4);
        }

        .color-preview:focus-visible {
            outline: 2px solid #ff8c00;
            outline-offset: 2px;
        }

        .color-swatch {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 1px solid rgba(0,0,0,0.2);
            flex-shrink: 0;
        }

        .color-name {
            font-size: 11px;
        }

        .color-popover {
            position: absolute;
            top: 0;
            left: 0;
            background-color: #1a1a1a;
            border: 1px solid #555;
            border-radius: 10px;
            padding: 12px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.8);
            display: grid;
            grid-template-columns: repeat(4, 24px);
            gap: 10px;
            z-index: 1002;
        }

        .color-option {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
        }

        .color-option.active {
            border-color: #ff8c00;
        }

        .color-option:focus-visible {
            outline: 2px solid #ff8c00;
            outline-offset: 2px;
        }

        .picker-overlay {
            position: fixed;
            inset: 0;
            background: transparent;
            z-index: 1001;
        }


        .url-container {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            z-index: 1001;
            background: #1a1a1a;
            border: 1px solid #555;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.8);
            padding: 12px;
            display: none;
        }

        .url-container.show {
            display: block;
        }

        .url-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }

        .url-input {
            width: 100%;
            padding: 8px;
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 11px;
            margin-bottom: 8px;
            font-family: monospace;
            background: #2a2a2a;
            color: #fff;
        }

        .status {
            position: absolute;
            z-index: 1001;
            background: rgba(20,20,20,0.95);
            color: #fff;
            padding: 8px 12px;
            border-radius: 10px;
            font-size: 12px;
            display: none;
            max-width: 260px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.8);
            pointer-events: none;
            border: 1px solid #555;
        }

        .status.show {
            display: block;
        }

        .status.error {
            background: rgba(255, 59, 48, 0.95);
            border-color: #ff3b30;
        }

        .status.success {
            background: rgba(255, 140, 0, 0.95);
            border-color: #ff8c00;
        }

        .preview-line {
            stroke-width: 2;
            fill: none;
            stroke-dasharray: 5,5;
            pointer-events: none;
        }

        .preview-circle {
            stroke-width: 2;
            fill: none;
            stroke-dasharray: 5,5;
            pointer-events: none;
        }

        .preview-arrow {
            stroke-width: 2;
            fill: none;
            stroke-dasharray: 5,5;
            pointer-events: none;
        }

        label {
            font-size: 11px;
            color: #666;
        }

        @media (max-width: 768px) {
            .controls {
                position: fixed;
                top: auto;
                bottom: 8px;
                left: 8px;
                right: 8px;
                transform: none;
                padding: 6px 8px;
                justify-content: center;
                gap: 8px;
                border-radius: 12px;
            }

            .toolbar-group {
                flex: 1 1 auto;
                justify-content: center;
                gap: 6px;
                border-left: none !important;
                padding-left: 0;
            }

            .btn-label {
                display: none;
            }

            .toolbar-btn {
                padding: 8px;
                min-width: 36px;
            }

            .color-preview {
                padding: 8px;
            }

            .color-name {
                display: none;
            }

            .stroke-popover {
                min-width: 120px;
            }

            .url-container {
                bottom: 72px;
                left: 8px;
                right: 8px;
            }
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <svg class="drawing-overlay" id="drawingOverlay">
        <defs id="arrowMarkers"></defs>
        <g id="drawingGroup"></g>
        <g id="previewGroup"></g>
    </svg>
    
    <div class="controls" role="toolbar" aria-label="Drawing controls">
        <div class="toolbar-group">
            <button id="locationBtn" class="toolbar-btn location-btn" aria-pressed="false" aria-label="Toggle location tracking">
                <span class="icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"/><circle cx="12" cy="12" r="10"/><line x1="12" y1="2" x2="12" y2="6"/><line x1="12" y1="18" x2="12" y2="22"/><line x1="2" y1="12" x2="6" y2="12"/><line x1="18" y1="12" x2="22" y2="12"/></svg>
                </span>
                <span class="btn-label">Locate</span>
            </button>
            <button id="shareBtn" class="toolbar-btn" aria-pressed="false" aria-label="Share drawing">
                <span class="icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                </span>
                <span class="btn-label">Share</span>
            </button>
            <a href="index.html" class="toolbar-btn" title="Back to tools" aria-label="Back to tools">
                <span class="icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="19" y1="12" x2="5" y2="12"/><polyline points="12 19 5 12 12 5"/></svg>
                </span>
                <span class="btn-label">Back</span>
            </a>
        </div>
        <div class="toolbar-group">
            <button id="undoBtn" class="toolbar-btn" title="Undo" aria-label="Undo">
                <span class="icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/></svg>
                </span>
                <span class="btn-label">Undo</span>
            </button>
            <button id="redoBtn" class="toolbar-btn" title="Redo" aria-label="Redo">
                <span class="icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"/><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"/></svg>
                </span>
                <span class="btn-label">Redo</span>
            </button>
            <button id="clearBtn" class="toolbar-btn" title="Clear drawing" aria-label="Clear drawing">
                <span class="icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>
                </span>
                <span class="btn-label">Clear</span>
            </button>
        </div>
        <div class="toolbar-group">
            <button id="freehandBtn" class="toolbar-btn tool-btn active" title="Freehand" aria-label="Freehand tool">
                <span class="icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="M2 2l7.586 7.586"/></svg>
                </span>
                <span class="btn-label">Freehand</span>
            </button>
            <button id="lineBtn" class="toolbar-btn tool-btn" title="Line" aria-label="Line tool">
                <span class="icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="19" x2="19" y2="5"/></svg>
                </span>
                <span class="btn-label">Line</span>
            </button>
            <button id="circleBtn" class="toolbar-btn tool-btn" title="Circle" aria-label="Circle tool">
                <span class="icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/></svg>
                </span>
                <span class="btn-label">Circle</span>
            </button>
            <button id="arrowBtn" class="toolbar-btn tool-btn" title="Arrow" aria-label="Arrow tool">
                <span class="icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12 5 19 12 12 19"/></svg>
                </span>
                <span class="btn-label">Arrow</span>
            </button>
        </div>
        <div class="toolbar-group">
            <div class="stroke-picker">
                <button type="button" class="toolbar-btn" id="strokePickerBtn" aria-haspopup="true" aria-expanded="false" aria-label="Stroke width">
                    <span class="icon stroke-visual" id="strokePickerLine" aria-hidden="true"></span>
                    <span class="btn-label" id="strokePickerLabel">Standard</span>
                </button>
            </div>
            <div class="color-picker">
                <button type="button" class="color-preview" id="colorPreviewBtn" aria-haspopup="true" aria-expanded="false">
                    <span class="color-swatch" id="colorPreviewSwatch"></span>
                    <span class="color-name" id="colorPreviewLabel">Red</span>
                </button>
            </div>
        </div>
    </div>
    
    <div class="url-container" id="urlContainer">
        <input type="text" class="url-input" id="shareUrl" readonly>
        <div class="url-actions">
            <button type="button" class="toolbar-btn" onclick="copyUrl()">Copy</button>
            <button type="button" class="toolbar-btn" onclick="hideShare()">Close</button>
        </div>
    </div>
    
    <div class="status" id="status"></div>

    <!-- Leaflet JS -->
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script src="https://cdn.jsdelivr.net/npm/uzip@0.20201231.0/UZIP.min.js" crossorigin="anonymous"></script>
    
    <script>
        class MapDrawingApp {
            constructor() {
                this.map = null;
                this.drawingMode = false;
                this.currentTool = 'freehand';
                this.currentPath = null;
                this.widthOptions = [2, 4, 6, 10];
                this.widthOptionLabels = ['Fine', 'Standard', 'Bold', 'Heavy'];
                this.currentWidthIndex = 1;
                this.currentStroke = this.widthOptions[this.currentWidthIndex];
                this.paths = [];
                this.undoStack = [];
                this.redoStack = [];
                this.isDrawing = false;
                this.startPoint = null;
                this.previewElement = null;
                this.lastLocation = { lat: 37.7749, lng: -122.4194, zoom: 13 };
                this.autoSaveTimer = null;
                this.pendingUndoSnapshot = null;
                this.didMutatePaths = false;
                this.cachedCompressedDrawing = '';
                this.drawingSerializationDirty = true;
                this.compressInFlight = null;
                this.colorPalette = [
                    '#FF3B30', '#FF9500', '#FFCC00', '#4CD964',
                    '#5AC8FA', '#007AFF', '#5856D6', '#AF52DE',
                    '#FF2D55', '#8E8E93', '#FF6B81', '#2ECC71',
                    '#1ABC9C', '#3498DB', '#9B59B6', '#34495E'
                ];
                this.colorNames = [
                    'Red', 'Orange', 'Yellow', 'Lime',
                    'Sky', 'Blue', 'Indigo', 'Violet',
                    'Pink', 'Gray', 'Coral', 'Emerald',
                    'Teal', 'Azure', 'Purple', 'Slate'
                ];
                this.currentColorIndex = 0;
                this.activeDrawingColorIndex = 0;
                this.pendingShapeColorIndex = null;
                this.colorPreviewBtn = null;
                this.colorPreviewSwatch = null;
                this.colorPreviewLabel = null;
                this.colorPopover = null;
                this.colorOverlay = null;
                this.boundColorPopoverKeyHandler = null;
                this.boundColorPopoverResize = null;
                this.boundColorPopoverScroll = null;
                this.strokePickerBtn = null;
                this.strokePickerLine = null;
                this.strokePickerLabel = null;
                this.strokePopover = null;
                this.strokeOverlay = null;
                this.boundStrokePopoverKeyHandler = null;
                this.boundStrokePopoverResize = null;
                this.boundStrokePopoverScroll = null;
                this.locationMarker = null;
                this.locationAccuracyCircle = null;
                this.locationWatchId = null;
                this.isTrackingLocation = false;
                this.hasCenteredOnLocation = false;
                this.lastLocationUpdate = 0;
                this.shareOpen = false;
                this.statusAnchor = null;
                this.statusHideTimer = null;
                this.locationButton = null;
                this.shareButton = null;
                this.clearButton = null;
                this.undoButton = null;
                this.redoButton = null;
                this.initMarkers();

                this.init();
            }

            init() {
                this.loadLastState();
                this.initMap();
                this.initControls();
                this.initDrawing();
                this.loadFromUrl();
                this.startAutoSave();
            }

            loadLastState() {
                // Try to load from memory (session-based storage)
                // Note: localStorage is not available in Claude.ai artifacts
                try {
                    const saved = window.sessionData || {};
                    if (saved.lastLocation) {
                        this.lastLocation = saved.lastLocation;
                    }
                    if (saved.lastDrawing) {
                        // Will be loaded after map initializes
                        this.savedDrawing = saved.lastDrawing;
                    }
                } catch (e) {
                    console.log('Session storage not available, using defaults');
                }
            }

            saveState() {
                try {
                    window.sessionData = window.sessionData || {};
                    window.sessionData.lastLocation = {
                        lat: this.map.getCenter().lat,
                        lng: this.map.getCenter().lng,
                        zoom: this.map.getZoom()
                    };
                    this.compressDrawing().then(drawing => {
                        window.sessionData.lastDrawing = drawing;
                    }).catch(() => {
                        // Ignore compression errors during auto-save
                    });
                } catch (e) {
                    console.log('Could not save state');
                }
            }

            initMap() {
                // Initialize map with last known location
                this.map = L.map('map').setView([this.lastLocation.lat, this.lastLocation.lng], this.lastLocation.zoom);
                
                // Add OpenStreetMap tiles
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: 'Â© OpenStreetMap contributors'
                }).addTo(this.map);

                // Handle map events
                this.map.on('moveend', () => {
                    this.updateUrl();
                    this.saveState();
                });
                this.map.on('zoomend', () => {
                    this.updateUrl();
                    this.saveState();
                });
                this.map.on('move', () => {
                    this.redrawPaths();
                });
                this.map.on('zoom', () => {
                    this.redrawPaths();
                });

                // Load saved drawing if available
                if (this.savedDrawing) {
                    setTimeout(() => {
                        this.decompressDrawing(this.savedDrawing);
                        delete this.savedDrawing;
                    }, 100);
                }
            }

            initControls() {
                const attachButton = (id, handler) => {
                    const el = document.getElementById(id);
                    if (!el) return null;
                    el.addEventListener('click', (event) => {
                        this.statusAnchor = event.currentTarget;
                        handler(event);
                    });
                    return el;
                };

                // Action buttons
                this.locationButton = attachButton('locationBtn', () => this.goToLocation());
                this.shareButton = attachButton('shareBtn', () => this.showShare());
                this.clearButton = attachButton('clearBtn', () => this.clearDrawing());
                this.undoButton = attachButton('undoBtn', () => this.undo());
                this.redoButton = attachButton('redoBtn', () => this.redo());

                // Tool buttons
                attachButton('freehandBtn', () => this.setTool('freehand'));
                attachButton('lineBtn', () => this.setTool('line'));
                attachButton('circleBtn', () => this.setTool('circle'));
                attachButton('arrowBtn', () => this.setTool('arrow'));

                // Stroke width options
                this.initWidthControls();

                // Color palette
                this.initColorControls();

                if (!this.statusAnchor) {
                    this.statusAnchor = this.shareButton || this.locationButton || this.clearButton;
                }

                this.updateToolButtons();
                this.updateUndoRedoButtons();
                this.updateColorButtons();
                this.updateWidthButtons();
                this.updateLocationButtonState();
            }

            setTool(tool) {
                if (this.currentTool === tool && this.drawingMode) {
                    this.toggleDrawingMode(false);
                    return;
                }

                this.currentTool = tool;
                this.updateToolButtons();

                if (!this.drawingMode) {
                    this.toggleDrawingMode(true);
                }
            }

            updateToolButtons() {
                const buttons = document.querySelectorAll('.tool-btn');
                buttons.forEach(btn => btn.classList.remove('active'));
                
                const activeBtn = document.getElementById(this.currentTool + 'Btn');
                if (activeBtn && this.drawingMode) activeBtn.classList.add('active');

                // Update overlay cursor class
                const overlay = document.getElementById('drawingOverlay');
                overlay.setAttribute('class', 'drawing-overlay');
                if (this.drawingMode) {
                    overlay.classList.add('drawing-mode', this.currentTool + '-mode');
                }
            }

            toggleDrawingMode(enable = null) {
                this.drawingMode = enable !== null ? enable : !this.drawingMode;
                
                const overlay = document.getElementById('drawingOverlay');
                
                if (this.drawingMode) {
                    overlay.classList.add('drawing-mode');
                    this.map.dragging.disable();
                    this.map.scrollWheelZoom.disable();
                    this.map.doubleClickZoom.disable();
                } else {
                    overlay.classList.remove('drawing-mode');
                    this.map.dragging.enable();
                    this.map.scrollWheelZoom.enable();
                    this.map.doubleClickZoom.enable();
                }
                
                this.updateToolButtons();
            }

            initDrawing() {
                const overlay = document.getElementById('drawingOverlay');

                // Mouse events
                overlay.addEventListener('mousedown', (e) => this.handleDrawStart(e));
                overlay.addEventListener('mousemove', (e) => this.handleDrawMove(e));
                overlay.addEventListener('mouseup', (e) => this.handleDrawEnd(e));

                // Touch events
                overlay.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.handleDrawStart(e);
                });
                overlay.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.handleDrawMove(e);
                });
                overlay.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.handleDrawEnd(e);
                });

                // Prevent context menu
                overlay.addEventListener('contextmenu', (e) => e.preventDefault());
            }

            handleDrawStart(event) {
                if (!this.drawingMode) return;

                this.closeStrokePopover();
                this.closeColorPopover();
                
                this.captureUndoSnapshot();
                this.didMutatePaths = false;
                this.redoStack = [];
                this.updateUndoRedoButtons();

                this.activeDrawingColorIndex = this.currentColorIndex;
                this.pendingShapeColorIndex = null;

                this.isDrawing = true;
                this.startPoint = this.getDrawingPoint(event);

                if (this.currentTool === 'freehand') {
                    this.startFreehandPath(this.startPoint, this.activeDrawingColorIndex);
                } else {
                    this.pendingShapeColorIndex = this.activeDrawingColorIndex;
                    this.startShapePath(this.startPoint);
                }
            }

            handleDrawMove(event) {
                if (!this.drawingMode || !this.isDrawing) return;
                
                const point = this.getDrawingPoint(event);

                if (this.currentTool === 'freehand') {
                    this.continueFreehandPath(point);
                } else {
                    this.updateShapePreview(this.startPoint, point);
                }
            }

            handleDrawEnd(event) {
                if (!this.isDrawing) return;
                
                const point = this.getDrawingPoint(event);
                this.isDrawing = false;

                if (this.currentTool === 'freehand') {
                    this.endFreehandPath();
                } else {
                    this.endShapePath(this.startPoint, point);
                }
                
                this.pendingShapeColorIndex = null;
                this.clearPreview();
                this.commitUndoSnapshot();
                this.updateUrl();
                this.scheduleAutoSave();
            }

            getDrawingPoint(event) {
                const pointer = event.touches && event.touches.length
                    ? event.touches[0]
                    : event.changedTouches && event.changedTouches.length
                        ? event.changedTouches[0]
                        : event;
                const rect = this.map.getContainer().getBoundingClientRect();
                const x = pointer.clientX - rect.left;
                const y = pointer.clientY - rect.top;
                const latLng = this.map.containerPointToLatLng([x, y]);
                return {
                    lat: latLng.lat,
                    lng: latLng.lng,
                    x,
                    y
                };
            }

            startFreehandPath(point, colorIndex) {
                this.currentPath = {
                    points: [{ lat: point.lat, lng: point.lng }],
                    strokeWidth: this.currentStroke,
                    type: 'freehand',
                    colorIndex
                };

                const path = this.createPathElement(colorIndex, this.currentStroke);
                path.setAttribute('d', this.latLngsToPathData(this.currentPath.points));

                document.getElementById('drawingGroup').appendChild(path);
                this.currentPath.element = path;
            }

            continueFreehandPath(point) {
                if (!this.currentPath) return;
                
                this.currentPath.points.push({ lat: point.lat, lng: point.lng });
                const pathData = this.latLngsToPathData(this.currentPath.points);
                this.currentPath.element.setAttribute('d', pathData);
            }

            endFreehandPath() {
                if (this.currentPath && this.currentPath.points.length > 1) {
                    this.paths.push({
                        points: this.currentPath.points.map(p => ({ lat: p.lat, lng: p.lng })),
                        strokeWidth: this.currentPath.strokeWidth,
                        type: 'freehand',
                        colorIndex: this.currentPath.colorIndex
                    });
                    this.markPathsMutated();
                }
                this.currentPath = null;
            }

            startShapePath(point) {
                this.pendingShapeColorIndex = this.pendingShapeColorIndex ?? this.currentColorIndex;
            }

            updateShapePreview(startPoint, currentPoint) {
                this.clearPreview();
                
                const preview = document.getElementById('previewGroup');
                let element;
                const startContainer = this.map.latLngToContainerPoint([startPoint.lat, startPoint.lng]);
                const currentContainer = this.map.latLngToContainerPoint([currentPoint.lat, currentPoint.lng]);

                switch (this.currentTool) {
                    case 'line':
                        element = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        element.setAttribute('class', 'preview-line');
                        element.setAttribute('x1', startContainer.x);
                        element.setAttribute('y1', startContainer.y);
                        element.setAttribute('x2', currentContainer.x);
                        element.setAttribute('y2', currentContainer.y);
                        element.setAttribute('stroke-width', this.currentStroke);
                        break;

                    case 'circle':
                        const radius = Math.sqrt(
                            Math.pow(currentContainer.x - startContainer.x, 2) + 
                            Math.pow(currentContainer.y - startContainer.y, 2)
                        );
                        element = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        element.setAttribute('class', 'preview-circle');
                        element.setAttribute('cx', startContainer.x);
                        element.setAttribute('cy', startContainer.y);
                        element.setAttribute('r', radius);
                        element.setAttribute('stroke-width', this.currentStroke);
                        break;

                    case 'arrow':
                        element = this.createArrowElement(startContainer, currentContainer, true, this.activeDrawingColorIndex ?? this.currentColorIndex, this.currentStroke);
                        break;
                }

                if (element) {
                    const color = this.getColorHex(this.activeDrawingColorIndex ?? this.currentColorIndex);
                    element.setAttribute('stroke', color);
                    if (element.tagName === 'circle') {
                        element.setAttribute('fill', 'none');
                    }
                    preview.appendChild(element);
                    this.previewElement = element;
                }
            }

            endShapePath(startPoint, endPoint) {
                const colorIndex = this.pendingShapeColorIndex ?? this.currentColorIndex;
                const points = [
                    { lat: startPoint.lat, lng: startPoint.lng },
                    { lat: endPoint.lat, lng: endPoint.lng }
                ];
                let pathData = null;

                switch (this.currentTool) {
                    case 'line':
                        pathData = this.latLngsToPathData(points);
                        break;

                    case 'circle':
                        pathData = this.circlePathFromLatLng(points[0], points[1]);
                        break;

                    case 'arrow':
                        pathData = this.latLngsToPathData(points);
                        break;
                }

                if (pathData) {
                    const element = this.createPathElement(colorIndex, this.currentStroke);
                    element.setAttribute('d', pathData);

                    if (this.currentTool === 'arrow') {
                        element.setAttribute('marker-end', `url(#arrowhead-${colorIndex})`);
                    }

                    document.getElementById('drawingGroup').appendChild(element);

                    this.paths.push({
                        points: this.currentTool === 'circle'
                            ? [points[0], points[1]]
                            : points,
                        strokeWidth: this.currentStroke,
                        type: this.currentTool,
                        colorIndex
                    });
                    this.markPathsMutated();
                }
            }

            createPathElement(colorIndex = this.currentColorIndex, strokeWidth = this.currentStroke) {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke', this.getColorHex(colorIndex));
                path.setAttribute('stroke-width', strokeWidth);
                path.setAttribute('stroke-linecap', 'round');
                path.setAttribute('stroke-linejoin', 'round');
                return path;
            }

            createArrowElement(start, end, isPreview = false, colorIndex = this.currentColorIndex, strokeWidth = this.currentStroke) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('class', isPreview ? 'preview-arrow' : '');
                line.setAttribute('x1', start.x);
                line.setAttribute('y1', start.y);
                line.setAttribute('x2', end.x);
                line.setAttribute('y2', end.y);
                line.setAttribute('stroke-width', strokeWidth);
                line.setAttribute('stroke', this.getColorHex(colorIndex));
                line.setAttribute('fill', 'none');
                if (!isPreview) {
                    line.setAttribute('marker-end', `url(#arrowhead-${colorIndex})`);
                }
                return line;
            }

            circleToPath(cx, cy, r) {
                return `M${cx-r},${cy} A${r},${r} 0 1,0 ${cx+r},${cy} A${r},${r} 0 1,0 ${cx-r},${cy}`;
            }

            clearPreview() {
                const preview = document.getElementById('previewGroup');
                preview.innerHTML = '';
                this.previewElement = null;
            }

            latLngsToPathData(points) {
                if (!points || points.length === 0) return '';

                const first = this.map.latLngToContainerPoint([points[0].lat, points[0].lng]);
                let d = `M${first.x},${first.y}`;
                for (let i = 1; i < points.length; i++) {
                    const pt = this.map.latLngToContainerPoint([points[i].lat, points[i].lng]);
                    d += ` L${pt.x},${pt.y}`;
                }
                return d;
            }

            circlePathFromLatLng(center, edge) {
                if (!center || !edge) return '';
                const centerPoint = this.map.latLngToContainerPoint([center.lat, center.lng]);
                const edgePoint = this.map.latLngToContainerPoint([edge.lat, edge.lng]);
                const radius = Math.sqrt(
                    Math.pow(edgePoint.x - centerPoint.x, 2) +
                    Math.pow(edgePoint.y - centerPoint.y, 2)
                );
                return this.circleToPath(centerPoint.x, centerPoint.y, radius);
            }

            captureUndoSnapshot() {
                this.pendingUndoSnapshot = JSON.parse(JSON.stringify(this.paths));
            }

            markPathsMutated() {
                this.didMutatePaths = true;
                this.drawingSerializationDirty = true;
                this.cachedCompressedDrawing = '';
                this.compressInFlight = null;
                this.compressionGeneration += 1;
            }

            commitUndoSnapshot() {
                if (this.didMutatePaths && this.pendingUndoSnapshot) {
                    this.undoStack.push(this.pendingUndoSnapshot);
                    if (this.undoStack.length > 20) {
                        this.undoStack.shift();
                    }
                }
                this.pendingUndoSnapshot = null;
                this.didMutatePaths = false;
                this.updateUndoRedoButtons();
            }

            undo() {
                if (this.undoStack.length === 0) return;

                this.redoStack.push(JSON.parse(JSON.stringify(this.paths)));
                this.paths = this.undoStack.pop();
                this.pendingUndoSnapshot = null;
                this.didMutatePaths = false;
                this.drawingSerializationDirty = true;
                this.cachedCompressedDrawing = '';
                this.compressInFlight = null;
                this.compressionGeneration += 1;

                this.redrawPaths();
                this.updateUndoRedoButtons();
                this.updateUrl();
                this.scheduleAutoSave();
            }

            redo() {
                if (this.redoStack.length === 0) return;

                this.undoStack.push(JSON.parse(JSON.stringify(this.paths)));
                this.paths = this.redoStack.pop();
                this.pendingUndoSnapshot = null;
                this.didMutatePaths = false;
                this.drawingSerializationDirty = true;
                this.cachedCompressedDrawing = '';
                this.compressInFlight = null;
                this.compressionGeneration += 1;

                this.redrawPaths();
                this.updateUndoRedoButtons();
                this.updateUrl();
                this.scheduleAutoSave();
            }

            updateUndoRedoButtons() {
                if (this.undoButton) {
                    this.undoButton.disabled = this.undoStack.length === 0;
                }
                if (this.redoButton) {
                    this.redoButton.disabled = this.redoStack.length === 0;
                }
            }

            clearDrawing() {
                if (this.paths.length > 0) {
                    this.captureUndoSnapshot();
                    this.markPathsMutated();
                }
                this.redoStack = [];
                document.getElementById('drawingGroup').innerHTML = '';
                this.paths = [];
                this.commitUndoSnapshot();
                this.updateUrl();
                this.scheduleAutoSave();
                this.showStatus('Drawing cleared', 'success', this.clearButton);
            }

            goToLocation() {
                if (this.isTrackingLocation) {
                    this.stopLocationTracking();
                } else {
                    this.startLocationTracking();
                }
            }

            startLocationTracking() {
                if (!navigator.geolocation) {
                    this.showStatus('Geolocation not supported by this browser', 'error', this.locationButton);
                    return;
                }

                if (this.isTrackingLocation) return;

                this.isTrackingLocation = true;
                this.hasCenteredOnLocation = false;
                this.lastLocationUpdate = 0;
                this.updateLocationButtonState();
                this.showStatus('Tracking your location...', '', this.locationButton);

                const options = {
                    enableHighAccuracy: true,
                    timeout: 15000,
                    maximumAge: 15000
                };

                this.locationWatchId = navigator.geolocation.watchPosition(
                    (position) => this.handleLocationUpdate(position),
                    (error) => {
                        let message = 'Could not get location: ';
                        switch (error.code) {
                            case error.PERMISSION_DENIED: message += 'Location access denied by user'; break;
                            case error.POSITION_UNAVAILABLE: message += 'Location information unavailable'; break;
                            case error.TIMEOUT: message += 'Location request timed out'; break;
                            default: message += 'Unknown error occurred'; break;
                        }
                        this.showStatus(message, 'error', this.locationButton);
                        this.stopLocationTracking(true);
                    },
                    options
                );
            }

            stopLocationTracking(silent = false) {
                if (this.locationWatchId !== null && navigator.geolocation) {
                    navigator.geolocation.clearWatch(this.locationWatchId);
                    this.locationWatchId = null;
                }
                if (this.locationMarker) {
                    this.map.removeLayer(this.locationMarker);
                    this.locationMarker = null;
                }
                if (this.locationAccuracyCircle) {
                    this.map.removeLayer(this.locationAccuracyCircle);
                    this.locationAccuracyCircle = null;
                }
                const wasTracking = this.isTrackingLocation;
                this.isTrackingLocation = false;
                this.hasCenteredOnLocation = false;
                this.lastLocationUpdate = 0;
                this.updateLocationButtonState();
                if (wasTracking && !silent) {
                    this.showStatus('Location tracking disabled', '', this.locationButton);
                }
            }

            handleLocationUpdate(position) {
                if (!this.isTrackingLocation) return;

                const now = Date.now();
                if (now - this.lastLocationUpdate < 3000) {
                    return;
                }
                this.lastLocationUpdate = now;

                const lat = position.coords.latitude;
                const lng = position.coords.longitude;
                const accuracy = position.coords.accuracy || 0;
                const latLng = [lat, lng];

                if (!this.locationMarker) {
                    this.locationMarker = L.circleMarker(latLng, {
                        radius: 6,
                        color: '#007AFF',
                        fillColor: '#007AFF',
                        fillOpacity: 0.9,
                        weight: 2,
                        opacity: 0.9
                    }).addTo(this.map);
                } else {
                    this.locationMarker.setLatLng(latLng);
                }

                if (accuracy > 0) {
                    if (!this.locationAccuracyCircle) {
                        this.locationAccuracyCircle = L.circle(latLng, {
                            radius: Math.max(accuracy, 20),
                            color: '#007AFF',
                            fillColor: '#007AFF',
                            fillOpacity: 0.1,
                            weight: 1,
                            opacity: 0.2
                        }).addTo(this.map);
                    } else {
                        this.locationAccuracyCircle.setLatLng(latLng);
                        this.locationAccuracyCircle.setRadius(Math.max(accuracy, 20));
                    }
                } else if (this.locationAccuracyCircle) {
                    this.locationAccuracyCircle.setLatLng(latLng);
                    this.locationAccuracyCircle.setRadius(20);
                }

                if (!this.hasCenteredOnLocation) {
                    this.map.setView(latLng, Math.max(this.map.getZoom(), 15), { animate: true });
                    this.hasCenteredOnLocation = true;
                    this.showStatus('Location found!', 'success', this.locationButton);
                }
            }

            updateLocationButtonState() {
                if (!this.locationButton) return;
                this.locationButton.classList.toggle('active', this.isTrackingLocation);
                this.locationButton.setAttribute('aria-pressed', String(this.isTrackingLocation));
            }

            startAutoSave() {
                this.stopAutoSave();
                this.autoSaveTimer = setInterval(() => {
                    this.saveState();
                }, 30000);
            }

            stopAutoSave() {
                if (this.autoSaveTimer) {
                    clearInterval(this.autoSaveTimer);
                    this.autoSaveTimer = null;
                }
            }

            scheduleAutoSave() {
                clearTimeout(this.quickSaveTimer);
                this.quickSaveTimer = setTimeout(() => {
                    this.saveState();
                }, 1000);
            }

            getColorHex(index) {
                return this.colorPalette[index] || this.colorPalette[0];
            }

            initColorControls() {
                const previewBtn = document.getElementById('colorPreviewBtn');
                const swatch = document.getElementById('colorPreviewSwatch');
                const label = document.getElementById('colorPreviewLabel');
                if (!previewBtn || !swatch || !label) return;

                this.colorPreviewBtn = previewBtn;
                this.colorPreviewSwatch = swatch;
                this.colorPreviewLabel = label;

                previewBtn.addEventListener('click', (event) => {
                    this.statusAnchor = event.currentTarget;
                    this.toggleColorPopover();
                });
                previewBtn.setAttribute('aria-expanded', 'false');
                previewBtn.setAttribute('aria-haspopup', 'true');

                this.renderColorPreview();
            }

            updateColorButtons() {
                this.renderColorPreview();
                if (this.colorPopover) {
                    const options = this.colorPopover.querySelectorAll('.color-option');
                    options.forEach((option, index) => {
                        option.classList.toggle('active', index === this.currentColorIndex);
                    });
                }
            }

            renderColorPreview() {
                const color = this.getColorHex(this.currentColorIndex);
                const name = this.colorNames[this.currentColorIndex] || 'Color';
                if (this.colorPreviewSwatch) {
                    this.colorPreviewSwatch.style.backgroundColor = color;
                }
                if (this.colorPreviewLabel) {
                    this.colorPreviewLabel.textContent = name;
                }
                if (this.colorPreviewBtn) {
                    this.colorPreviewBtn.setAttribute('aria-label', `Current color ${name}`);
                    this.colorPreviewBtn.setAttribute('title', `Current color ${name}`);
                }
                this.updateWidthPreview();
            }

            toggleColorPopover() {
                if (this.colorPopover) {
                    this.closeColorPopover();
                } else {
                    this.openColorPopover();
                }
            }

            openColorPopover() {
                if (!this.colorPreviewBtn || this.colorPopover) return;

                this.closeStrokePopover();

                const overlay = document.createElement('div');
                overlay.className = 'picker-overlay';
                overlay.addEventListener('click', () => this.closeColorPopover());
                document.body.appendChild(overlay);
                this.colorOverlay = overlay;

                const popover = document.createElement('div');
                popover.className = 'color-popover';
                popover.style.position = 'absolute';
                this.colorPalette.forEach((hex, index) => {
                    const option = document.createElement('button');
                    option.type = 'button';
                    option.className = 'color-option';
                    option.style.background = hex;
                    option.style.backgroundColor = hex;
                    const name = this.colorNames[index] || `Color ${index + 1}`;
                    option.setAttribute('aria-label', `Choose ${name}`);
                    option.setAttribute('title', name);
                    if (index === this.currentColorIndex) {
                        option.classList.add('active');
                    }
                    option.addEventListener('click', () => {
                        this.setColor(index);
                        this.closeColorPopover();
                    });
                    popover.appendChild(option);
                });
                document.body.appendChild(popover);
                this.colorPopover = popover;

                this.positionColorPopover();

                this.boundColorPopoverResize = () => this.positionColorPopover();
                this.boundColorPopoverKeyHandler = (event) => {
                    if (event.key === 'Escape') {
                        event.preventDefault();
                        this.closeColorPopover();
                    }
                };
                window.addEventListener('resize', this.boundColorPopoverResize);
                document.addEventListener('keydown', this.boundColorPopoverKeyHandler, true);
                this.boundColorPopoverScroll = () => this.positionColorPopover();
                window.addEventListener('scroll', this.boundColorPopoverScroll, true);

                this.colorPreviewBtn.classList.add('active');
                this.colorPreviewBtn.setAttribute('aria-expanded', 'true');
            }

            positionColorPopover() {
                if (!this.colorPopover || !this.colorPreviewBtn) return;
                const rect = this.colorPreviewBtn.getBoundingClientRect();
                const popover = this.colorPopover;
                popover.style.visibility = 'hidden';
                popover.style.left = '0px';
                popover.style.top = '0px';
                popover.style.bottom = 'auto';
                const popRect = popover.getBoundingClientRect();
                const viewportTop = window.scrollY + 8;
                const viewportBottom = window.scrollY + window.innerHeight - 8;
                let top = rect.bottom + window.scrollY + 8;
                if (top + popRect.height > viewportBottom) {
                    top = rect.top + window.scrollY - popRect.height - 8;
                    if (top < viewportTop) {
                        top = Math.max(viewportTop, viewportBottom - popRect.height);
                    }
                }
                let left = rect.left + rect.width / 2 + window.scrollX - popRect.width / 2;
                const minLeft = window.scrollX + 8;
                const maxLeft = window.scrollX + window.innerWidth - popRect.width - 8;
                if (left < minLeft) left = minLeft;
                if (left > maxLeft) left = maxLeft;
                popover.style.top = `${top}px`;
                popover.style.left = `${left}px`;
                popover.style.visibility = 'visible';
            }

            closeColorPopover() {
                if (this.colorOverlay) {
                    this.colorOverlay.remove();
                    this.colorOverlay = null;
                }
                if (this.colorPopover) {
                    this.colorPopover.remove();
                    this.colorPopover = null;
                }
                if (this.boundColorPopoverResize) {
                    window.removeEventListener('resize', this.boundColorPopoverResize);
                    this.boundColorPopoverResize = null;
                }
                if (this.boundColorPopoverScroll) {
                    window.removeEventListener('scroll', this.boundColorPopoverScroll, true);
                    this.boundColorPopoverScroll = null;
                }
                if (this.boundColorPopoverKeyHandler) {
                    document.removeEventListener('keydown', this.boundColorPopoverKeyHandler, true);
                    this.boundColorPopoverKeyHandler = null;
                }
                if (this.colorPreviewBtn) {
                    this.colorPreviewBtn.classList.remove('active');
                    this.colorPreviewBtn.setAttribute('aria-expanded', 'false');
                }
            }

            setColor(index) {
                if (index < 0 || index >= this.colorPalette.length) return;
                this.currentColorIndex = index;
                this.activeDrawingColorIndex = this.currentColorIndex;
                this.updateColorButtons();
            }

            initWidthControls() {
                const pickerBtn = document.getElementById('strokePickerBtn');
                const line = document.getElementById('strokePickerLine');
                const label = document.getElementById('strokePickerLabel');

                this.strokePickerBtn = pickerBtn || null;
                this.strokePickerLine = line || null;
                this.strokePickerLabel = label || null;

                if (pickerBtn) {
                    pickerBtn.addEventListener('click', (event) => {
                        this.statusAnchor = event.currentTarget;
                        this.toggleStrokePopover();
                    });
                    pickerBtn.setAttribute('aria-haspopup', 'true');
                    pickerBtn.setAttribute('aria-expanded', 'false');
                }

                this.updateWidthButtons();
            }

            updateWidthButtons() {
                const label = this.widthOptionLabels[this.currentWidthIndex] || `${this.currentStroke}px`;
                if (this.strokePickerLabel) {
                    this.strokePickerLabel.textContent = label;
                }
                if (this.strokePickerBtn) {
                    this.strokePickerBtn.setAttribute('aria-label', `Stroke width ${label}`);
                    this.strokePickerBtn.setAttribute('title', `Stroke width ${label}`);
                    this.strokePickerBtn.setAttribute('aria-expanded', this.strokePopover ? 'true' : 'false');
                }
                this.updateWidthPreview();
            }

            updateWidthPreview() {
                const color = this.getColorHex(this.currentColorIndex);
                if (this.strokePickerLine) {
                    this.strokePickerLine.style.setProperty('--stroke-width', `${this.currentStroke}px`);
                    this.strokePickerLine.style.setProperty('--stroke-color', color);
                }
                if (this.strokePopover) {
                    const lines = this.strokePopover.querySelectorAll('.stroke-option-line');
                    lines.forEach((lineEl) => {
                        const idx = parseInt(lineEl.dataset.index || '0', 10);
                        const widthValue = this.widthOptions[idx] || this.currentStroke;
                        lineEl.style.setProperty('--stroke-width', `${widthValue}px`);
                        lineEl.style.setProperty('--stroke-color', color);
                    });
                    const options = this.strokePopover.querySelectorAll('.stroke-option');
                    options.forEach((option, idx) => {
                        option.classList.toggle('active', idx === this.currentWidthIndex);
                    });
                }
            }

            toggleStrokePopover() {
                if (this.strokePopover) {
                    this.closeStrokePopover();
                } else {
                    this.openStrokePopover();
                }
            }

            openStrokePopover() {
                if (!this.strokePickerBtn || this.strokePopover) return;

                this.closeColorPopover();

                const overlay = document.createElement('div');
                overlay.className = 'picker-overlay';
                overlay.addEventListener('click', () => this.closeStrokePopover());
                document.body.appendChild(overlay);
                this.strokeOverlay = overlay;

                const popover = document.createElement('div');
                popover.className = 'stroke-popover';
                this.widthOptions.forEach((value, index) => {
                    const option = document.createElement('button');
                    option.type = 'button';
                    option.className = 'stroke-option';
                    const name = this.widthOptionLabels[index] || `${value}px`;
                    option.setAttribute('aria-label', `Select ${name} stroke`);
                    option.setAttribute('title', `${name} stroke`);
                    if (index === this.currentWidthIndex) {
                        option.classList.add('active');
                    }

                    const line = document.createElement('span');
                    line.className = 'stroke-option-line';
                    line.dataset.index = String(index);
                    line.style.setProperty('--stroke-width', `${value}px`);
                    line.style.setProperty('--stroke-color', this.getColorHex(this.currentColorIndex));
                    line.setAttribute('aria-hidden', 'true');

                    const text = document.createElement('span');
                    text.textContent = name;

                    option.appendChild(line);
                    option.appendChild(text);

                    option.addEventListener('click', () => {
                        this.setStrokeWidth(index);
                        this.closeStrokePopover();
                    });

                    popover.appendChild(option);
                });
                document.body.appendChild(popover);
                this.strokePopover = popover;

                this.positionStrokePopover();

                this.boundStrokePopoverResize = () => this.positionStrokePopover();
                window.addEventListener('resize', this.boundStrokePopoverResize);

                this.boundStrokePopoverScroll = () => this.positionStrokePopover();
                window.addEventListener('scroll', this.boundStrokePopoverScroll, true);

                this.boundStrokePopoverKeyHandler = (event) => {
                    if (event.key === 'Escape') {
                        event.stopPropagation();
                        this.closeStrokePopover();
                    }
                };
                document.addEventListener('keydown', this.boundStrokePopoverKeyHandler, true);

                this.strokePickerBtn.classList.add('active');
                this.strokePickerBtn.setAttribute('aria-expanded', 'true');
            }

            positionStrokePopover() {
                if (!this.strokePopover || !this.strokePickerBtn) return;

                const rect = this.strokePickerBtn.getBoundingClientRect();
                const popover = this.strokePopover;
                popover.style.visibility = 'hidden';
                popover.style.left = '0px';
                popover.style.top = '0px';
                popover.style.bottom = 'auto';
                const popoverRect = popover.getBoundingClientRect();
                const viewportTop = window.scrollY + 8;
                const viewportBottom = window.scrollY + window.innerHeight - 8;
                let top = rect.bottom + window.scrollY + 8;
                if (top + popoverRect.height > viewportBottom) {
                    top = rect.top + window.scrollY - popoverRect.height - 8;
                    if (top < viewportTop) {
                        top = Math.max(viewportTop, viewportBottom - popoverRect.height);
                    }
                }
                let left = rect.left + rect.width / 2 + window.scrollX - popoverRect.width / 2;
                const minLeft = window.scrollX + 8;
                const maxLeft = window.scrollX + window.innerWidth - popoverRect.width - 8;
                if (left < minLeft) left = minLeft;
                if (left > maxLeft) left = maxLeft;
                popover.style.top = `${top}px`;
                popover.style.left = `${left}px`;
                popover.style.visibility = 'visible';
            }

            closeStrokePopover() {
                if (this.strokeOverlay) {
                    this.strokeOverlay.remove();
                    this.strokeOverlay = null;
                }
                if (this.strokePopover) {
                    this.strokePopover.remove();
                    this.strokePopover = null;
                }
                if (this.boundStrokePopoverResize) {
                    window.removeEventListener('resize', this.boundStrokePopoverResize);
                    this.boundStrokePopoverResize = null;
                }
                if (this.boundStrokePopoverScroll) {
                    window.removeEventListener('scroll', this.boundStrokePopoverScroll, true);
                    this.boundStrokePopoverScroll = null;
                }
                if (this.boundStrokePopoverKeyHandler) {
                    document.removeEventListener('keydown', this.boundStrokePopoverKeyHandler, true);
                    this.boundStrokePopoverKeyHandler = null;
                }
                if (this.strokePickerBtn) {
                    this.strokePickerBtn.classList.remove('active');
                    this.strokePickerBtn.setAttribute('aria-expanded', 'false');
                }
            }

            setStrokeWidth(index) {
                if (index < 0 || index >= this.widthOptions.length) return;
                this.currentWidthIndex = index;
                this.currentStroke = this.widthOptions[index];
                if (this.strokePopover) {
                    this.closeStrokePopover();
                }
                this.updateWidthButtons();
            }

            initMarkers() {
                const defs = document.getElementById('arrowMarkers');
                if (!defs) return;

                defs.innerHTML = '';
                this.colorPalette.forEach((color, index) => {
                    const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                    marker.setAttribute('id', `arrowhead-${index}`);
                    marker.setAttribute('markerWidth', '10');
                    marker.setAttribute('markerHeight', '7');
                    marker.setAttribute('refX', '9');
                    marker.setAttribute('refY', '3.5');
                    marker.setAttribute('orient', 'auto');
                    marker.setAttribute('markerUnits', 'strokeWidth');

                    const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    polygon.setAttribute('points', '0 0, 10 3.5, 0 7');
                    polygon.setAttribute('fill', color);
                    marker.appendChild(polygon);

                    defs.appendChild(marker);
                });
            }

            writeVarUint(target, value) {
                let v = value >>> 0;
                while (v >= 0x80) {
                    target.push((v & 0x7f) | 0x80);
                    v >>>= 7;
                }
                target.push(v & 0x7f);
            }

            writeVarInt(target, value) {
                let zigzag = ((value << 1) ^ (value >> 31)) >>> 0;
                while (zigzag >= 0x80) {
                    target.push((zigzag & 0x7f) | 0x80);
                    zigzag >>>= 7;
                }
                target.push(zigzag & 0x7f);
            }

            readVarUint(bytes, cursor) {
                let result = 0;
                let shift = 0;
                while (true) {
                    if (cursor.index >= bytes.length || shift > 35) {
                        throw new Error('Corrupt drawing payload');
                    }
                    const byte = bytes[cursor.index++];
                    result |= (byte & 0x7f) << shift;
                    if ((byte & 0x80) === 0) {
                        return result >>> 0;
                    }
                    shift += 7;
                }
            }

            readVarInt(bytes, cursor) {
                const raw = this.readVarUint(bytes, cursor);
                const value = (raw >>> 1) ^ -(raw & 1);
                return value | 0;
            }

            toUrlSafeBase64(bytes) {
                let binary = '';
                const chunkSize = 0x8000;
                for (let i = 0; i < bytes.length; i += chunkSize) {
                    const chunk = bytes.subarray(i, i + chunkSize);
                    binary += String.fromCharCode.apply(null, chunk);
                }
                return btoa(binary).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
            }

            fromUrlSafeBase64(str) {
                const base64 = str.replace(/-/g, '+').replace(/_/g, '/');
                const padded = base64 + '='.repeat((4 - base64.length % 4) % 4);
                const binary = atob(padded);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                }
                return bytes;
            }

            normalizePathPoints(rawPoints, requireTwoPoints = false) {
                const normalized = [];
                let lastLat = null;
                let lastLng = null;

                (rawPoints || []).forEach(point => {
                    if (!Number.isFinite(point.lat) || !Number.isFinite(point.lng)) return;
                    const latInt = Math.round(point.lat * 1e6);
                    const lngInt = Math.round(point.lng * 1e6);
                    if (normalized.length === 0 || latInt !== lastLat || lngInt !== lastLng) {
                        normalized.push({ lat: latInt, lng: lngInt });
                        lastLat = latInt;
                        lastLng = lngInt;
                    }
                });

                if (requireTwoPoints && normalized.length < 2) {
                    return [];
                }

                return normalized;
            }

            getClosestWidthIndex(value) {
                let bestIndex = 0;
                let bestDiff = Number.POSITIVE_INFINITY;
                this.widthOptions.forEach((width, index) => {
                    const diff = Math.abs(width - value);
                    if (diff < bestDiff) {
                        bestDiff = diff;
                        bestIndex = index;
                    }
                });
                return bestIndex;
            }

            encodePathsToBinary() {
                const typeToCode = { freehand: 0, line: 1, circle: 2, arrow: 3 };
                const prepared = [];

                this.paths.forEach(path => {
                    const requiresTwoPoints = path.type === 'circle' || path.type === 'line' || path.type === 'arrow';
                    const normalized = this.normalizePathPoints(path.points, requiresTwoPoints);
                    if (normalized.length === 0) return;

                    const colorIndex = Math.max(0, Math.min(15, Number.isInteger(path.colorIndex) ? path.colorIndex : 0)) % this.colorPalette.length;
                    const widthIndex = this.getClosestWidthIndex(path.strokeWidth || this.widthOptions[this.currentWidthIndex]);
                    const snappedWidth = this.widthOptions[widthIndex];
                    const typeCode = typeToCode[path.type] ?? typeToCode.freehand;

                    path.colorIndex = colorIndex;
                    path.strokeWidth = snappedWidth;

                    prepared.push({
                        typeCode,
                        widthIndex,
                        colorIndex,
                        points: normalized
                    });
                });

                const bytes = [];
                bytes.push(2); // version
                this.writeVarUint(bytes, prepared.length);

                prepared.forEach(path => {
                    const meta = ((path.typeCode & 0x03) << 6) | ((path.widthIndex & 0x03) << 4) | (path.colorIndex & 0x0f);
                    bytes.push(meta & 0xff);
                    this.writeVarUint(bytes, path.points.length);

                    let prevLat = 0;
                    let prevLng = 0;
                    path.points.forEach((point, index) => {
                        const lat = point.lat | 0;
                        const lng = point.lng | 0;
                        if (index === 0) {
                            this.writeVarInt(bytes, lat);
                            this.writeVarInt(bytes, lng);
                        } else {
                            this.writeVarInt(bytes, lat - prevLat);
                            this.writeVarInt(bytes, lng - prevLng);
                        }
                        prevLat = lat;
                        prevLng = lng;
                    });
                });

                return new Uint8Array(bytes);
            }

            decodePathsFromBinary(bytes) {
                if (!bytes || bytes.length < 2) {
                    throw new Error('Corrupt drawing payload');
                }

                const cursor = { index: 0 };
                const version = bytes[cursor.index++];
                if (version !== 2) {
                    throw new Error('Unsupported drawing format');
                }

                const pathCount = this.readVarUint(bytes, cursor);
                const codeToType = ['freehand', 'line', 'circle', 'arrow'];
                const paths = [];

                for (let i = 0; i < pathCount; i++) {
                    if (cursor.index >= bytes.length) {
                        throw new Error('Corrupt drawing payload');
                    }

                    const meta = bytes[cursor.index++];
                    const typeCode = (meta >> 6) & 0x03;
                    const widthIndex = (meta >> 4) & 0x03;
                    const colorIndex = meta & 0x0f;

                    const pointCount = this.readVarUint(bytes, cursor);
                    const points = [];
                    let lat = 0;
                    let lng = 0;
                    for (let p = 0; p < pointCount; p++) {
                        const deltaLat = this.readVarInt(bytes, cursor);
                        const deltaLng = this.readVarInt(bytes, cursor);
                        if (p === 0) {
                            lat = deltaLat;
                            lng = deltaLng;
                        } else {
                            lat += deltaLat;
                            lng += deltaLng;
                        }
                        points.push({ lat: lat / 1e6, lng: lng / 1e6 });
                    }

                    const strokeWidth = this.widthOptions[widthIndex] ?? this.widthOptions[0];

                    paths.push({
                        type: codeToType[typeCode] || 'freehand',
                        strokeWidth,
                        colorIndex: colorIndex % this.colorPalette.length,
                        points
                    });
                }

                return paths;
            }

            compressDrawing() {
                if (this.paths.length === 0) {
                    this.cachedCompressedDrawing = '';
                    this.drawingSerializationDirty = false;
                    this.compressInFlight = null;
                    return Promise.resolve('');
                }

                if (!this.drawingSerializationDirty && this.cachedCompressedDrawing && !this.compressInFlight) {
                    return Promise.resolve(this.cachedCompressedDrawing);
                }

                if (this.compressInFlight) {
                    return this.compressInFlight;
                }

                if (!window.UZIP || typeof window.UZIP.deflateRaw !== 'function') {
                    return Promise.reject(new Error('UZIP library unavailable'));
                }

                const targetGeneration = this.compressionGeneration;

                this.compressInFlight = new Promise((resolve, reject) => {
                    try {
                        const binary = this.encodePathsToBinary();
                        const compressed = window.UZIP.deflateRaw(binary);
                        const compressedBytes = compressed instanceof Uint8Array ? compressed : new Uint8Array(compressed);
                        const encoded = this.toUrlSafeBase64(compressedBytes);

                        if (this.compressionGeneration === targetGeneration) {
                            this.cachedCompressedDrawing = encoded;
                            this.drawingSerializationDirty = false;
                        }

                        resolve(encoded);
                    } catch (error) {
                        reject(error);
                    }
                }).finally(() => {
                    this.compressInFlight = null;
                });

                return this.compressInFlight;
            }

            decompressDrawing(encoded) {
                if (!encoded) return;

                if (!window.UZIP || typeof window.UZIP.inflateRaw !== 'function') {
                    console.error('UZIP library unavailable');
                    this.showStatus('Failed to load drawing', 'error', this.shareButton);
                    return;
                }

                try {
                    this.initMarkers();
                    const compressedBytes = this.fromUrlSafeBase64(encoded);
                    const inflated = window.UZIP.inflateRaw(compressedBytes);
                    const binary = inflated instanceof Uint8Array ? inflated : new Uint8Array(inflated);
                    const paths = this.decodePathsFromBinary(binary);

                    this.paths = paths;
                    this.undoStack = [];
                    this.redoStack = [];
                    this.pendingUndoSnapshot = null;
                    this.didMutatePaths = false;
                    this.drawingSerializationDirty = false;
                    this.cachedCompressedDrawing = encoded;
                    this.compressInFlight = null;
                    this.compressionGeneration += 1;
                    this.pendingShapeColorIndex = null;

                    this.redrawPaths();
                    this.updateUndoRedoButtons();
                    this.updateToolButtons();
                    this.updateColorButtons();
                    this.updateWidthButtons();
                    this.showStatus('Drawing loaded', 'success', this.shareButton);
                } catch (error) {
                    console.error('Failed to decompress drawing:', error);
                    this.showStatus('Failed to load drawing', 'error', this.shareButton);
                }
            }


            redrawPaths() {
                const group = document.getElementById('drawingGroup');
                group.innerHTML = '';
                
                this.paths.forEach(path => {
                    const colorIndex = Math.max(0, Math.min(15, Number.isInteger(path.colorIndex) ? path.colorIndex : 0)) % this.colorPalette.length;
                    const widthIndex = this.getClosestWidthIndex(path.strokeWidth || this.widthOptions[this.currentWidthIndex]);
                    const strokeWidth = this.widthOptions[widthIndex];
                    path.colorIndex = colorIndex;
                    path.strokeWidth = strokeWidth;
                    const pathElement = this.createPathElement(colorIndex, strokeWidth);
                    let pathData = '';

                    switch (path.type) {
                        case 'freehand':
                            pathData = this.latLngsToPathData(path.points);
                            break;
                        case 'circle':
                            if (path.points && path.points.length >= 2) {
                                pathData = this.circlePathFromLatLng(path.points[0], path.points[1]);
                            }
                            break;
                        case 'arrow':
                        case 'line':
                            if (path.points && path.points.length >= 2) {
                                pathData = this.latLngsToPathData(path.points.slice(0, 2));
                            }
                            break;
                    }

                    if (path.type === 'arrow') {
                        pathElement.setAttribute('marker-end', `url(#arrowhead-${colorIndex})`);
                    }

                    if (pathData) {
                        pathElement.setAttribute('d', pathData);
                        group.appendChild(pathElement);
                    }
                });
            }

            async updateUrl() {
                try {
                    const center = this.map.getCenter();
                    const zoom = this.map.getZoom();
                    const drawing = await this.compressDrawing();
                    
                    const params = new URLSearchParams();
                    params.set('l', `${center.lat.toFixed(6)},${center.lng.toFixed(6)}`);
                    params.set('z', zoom.toString());
                    if (drawing) params.set('d', drawing);
                    
                    const newUrl = `${window.location.origin}${window.location.pathname}#${params.toString()}`;
                    history.replaceState(null, '', newUrl);

                    if (this.shareOpen) {
                        const shareUrl = document.getElementById('shareUrl');
                        if (shareUrl) {
                            shareUrl.value = newUrl;
                        }
                        const shareBtn = document.getElementById('shareBtn');
                        if (shareBtn) {
                            shareBtn.classList.add('active');
                            shareBtn.setAttribute('aria-pressed', 'true');
                        }
                    }

                    return newUrl;
                } catch (e) {
                    console.error('Failed to update URL:', e);
                    return undefined;
                }
            }

            loadFromUrl() {
                const hash = window.location.hash.substring(1);
                if (!hash) return;
                
                try {
                    const params = new URLSearchParams(hash);
                    const loc = params.get('l') || '';
                    const [latStr, lngStr] = loc.split(',');
                    let lat = parseFloat(latStr);
                    let lng = parseFloat(lngStr);
                    if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
                        lat = parseFloat(params.get('lat'));
                        lng = parseFloat(params.get('lng'));
                    }
                    const zoomStr = params.get('z') ?? params.get('zoom');
                    const zoom = zoomStr ? parseInt(zoomStr) : undefined;
                    const drawing = params.get('d') || params.get('drawing');
                    
                    if (Number.isFinite(lat) && Number.isFinite(lng) && Number.isFinite(zoom)) {
                        this.map.setView([lat, lng], zoom);
                    } else if (Number.isFinite(lat) && Number.isFinite(lng)) {
                        this.map.setView([lat, lng], this.map.getZoom());
                    }
                    
                    if (drawing) {
                        setTimeout(() => {
                            this.decompressDrawing(drawing);
                        }, 200);
                    }
                } catch (e) {
                    console.error('Failed to load from URL:', e);
                }
            }

            async showShare() {
                const urlContainer = document.getElementById('urlContainer');
                const shareUrl = document.getElementById('shareUrl');
                this.shareOpen = true;
                this.closeColorPopover();
                this.closeStrokePopover();
                const shareBtn = document.getElementById('shareBtn');
                if (shareBtn) {
                    this.statusAnchor = shareBtn;
                }
                if (shareBtn) {
                    shareBtn.classList.add('active');
                    shareBtn.setAttribute('aria-pressed', 'true');
                }

                const updated = await this.updateUrl();
                const url = updated || window.location.href;
                if (shareUrl) {
                    shareUrl.value = url;
                }
                if (urlContainer) {
                    urlContainer.classList.add('show');
                }
                
                // Show URL length info
                const length = url.length;
                this.showStatus(`Share URL generated (${length} characters)`, length < 2000 ? 'success' : 'error', shareBtn);
            }

            showStatus(message, type = '', anchor = null) {
                const status = document.getElementById('status');
                if (!status) return;
                if (this.statusHideTimer) {
                    clearTimeout(this.statusHideTimer);
                    this.statusHideTimer = null;
                }
                status.textContent = message;
                status.className = 'status show';
                if (type) status.classList.add(type);

                status.style.opacity = '0';
                status.style.visibility = 'hidden';
                status.style.removeProperty('top');
                status.style.removeProperty('left');
                status.style.removeProperty('bottom');
                status.style.removeProperty('transform');

                requestAnimationFrame(() => {
                    const isMobile = window.innerWidth <= 768;
                    const controls = document.querySelector('.controls');
                    const shareContainer = document.getElementById('urlContainer');
                    const shareVisible = shareContainer && shareContainer.classList.contains('show');
                    const statusRect = status.getBoundingClientRect();

                    if (isMobile) {
                        let hostRect = null;
                        if (shareVisible) {
                            hostRect = shareContainer.getBoundingClientRect();
                        } else if (controls) {
                            hostRect = controls.getBoundingClientRect();
                        }
                        if (hostRect) {
                            let top = hostRect.top + window.scrollY - statusRect.height - 12;
                            const minTop = window.scrollY + 16;
                            if (top < minTop) {
                                top = minTop;
                            }
                            const left = window.scrollX + window.innerWidth / 2;
                            status.style.top = `${top}px`;
                            status.style.left = `${left}px`;
                            status.style.transform = 'translateX(-50%)';
                            status.style.bottom = 'auto';
                        } else {
                            status.style.left = '50%';
                            status.style.bottom = '96px';
                            status.style.transform = 'translateX(-50%)';
                        }
                    } else {
                        if (controls) {
                            const rect = controls.getBoundingClientRect();
                            const left = rect.left + rect.width / 2 + window.scrollX;
                            const top = rect.bottom + window.scrollY + 12;
                            status.style.top = `${top}px`;
                            status.style.left = `${left}px`;
                            status.style.transform = 'translateX(-50%)';
                            status.style.bottom = 'auto';
                        } else {
                            status.style.left = '50%';
                            status.style.bottom = '80px';
                            status.style.transform = 'translateX(-50%)';
                        }
                    }

                    status.style.visibility = 'visible';
                    status.style.opacity = '1';
                });

                this.statusHideTimer = setTimeout(() => {
                    status.classList.remove('show');
                    status.style.visibility = 'hidden';
                    status.style.opacity = '0';
                }, 3000);
            }
        }

        // Global functions
        function copyUrl() {
            const shareUrl = document.getElementById('shareUrl');
            if (!shareUrl) return;

            const anchor = app && app.shareButton ? app.shareButton : document.getElementById('shareBtn');

            const performCopy = () => {
                shareUrl.select();
                shareUrl.setSelectionRange(0, 99999);
                try {
                    document.execCommand('copy');
                    if (app) {
                        app.showStatus('URL copied to clipboard!', 'success', anchor);
                    }
                } catch (e) {
                    if (app) {
                        app.showStatus('Failed to copy URL', 'error', anchor);
                    }
                }
            };

            if (app) {
                Promise.resolve(app.updateUrl()).finally(performCopy);
            } else {
                performCopy();
            }
        }

        function hideShare() {
            const container = document.getElementById('urlContainer');
            if (container) {
                container.classList.remove('show');
            }
            if (app) {
                app.shareOpen = false;
                app.closeColorPopover();
                app.closeStrokePopover();
                const shareBtn = document.getElementById('shareBtn');
                if (shareBtn) {
                    shareBtn.classList.remove('active');
                    shareBtn.setAttribute('aria-pressed', 'false');
                }
            }
        }

        // Initialize app
        let app;
        window.addEventListener('DOMContentLoaded', () => {
            app = new MapDrawingApp();
        });

        // Handle page visibility for auto-save
        document.addEventListener('visibilitychange', () => {
            if (app && document.visibilityState === 'hidden') {
                app.saveState();
            }
        });

        // Handle page unload
        window.addEventListener('beforeunload', () => {
            if (app) {
                app.stopLocationTracking(true);
                app.saveState();
            }
        });
    </script>
</body>
</html>
