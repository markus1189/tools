<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Map Draw is an interactive map drawing and annotation tool for creating, editing, and sharing custom maps.">
    <title>Map Draw</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            height: 100vh;
            overflow: hidden;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        /* Drawing overlay */
        #drawingOverlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 500;
        }

        #drawingOverlay.drawing {
            pointer-events: auto;
        }

        #drawingOverlay.drawing {
            cursor: crosshair;
        }

        #drawingOverlay.drawing.select-mode {
            cursor: move;
        }

        #drawingOverlay.drawing.eraser-mode {
            cursor: not-allowed;
        }

        /* Toolbar */
        .toolbar {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            padding: 0.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            z-index: 1000;
        }

        .tool-btn {
            width: 40px;
            height: 40px;
            border: none;
            background: white;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .tool-btn svg {
            width: 20px;
            height: 20px;
            stroke: #333;
            fill: none;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .tool-btn:hover {
            background: #f0f0f0;
        }

        .tool-btn.active {
            background: #2563eb;
        }

        .tool-btn.active svg {
            stroke: white;
        }

        .tool-separator {
            height: 1px;
            background: #e0e0e0;
            margin: 0.25rem 0;
        }

        /* Color picker */
        .color-picker {
            position: absolute;
            top: 1rem;
            right: 5rem;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            padding: 0.75rem;
            display: none;
            z-index: 1000;
        }

        .color-picker.show {
            display: block;
        }

        .color-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
        }

        .color-btn {
            width: 32px;
            height: 32px;
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.1s;
        }

        .color-btn:hover {
            transform: scale(1.1);
        }

        .color-btn.active {
            border-color: #333;
            box-shadow: 0 0 0 2px white, 0 0 0 4px #2563eb;
        }

        /* Stroke picker */
        .stroke-picker {
            position: absolute;
            top: 1rem;
            right: 5rem;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            padding: 0.75rem;
            display: none;
            flex-direction: column;
            gap: 0.5rem;
            z-index: 1000;
        }

        .stroke-picker.show {
            display: flex;
        }

        .stroke-option {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .stroke-option:hover {
            background: #f0f0f0;
        }

        .stroke-option.active {
            background: #e3f2fd;
        }

        .stroke-preview {
            width: 60px;
            height: 20px;
            display: flex;
            align-items: center;
        }

        .stroke-line {
            width: 100%;
            background: #333;
            border-radius: 2px;
        }

        .stroke-label {
            font-size: 0.875rem;
            color: #666;
        }

        /* Share panel */
        .share-panel {
            position: absolute;
            bottom: 1rem;
            left: 1rem;
            right: 1rem;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            padding: 1rem;
            display: flex;
            gap: 0.75rem;
            align-items: center;
            z-index: 1000;
        }

        .share-label {
            font-size: 0.875rem;
            font-weight: 500;
            color: #666;
            white-space: nowrap;
        }

        .share-input {
            flex: 1;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.75rem;
        }

        .share-btn {
            padding: 0.5rem 1rem;
            background: #2563eb;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            white-space: nowrap;
            transition: background 0.2s;
        }

        .share-btn:hover {
            background: #1d4ed8;
        }

        .share-btn.copied {
            background: #10b981;
        }

        /* Location controls */
        .location-controls {
            position: absolute;
            top: 1rem;
            left: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            z-index: 1000;
        }

        .location-btn {
            width: 40px;
            height: 40px;
            background: white;
            border: none;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            text-decoration: none;
        }

        .location-btn svg {
            width: 20px;
            height: 20px;
            stroke: #333;
            fill: none;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .location-btn:hover {
            background: #f0f0f0;
        }

        .location-btn.active {
            background: #2563eb;
        }

        .location-btn.active svg {
            stroke: white;
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .toolbar {
                flex-direction: row;
                top: auto;
                bottom: 5rem;
                right: 0.5rem;
                left: 0.5rem;
            }

            .color-picker, .stroke-picker {
                top: auto;
                bottom: 10rem;
                right: 0.5rem;
            }

            .share-panel {
                flex-wrap: wrap;
            }
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <svg id="drawingOverlay"></svg>

    <!-- Location controls -->
    <div class="location-controls" role="navigation" aria-label="Map navigation controls">
        <button class="location-btn" id="locateBtn" title="Locate me">
            <svg viewBox="0 0 24 24">
                <circle cx="12" cy="12" r="3"/>
                <circle cx="12" cy="12" r="10"/>
                <line x1="12" y1="2" x2="12" y2="6"/>
                <line x1="12" y1="18" x2="12" y2="22"/>
                <line x1="2" y1="12" x2="6" y2="12"/>
                <line x1="18" y1="12" x2="22" y2="12"/>
            </svg>
        </button>
        <a href="index.html" class="location-btn" title="Back to tools" aria-label="Back to tools">
            <svg viewBox="0 0 24 24">
                <line x1="19" y1="12" x2="5" y2="12"/>
                <polyline points="12 19 5 12 12 5"/>
            </svg>
        </a>
    </div>

    <!-- Toolbar -->
    <div class="toolbar">
        <button class="tool-btn" id="panBtn" title="Pan/Move Map">
            <svg viewBox="0 0 24 24">
                <path d="M12 2v7.5M12 14.5V22M2 12h7.5M14.5 12H22"/>
                <circle cx="12" cy="12" r="3"/>
            </svg>
        </button>
        <button class="tool-btn" id="freehandBtn" title="Freehand">
            <svg viewBox="0 0 24 24">
                <path d="M12 19l7-7 3 3-7 7-3-3z"/>
                <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/>
                <path d="M2 2l7.586 7.586"/>
            </svg>
        </button>
        <button class="tool-btn" id="lineBtn" title="Line">
            <svg viewBox="0 0 24 24">
                <line x1="5" y1="19" x2="19" y2="5"/>
            </svg>
        </button>
        <button class="tool-btn" id="circleBtn" title="Circle">
            <svg viewBox="0 0 24 24">
                <circle cx="12" cy="12" r="10"/>
            </svg>
        </button>
        <button class="tool-btn" id="arrowBtn" title="Arrow">
            <svg viewBox="0 0 24 24">
                <line x1="5" y1="12" x2="19" y2="12"/>
                <polyline points="12 5 19 12 12 19"/>
            </svg>
        </button>
        <button class="tool-btn" id="selectBtn" title="Select/Move">
            <svg viewBox="0 0 24 24">
                <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/>
            </svg>
        </button>
        <button class="tool-btn" id="eraserBtn" title="Eraser">
            <svg viewBox="0 0 24 24">
                <path d="M20 20H7L3 16l10-10 8 8-1 6z"/>
                <path d="M16 6l4 4"/>
            </svg>
        </button>
        <div class="tool-separator"></div>
        <button class="tool-btn" id="colorBtn" title="Color">
            <svg viewBox="0 0 24 24">
                <path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"/>
            </svg>
        </button>
        <button class="tool-btn" id="strokeBtn" title="Stroke width">
            <svg viewBox="0 0 24 24">
                <line x1="4" y1="6" x2="20" y2="6"/>
                <line x1="4" y1="12" x2="20" y2="12" stroke-width="3"/>
                <line x1="4" y1="18" x2="20" y2="18" stroke-width="4"/>
            </svg>
        </button>
        <div class="tool-separator"></div>
        <button class="tool-btn" id="undoBtn" title="Undo">
            <svg viewBox="0 0 24 24">
                <polyline points="1 4 1 10 7 10"/>
                <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/>
            </svg>
        </button>
        <button class="tool-btn" id="redoBtn" title="Redo">
            <svg viewBox="0 0 24 24">
                <polyline points="23 4 23 10 17 10"/>
                <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"/>
            </svg>
        </button>
        <button class="tool-btn" id="clearBtn" title="Clear all">
            <svg viewBox="0 0 24 24">
                <polyline points="3 6 5 6 21 6"/>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
            </svg>
        </button>
    </div>

    <!-- Color picker -->
    <div class="color-picker" id="colorPicker">
        <div class="color-grid">
            <div class="color-btn active" data-color="#ef4444" style="background: #ef4444;"></div>
            <div class="color-btn" data-color="#f97316" style="background: #f97316;"></div>
            <div class="color-btn" data-color="#f59e0b" style="background: #f59e0b;"></div>
            <div class="color-btn" data-color="#eab308" style="background: #eab308;"></div>
            <div class="color-btn" data-color="#84cc16" style="background: #84cc16;"></div>
            <div class="color-btn" data-color="#22c55e" style="background: #22c55e;"></div>
            <div class="color-btn" data-color="#10b981" style="background: #10b981;"></div>
            <div class="color-btn" data-color="#14b8a6" style="background: #14b8a6;"></div>
            <div class="color-btn" data-color="#06b6d4" style="background: #06b6d4;"></div>
            <div class="color-btn" data-color="#0ea5e9" style="background: #0ea5e9;"></div>
            <div class="color-btn" data-color="#3b82f6" style="background: #3b82f6;"></div>
            <div class="color-btn" data-color="#6366f1" style="background: #6366f1;"></div>
            <div class="color-btn" data-color="#8b5cf6" style="background: #8b5cf6;"></div>
            <div class="color-btn" data-color="#a855f7" style="background: #a855f7;"></div>
            <div class="color-btn" data-color="#d946ef" style="background: #d946ef;"></div>
            <div class="color-btn" data-color="#ec4899" style="background: #ec4899;"></div>
        </div>
    </div>

    <!-- Stroke picker -->
    <div class="stroke-picker" id="strokePicker">
        <div class="stroke-option active" data-width="2">
            <div class="stroke-preview"><div class="stroke-line" style="height: 2px;"></div></div>
            <span class="stroke-label">Fine</span>
        </div>
        <div class="stroke-option" data-width="4">
            <div class="stroke-preview"><div class="stroke-line" style="height: 4px;"></div></div>
            <span class="stroke-label">Standard</span>
        </div>
        <div class="stroke-option" data-width="6">
            <div class="stroke-preview"><div class="stroke-line" style="height: 6px;"></div></div>
            <span class="stroke-label">Bold</span>
        </div>
        <div class="stroke-option" data-width="10">
            <div class="stroke-preview"><div class="stroke-line" style="height: 10px;"></div></div>
            <span class="stroke-label">Heavy</span>
        </div>
    </div>

    <!-- Share panel -->
    <div class="share-panel">
        <span class="share-label">Share:</span>
        <input type="text" class="share-input" id="shareInput" readonly>
        <button class="share-btn" id="shareBtn">Copy</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <script>
        // State
        let map;
        let paths = [];
        let undoStack = [];
        let redoStack = [];
        let currentTool = 'freehand';
        let currentColor = 0; // Index into color array
        let currentStroke = 4;
        let isDrawing = false;
        let currentPath = null;
        let startPoint = null;
        let locationMarker = null;
        let autoSaveTimer = null;
        let selectedPathIndex = null;

        const colors = [
            '#ef4444', '#f97316', '#f59e0b', '#eab308',
            '#84cc16', '#22c55e', '#10b981', '#14b8a6',
            '#06b6d4', '#0ea5e9', '#3b82f6', '#6366f1',
            '#8b5cf6', '#a855f7', '#d946ef', '#ec4899'
        ];

        // Initialize map
        map = L.map('map', {
            zoomControl: false
        }).setView([51.505, -0.09], 13);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors',
            maxZoom: 19
        }).addTo(map);

        L.control.zoom({ position: 'bottomright' }).addTo(map);

        const overlay = document.getElementById('drawingOverlay');

        // Update overlay size
        function updateOverlaySize() {
            const container = map.getContainer();
            overlay.setAttribute('width', container.clientWidth);
            overlay.setAttribute('height', container.clientHeight);
        }

        updateOverlaySize();
        window.addEventListener('resize', updateOverlaySize);

        // Convert lat/lng to SVG coordinates
        function latLngToPoint(lat, lng) {
            const point = map.latLngToContainerPoint([lat, lng]);
            return point;
        }

        // Convert SVG coordinates to lat/lng
        function pointToLatLng(x, y) {
            const latLng = map.containerPointToLatLng([x, y]);
            return latLng;
        }

        // Get mouse/touch position
        function getEventPosition(e) {
            const rect = overlay.getBoundingClientRect();
            if (e.touches && e.touches.length > 0) {
                return {
                    x: e.touches[0].clientX - rect.left,
                    y: e.touches[0].clientY - rect.top
                };
            }
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }

        // Drawing functions
        function startDrawing(e) {
            // Don't draw in pan mode
            if (currentTool === 'pan') {
                return;
            }

            // Allow multi-touch for map zoom/pan
            if (e.touches && e.touches.length > 1) {
                return;
            }

            e.preventDefault();
            const pos = getEventPosition(e);

            // Handle eraser tool
            if (currentTool === 'eraser') {
                const pathIndex = findPathAtPoint(pos.x, pos.y);
                if (pathIndex !== null) {
                    // Save to undo stack
                    undoStack.push(JSON.parse(JSON.stringify(paths)));
                    if (undoStack.length > 20) undoStack.shift();
                    redoStack = [];

                    // Remove the path
                    paths.splice(pathIndex, 1);
                    renderPaths();
                    updateButtons();
                    scheduleSave();
                }
                return;
            }

            // Handle select tool
            if (currentTool === 'select') {
                const pathIndex = findPathAtPoint(pos.x, pos.y);
                selectedPathIndex = pathIndex;

                if (pathIndex !== null) {
                    // Save to undo stack before moving
                    undoStack.push(JSON.parse(JSON.stringify(paths)));
                    if (undoStack.length > 20) undoStack.shift();
                    redoStack = [];

                    isDrawing = true;
                    const latLng = pointToLatLng(pos.x, pos.y);
                    startPoint = latLng;
                    map.dragging.disable();
                    renderPaths(); // Re-render to show selection
                }
                return;
            }

            // Normal drawing tools
            isDrawing = true;
            const latLng = pointToLatLng(pos.x, pos.y);

            startPoint = latLng;
            currentPath = {
                type: currentTool,
                color: currentColor,
                width: currentStroke,
                points: [[latLng.lat, latLng.lng]]
            };

            if (currentTool === 'freehand') {
                map.dragging.disable();
            }
        }

        function continueDrawing(e) {
            if (!isDrawing) return;

            // Allow multi-touch for map zoom/pan
            if (e.touches && e.touches.length > 1) {
                stopDrawing(e);
                return;
            }

            e.preventDefault();

            const pos = getEventPosition(e);
            const latLng = pointToLatLng(pos.x, pos.y);

            // Handle select tool dragging
            if (currentTool === 'select' && selectedPathIndex !== null) {
                const path = paths[selectedPathIndex];
                const deltaLat = latLng.lat - startPoint.lat;
                const deltaLng = latLng.lng - startPoint.lng;

                // Move all points in the path
                path.points = path.points.map(point => [
                    point[0] + deltaLat,
                    point[1] + deltaLng
                ]);

                startPoint = latLng;
                renderPaths();
                return;
            }

            if (currentTool === 'freehand') {
                currentPath.points.push([latLng.lat, latLng.lng]);
            } else {
                // For line, circle, arrow - update endpoint
                currentPath.points = [
                    [startPoint.lat, startPoint.lng],
                    [latLng.lat, latLng.lng]
                ];
            }

            renderPaths();
        }

        function stopDrawing(e) {
            if (!isDrawing) return;
            if (e && e.cancelable) e.preventDefault();

            // Handle select tool - just schedule save (undo already saved in startDrawing)
            if (currentTool === 'select' && selectedPathIndex !== null) {
                scheduleSave();
            }

            isDrawing = false;
            map.dragging.enable();

            if (currentPath && currentPath.points.length > 1) {
                // Save to undo stack
                undoStack.push(JSON.parse(JSON.stringify(paths)));
                if (undoStack.length > 20) undoStack.shift();
                redoStack = [];

                paths.push(currentPath);
                scheduleSave();
            }

            currentPath = null;
            startPoint = null;
            renderPaths();
            updateButtons();
        }

        // Render all paths
        function renderPaths() {
            overlay.innerHTML = '';

            // Render saved paths
            paths.forEach((path, index) => {
                const isSelected = (currentTool === 'select' && selectedPathIndex === index);
                renderPath(path, false, isSelected);
            });

            // Render current path being drawn
            if (currentPath) {
                renderPath(currentPath, true, false);
            }
        }

        function renderPath(path, isCurrent = false, isSelected = false) {
            const color = colors[path.color];
            const width = path.width;

            if (path.points.length < 2) return;

            if (path.type === 'freehand' || path.type === 'line') {
                const points = path.points.map(p => latLngToPoint(p[0], p[1]));
                let d = `M ${points[0].x} ${points[0].y}`;
                for (let i = 1; i < points.length; i++) {
                    d += ` L ${points[i].x} ${points[i].y}`;
                }

                // Draw selection highlight
                if (isSelected) {
                    const highlight = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    highlight.setAttribute('d', d);
                    highlight.setAttribute('stroke', '#2563eb');
                    highlight.setAttribute('stroke-width', width + 6);
                    highlight.setAttribute('fill', 'none');
                    highlight.setAttribute('stroke-linecap', 'round');
                    highlight.setAttribute('stroke-linejoin', 'round');
                    highlight.setAttribute('opacity', '0.3');
                    overlay.appendChild(highlight);
                }

                const svgPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                svgPath.setAttribute('d', d);
                svgPath.setAttribute('stroke', color);
                svgPath.setAttribute('stroke-width', width);
                svgPath.setAttribute('fill', 'none');
                svgPath.setAttribute('stroke-linecap', 'round');
                svgPath.setAttribute('stroke-linejoin', 'round');
                if (isCurrent) svgPath.setAttribute('opacity', '0.7');

                overlay.appendChild(svgPath);
            } else if (path.type === 'circle') {
                const start = latLngToPoint(path.points[0][0], path.points[0][1]);
                const end = latLngToPoint(path.points[1][0], path.points[1][1]);
                const radius = Math.sqrt(
                    Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2)
                );

                // Draw selection highlight
                if (isSelected) {
                    const highlight = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    highlight.setAttribute('cx', start.x);
                    highlight.setAttribute('cy', start.y);
                    highlight.setAttribute('r', radius);
                    highlight.setAttribute('stroke', '#2563eb');
                    highlight.setAttribute('stroke-width', width + 6);
                    highlight.setAttribute('fill', 'none');
                    highlight.setAttribute('opacity', '0.3');
                    overlay.appendChild(highlight);
                }

                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', start.x);
                circle.setAttribute('cy', start.y);
                circle.setAttribute('r', radius);
                circle.setAttribute('stroke', color);
                circle.setAttribute('stroke-width', width);
                circle.setAttribute('fill', 'none');
                if (isCurrent) circle.setAttribute('opacity', '0.7');

                overlay.appendChild(circle);
            } else if (path.type === 'arrow') {
                const start = latLngToPoint(path.points[0][0], path.points[0][1]);
                const end = latLngToPoint(path.points[1][0], path.points[1][1]);

                // Arrow head calculations
                const ARROW_HEAD_LENGTH_MULTIPLIER = 3;
                const ARROW_HEAD_ANGLE_RADIANS = Math.PI / 6;
                const angle = Math.atan2(end.y - start.y, end.x - start.x);
                const headLength = width * ARROW_HEAD_LENGTH_MULTIPLIER;
                const headAngle = ARROW_HEAD_ANGLE_RADIANS;

                const x1 = end.x - headLength * Math.cos(angle - headAngle);
                const y1 = end.y - headLength * Math.sin(angle - headAngle);
                const x2 = end.x - headLength * Math.cos(angle + headAngle);
                const y2 = end.y - headLength * Math.sin(angle + headAngle);

                // Draw selection highlight
                if (isSelected) {
                    const highlightLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    highlightLine.setAttribute('x1', start.x);
                    highlightLine.setAttribute('y1', start.y);
                    highlightLine.setAttribute('x2', end.x);
                    highlightLine.setAttribute('y2', end.y);
                    highlightLine.setAttribute('stroke', '#2563eb');
                    highlightLine.setAttribute('stroke-width', width + 6);
                    highlightLine.setAttribute('stroke-linecap', 'round');
                    highlightLine.setAttribute('opacity', '0.3');
                    overlay.appendChild(highlightLine);

                    const highlightHead = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    highlightHead.setAttribute('d', `M ${x1} ${y1} L ${end.x} ${end.y} L ${x2} ${y2}`);
                    highlightHead.setAttribute('stroke', '#2563eb');
                    highlightHead.setAttribute('stroke-width', width + 6);
                    highlightHead.setAttribute('fill', 'none');
                    highlightHead.setAttribute('stroke-linecap', 'round');
                    highlightHead.setAttribute('stroke-linejoin', 'round');
                    highlightHead.setAttribute('opacity', '0.3');
                    overlay.appendChild(highlightHead);
                }

                // Arrow line
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', start.x);
                line.setAttribute('y1', start.y);
                line.setAttribute('x2', end.x);
                line.setAttribute('y2', end.y);
                line.setAttribute('stroke', color);
                line.setAttribute('stroke-width', width);
                line.setAttribute('stroke-linecap', 'round');
                if (isCurrent) line.setAttribute('opacity', '0.7');
                overlay.appendChild(line);

                // Arrow head
                const arrowHead = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                arrowHead.setAttribute('d', `M ${x1} ${y1} L ${end.x} ${end.y} L ${x2} ${y2}`);
                arrowHead.setAttribute('stroke', color);
                arrowHead.setAttribute('stroke-width', width);
                arrowHead.setAttribute('fill', 'none');
                arrowHead.setAttribute('stroke-linecap', 'round');
                arrowHead.setAttribute('stroke-linejoin', 'round');
                if (isCurrent) arrowHead.setAttribute('opacity', '0.7');
                overlay.appendChild(arrowHead);
            }
        }

        // Hit detection - find which path was clicked
        function findPathAtPoint(x, y) {
            const clickLatLng = pointToLatLng(x, y);
            const threshold = 10; // pixels

            // Check paths in reverse order (top to bottom)
            for (let i = paths.length - 1; i >= 0; i--) {
                const path = paths[i];

                if (path.type === 'freehand' || path.type === 'line') {
                    // Check if click is near any line segment
                    for (let j = 0; j < path.points.length - 1; j++) {
                        const p1 = latLngToPoint(path.points[j][0], path.points[j][1]);
                        const p2 = latLngToPoint(path.points[j + 1][0], path.points[j + 1][1]);

                        const dist = distanceToSegment(x, y, p1.x, p1.y, p2.x, p2.y);
                        if (dist < threshold + path.width / 2) {
                            return i;
                        }
                    }
                } else if (path.type === 'circle') {
                    const center = latLngToPoint(path.points[0][0], path.points[0][1]);
                    const edge = latLngToPoint(path.points[1][0], path.points[1][1]);
                    const radius = Math.sqrt(
                        Math.pow(edge.x - center.x, 2) + Math.pow(edge.y - center.y, 2)
                    );

                    const distToCenter = Math.sqrt(
                        Math.pow(x - center.x, 2) + Math.pow(y - center.y, 2)
                    );

                    // Check if click is near the circle outline
                    if (Math.abs(distToCenter - radius) < threshold + path.width / 2) {
                        return i;
                    }
                } else if (path.type === 'arrow') {
                    const start = latLngToPoint(path.points[0][0], path.points[0][1]);
                    const end = latLngToPoint(path.points[1][0], path.points[1][1]);

                    const dist = distanceToSegment(x, y, start.x, start.y, end.x, end.y);
                    if (dist < threshold + path.width / 2) {
                        return i;
                    }
                }
            }

            return null;
        }

        // Calculate distance from point to line segment
        function distanceToSegment(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const lengthSquared = dx * dx + dy * dy;

            if (lengthSquared === 0) {
                return Math.sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1));
            }

            let t = ((px - x1) * dx + (py - y1) * dy) / lengthSquared;
            t = Math.max(0, Math.min(1, t));

            const closestX = x1 + t * dx;
            const closestY = y1 + t * dy;

            return Math.sqrt((px - closestX) * (px - closestX) + (py - closestY) * (py - closestY));
        }

        // Update overlay when map moves
        map.on('move', renderPaths);
        map.on('zoom', () => {
            updateOverlaySize();
            renderPaths();
        });

        // Drawing event listeners
        overlay.addEventListener('mousedown', startDrawing);
        overlay.addEventListener('mousemove', continueDrawing);
        overlay.addEventListener('mouseup', stopDrawing);
        overlay.addEventListener('mouseleave', stopDrawing);

        overlay.addEventListener('touchstart', startDrawing, { passive: false });
        overlay.addEventListener('touchmove', continueDrawing, { passive: false });
        overlay.addEventListener('touchend', stopDrawing, { passive: false });
        overlay.addEventListener('touchcancel', stopDrawing, { passive: false });

        // Tool selection
        function selectTool(tool) {
            currentTool = tool;

            // Clear selection when switching tools
            selectedPathIndex = null;

            // Enable/disable drawing overlay based on tool
            // 'pan' mode: disable overlay so map can be fully interacted with
            // Other tools: enable overlay for drawing
            overlay.classList.toggle('drawing', tool !== null && tool !== 'pan');

            // Update cursor classes
            overlay.classList.remove('select-mode', 'eraser-mode');
            if (tool === 'select') {
                overlay.classList.add('select-mode');
            } else if (tool === 'eraser') {
                overlay.classList.add('eraser-mode');
            }

            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.remove('active');
            });

            if (tool) {
                document.getElementById(tool + 'Btn').classList.add('active');
            }

            // Hide pickers
            document.getElementById('colorPicker').classList.remove('show');
            document.getElementById('strokePicker').classList.remove('show');

            // Re-render to clear any selection highlights
            renderPaths();
        }

        document.getElementById('panBtn').addEventListener('click', () => selectTool('pan'));
        document.getElementById('freehandBtn').addEventListener('click', () => selectTool('freehand'));
        document.getElementById('lineBtn').addEventListener('click', () => selectTool('line'));
        document.getElementById('circleBtn').addEventListener('click', () => selectTool('circle'));
        document.getElementById('arrowBtn').addEventListener('click', () => selectTool('arrow'));
        document.getElementById('selectBtn').addEventListener('click', () => selectTool('select'));
        document.getElementById('eraserBtn').addEventListener('click', () => selectTool('eraser'));

        // Color picker
        document.getElementById('colorBtn').addEventListener('click', () => {
            const picker = document.getElementById('colorPicker');
            const strokePicker = document.getElementById('strokePicker');
            strokePicker.classList.remove('show');
            picker.classList.toggle('show');
        });

        document.querySelectorAll('.color-btn').forEach((btn, index) => {
            btn.addEventListener('click', () => {
                currentColor = index;
                document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
        });

        // Stroke picker
        document.getElementById('strokeBtn').addEventListener('click', () => {
            const picker = document.getElementById('strokePicker');
            const colorPicker = document.getElementById('colorPicker');
            colorPicker.classList.remove('show');
            picker.classList.toggle('show');
        });

        document.querySelectorAll('.stroke-option').forEach(option => {
            option.addEventListener('click', () => {
                currentStroke = parseInt(option.dataset.width);
                document.querySelectorAll('.stroke-option').forEach(o => o.classList.remove('active'));
                option.classList.add('active');
            });
        });

        // Undo/Redo
        function undo() {
            if (undoStack.length === 0) return;
            redoStack.push(JSON.parse(JSON.stringify(paths)));
            paths = undoStack.pop();
            renderPaths();
            updateButtons();
            scheduleSave();
        }

        function redo() {
            if (redoStack.length === 0) return;
            undoStack.push(JSON.parse(JSON.stringify(paths)));
            paths = redoStack.pop();
            renderPaths();
            updateButtons();
            scheduleSave();
        }

        function clearAll() {
            if (paths.length === 0) return;
            if (!confirm('Clear all drawings?')) return;

            undoStack.push(JSON.parse(JSON.stringify(paths)));
            redoStack = [];
            paths = [];
            renderPaths();
            updateButtons();
            scheduleSave();
        }

        document.getElementById('undoBtn').addEventListener('click', undo);
        document.getElementById('redoBtn').addEventListener('click', redo);
        document.getElementById('clearBtn').addEventListener('click', clearAll);

        function updateButtons() {
            document.getElementById('undoBtn').style.opacity = undoStack.length > 0 ? '1' : '0.5';
            document.getElementById('redoBtn').style.opacity = redoStack.length > 0 ? '1' : '0.5';
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
            } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                e.preventDefault();
                redo();
            }
        });

        // Location
        document.getElementById('locateBtn').addEventListener('click', () => {
            if (!navigator.geolocation) {
                alert('Geolocation not supported');
                return;
            }

            const btn = document.getElementById('locateBtn');
            btn.classList.add('active');

            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const { latitude, longitude, accuracy } = position.coords;

                    if (locationMarker) {
                        map.removeLayer(locationMarker);
                    }

                    locationMarker = L.layerGroup([
                        L.circle([latitude, longitude], {
                            radius: accuracy,
                            color: '#3b82f6',
                            fillColor: '#3b82f6',
                            fillOpacity: 0.15
                        }),
                        L.circleMarker([latitude, longitude], {
                            radius: 8,
                            color: '#3b82f6',
                            fillColor: '#3b82f6',
                            fillOpacity: 0.8
                        })
                    ]).addTo(map);

                    map.setView([latitude, longitude], 16);

                    setTimeout(() => btn.classList.remove('active'), 2000);
                },
                (error) => {
                    alert('Location error: ' + error.message);
                    btn.classList.remove('active');
                },
                { enableHighAccuracy: true }
            );
        });

        // Save/Load from URL
        async function encodeData(data) {
            const json = JSON.stringify(data);
            const encoder = new TextEncoder();
            const bytes = encoder.encode(json);

            const stream = new Response(
                new Blob([bytes]).stream().pipeThrough(new CompressionStream('deflate'))
            );

            const compressed = await stream.arrayBuffer();
            const base64 = btoa(String.fromCharCode(...new Uint8Array(compressed)));

            // URL-safe base64: map '+' → '-', '/' → '_' and remove '=' padding (RFC 4648 §5)
            return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
        }

        async function decodeData(encoded) {
            try {
                // Reverse URL-safe base64
                let base64 = encoded.replace(/-/g, '+').replace(/_/g, '/');
                while (base64.length % 4) base64 += '=';

                const binary = atob(base64);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                }

                const stream = new Response(
                    new Blob([bytes]).stream().pipeThrough(new DecompressionStream('deflate'))
                );

                const decompressed = await stream.arrayBuffer();
                const json = new TextDecoder().decode(decompressed);
                return JSON.parse(json);
            } catch (e) {
                console.error('Decode error:', e);
                return null;
            }
        }

        async function updateURL() {
            const data = {
                center: map.getCenter(),
                zoom: map.getZoom(),
                paths: paths
            };

            const encoded = await encodeData(data);
            const url = window.location.origin + window.location.pathname + '#' + encoded;

            document.getElementById('shareInput').value = url;

            // Update URL without reloading
            if (window.location.hash !== '#' + encoded) {
                history.replaceState(null, '', url);
            }

            // Save to sessionStorage
            sessionStorage.setItem('mapDrawData', JSON.stringify(data));
        }

        async function loadFromURL() {
            const hash = window.location.hash.slice(1);

            if (hash) {
                const data = await decodeData(hash);
                if (data) {
                    paths = data.paths || [];
                    if (data.center && data.zoom) {
                        map.setView(data.center, data.zoom);
                    }
                    renderPaths();
                    updateButtons();
                    return;
                }
            }

            // Try sessionStorage
            const saved = sessionStorage.getItem('mapDrawData');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    paths = data.paths || [];
                    if (data.center && data.zoom) {
                        map.setView(data.center, data.zoom);
                    }
                    renderPaths();
                    updateButtons();
                } catch (e) {
                    console.error('Load error:', e);
                }
            }
        }

        const AUTO_SAVE_DELAY = 1000;

        function scheduleSave() {
            if (autoSaveTimer) clearTimeout(autoSaveTimer);
            autoSaveTimer = setTimeout(updateURL, AUTO_SAVE_DELAY);
        }

        // Share button
        document.getElementById('shareBtn').addEventListener('click', async () => {
            const input = document.getElementById('shareInput');
            const btn = document.getElementById('shareBtn');

            try {
                await navigator.clipboard.writeText(input.value);
                btn.textContent = 'Copied!';
                btn.classList.add('copied');
                setTimeout(() => {
                    btn.textContent = 'Copy';
                    btn.classList.remove('copied');
                }, 2000);
            } catch (e) {
                input.select();
            }
        });

        // Initialize
        selectTool('pan');
        loadFromURL();
        updateURL();

        // Save on map move
        map.on('moveend', scheduleSave);
    </script>
</body>
</html>
