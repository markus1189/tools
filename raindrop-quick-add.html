<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Quickly add bookmarks to Raindrop.io with automatic metadata parsing">
    <meta name="theme-color" content="#f97316">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Raindrop+">
    <link rel="manifest" href="raindrop-quick-add.manifest.json">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='80' font-size='80'>üíß</text></svg>">
    <title>Raindrop Quick Add</title>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #0a0a0a;
            --bg-card: #141414;
            --bg-card-hover: #1a1a1a;
            --bg-input: #1e1e1e;
            --border: #2a2a2a;
            --text: #e5e5e5;
            --text-muted: #888;
            --accent: #f97316;
            --accent-hover: #fb923c;
            --accent-dim: #c2410c;
            --success: #22c55e;
            --danger: #ef4444;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1.5rem;
        }

        .container {
            width: 100%;
            max-width: 600px;
        }

        /* Header */
        header {
            text-align: center;
            margin-bottom: 2rem;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent);
            margin-bottom: 0.5rem;
        }

        .subtitle {
            font-size: 0.875rem;
            color: var(--text-muted);
        }

        /* Cards */
        .card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1rem;
        }

        .card h2 {
            font-size: 1.125rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text);
        }

        /* Settings Section */
        .settings-section {
            margin-bottom: 1rem;
        }

        .settings-toggle {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1rem 1.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: background-color 0.2s;
        }

        .settings-toggle:hover {
            background: var(--bg-card-hover);
        }

        .settings-toggle-text {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .settings-status {
            font-size: 0.875rem;
            color: var(--text-muted);
        }

        .settings-status.configured {
            color: var(--success);
        }

        .chevron {
            transition: transform 0.2s;
            color: var(--text-muted);
        }

        .chevron.expanded {
            transform: rotate(180deg);
        }

        .settings-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .settings-content.expanded {
            max-height: 500px;
        }

        .settings-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-top: none;
            border-radius: 0 0 12px 12px;
            padding: 1.5rem;
            margin-top: -1px;
        }

        /* Form Elements */
        label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            margin-bottom: 0.5rem;
            color: var(--text);
        }

        input {
            width: 100%;
            background: var(--bg-input);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 0.75rem 1rem;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.2s;
        }

        input:focus {
            outline: none;
            border-color: var(--accent);
        }

        input::placeholder {
            color: var(--text-muted);
        }

        .help-text {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-top: 0.5rem;
            line-height: 1.4;
        }

        .help-text a {
            color: var(--accent);
            text-decoration: none;
        }

        .help-text a:hover {
            text-decoration: underline;
        }

        /* Buttons */
        button {
            background: var(--accent);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
            width: 100%;
        }

        button:hover:not(:disabled) {
            background: var(--accent-hover);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button.secondary {
            background: var(--bg-input);
            color: var(--text);
            border: 1px solid var(--border);
        }

        button.secondary:hover:not(:disabled) {
            background: var(--bg-card-hover);
        }

        .button-group {
            display: flex;
            gap: 0.75rem;
            margin-top: 1rem;
        }

        .button-group button {
            flex: 1;
        }

        /* Loading Spinner */
        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
            margin-right: 0.5rem;
            vertical-align: middle;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none;
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-left: 4px solid var(--success);
            border-radius: 8px;
            padding: 1rem 1.25rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            min-width: 300px;
            max-width: 400px;
            animation: slideIn 0.3s ease;
            opacity: 1;
            transition: opacity 0.3s;
        }

        .toast.hidden {
            display: none;
        }

        .toast.error {
            border-left-color: var(--danger);
        }

        .toast.success {
            border-left-color: var(--success);
        }

        .toast-icon {
            font-size: 1.25rem;
            flex-shrink: 0;
        }

        .toast-message {
            flex: 1;
            line-height: 1.4;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Form spacing */
        .form-group {
            margin-bottom: 1rem;
        }

        .form-group:last-child {
            margin-bottom: 0;
        }

        /* Responsive */
        @media (max-width: 640px) {
            .toast {
                left: 20px;
                right: 20px;
                min-width: 0;
            }
        }

        /* Screen reader only */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        /* Recent Bookmarks */
        .recent-bookmarks {
            margin-top: 1rem;
        }

        .bookmark-item {
            background: var(--bg-input);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            transition: background-color 0.2s;
            display: flex;
            gap: 0.75rem;
            align-items: flex-start;
        }

        .bookmark-item:hover {
            background: var(--bg-card-hover);
        }

        .bookmark-item:last-child {
            margin-bottom: 0;
        }

        .bookmark-content {
            flex: 1;
            min-width: 0;
        }

        .bookmark-delete-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-muted);
            padding: 0.4rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
            flex-shrink: 0;
            line-height: 1;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .bookmark-delete-btn:hover {
            background: var(--danger);
            color: white;
            border-color: var(--danger);
        }

        .bookmark-delete-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .bookmark-title {
            font-weight: 500;
            color: var(--text);
            margin-bottom: 0.25rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .bookmark-url {
            font-size: 0.75rem;
            color: var(--text-muted);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .bookmark-url a {
            color: var(--accent);
            text-decoration: none;
        }

        .bookmark-url a:hover {
            text-decoration: underline;
        }

        .bookmark-meta {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-top: 0.25rem;
            font-style: italic;
        }

        .loading-text {
            text-align: center;
            color: var(--text-muted);
            padding: 1rem;
            font-size: 0.875rem;
        }

        .error-text {
            text-align: center;
            color: var(--danger);
            padding: 1rem;
            font-size: 0.875rem;
        }

        .empty-text {
            text-align: center;
            color: var(--text-muted);
            padding: 1rem;
            font-size: 0.875rem;
        }

        .refresh-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
        }

        .refresh-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-muted);
            padding: 0.4rem 0.75rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s;
        }

        .refresh-btn:hover {
            background: var(--bg-input);
            color: var(--text);
            border-color: var(--accent);
        }

        .refresh-btn.refreshing {
            cursor: not-allowed;
            opacity: 0.5;
        }

        .refresh-btn .refresh-icon {
            display: inline-block;
            transition: transform 0.3s;
        }

        .refresh-btn.refreshing .refresh-icon {
            animation: spin 1s linear infinite;
        }

        /* ===================================================================
           Background Sync Queue UI Styles
           ================================================================ */

        /* Queue Status Header */
        .queue-status {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-left: 4px solid var(--accent);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .queue-status.hidden {
            display: none;
        }

        .queue-icon {
            font-size: 1.25rem;
            flex-shrink: 0;
        }

        .queue-text {
            flex: 1;
            font-size: 0.875rem;
            color: var(--text);
        }

        .queue-dismiss {
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 0.25rem;
            width: auto;
            min-width: unset;
            transition: color 0.2s;
        }

        .queue-dismiss:hover {
            color: var(--text);
        }

        /* Queue Badge on Submit Button */
        button[type="submit"] {
            position: relative;
        }

        .queue-badge {
            position: absolute;
            top: -8px;
            right: -8px;
            background: var(--accent);
            color: white;
            border-radius: 12px;
            padding: 2px 8px;
            font-size: 0.75rem;
            font-weight: 600;
            min-width: 20px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .queue-badge.hidden {
            display: none;
        }

        /* Bookmark Status Badges */
        .bookmark-status {
            display: inline-block;
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 500;
            margin-left: 0.5rem;
            vertical-align: middle;
        }

        .status-queued {
            background: var(--bg-input);
            color: var(--text-muted);
            border: 1px solid var(--border);
        }

        .status-syncing {
            background: var(--accent);
            color: white;
            animation: pulse 1.5s infinite;
        }

        .status-failed {
            background: var(--danger);
            color: white;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Raindrop Quick Add</h1>
            <p class="subtitle">Add bookmarks to your Raindrop.io collection</p>
        </header>

        <!-- Queue Status Header -->
        <div id="queueStatus" class="queue-status hidden">
            <span class="queue-icon">‚è≥</span>
            <span class="queue-text"><span id="queueCount">0</span> bookmark(s) queued</span>
            <button type="button" class="queue-dismiss" onclick="dismissQueueHeader()">‚úï</button>
        </div>

        <!-- Settings Section -->
        <div class="settings-section">
            <div class="settings-toggle" id="settingsToggle" role="button" tabindex="0" aria-expanded="false" aria-controls="settingsContent">
                <div class="settings-toggle-text">
                    <span style="font-weight: 500;">Settings</span>
                    <span class="settings-status" id="settingsStatus">Not configured</span>
                </div>
                <span class="chevron" aria-hidden="true">‚ñº</span>
            </div>
            <div class="settings-content" id="settingsContent">
                <div class="settings-card">
                    <h2>Access Token</h2>
                    <div class="form-group">
                        <label for="accessToken">Bearer Token</label>
                        <input
                            type="password"
                            id="accessToken"
                            placeholder="Enter your Raindrop.io access token"
                            aria-describedby="tokenHelp"
                        >
                        <p class="help-text" id="tokenHelp">
                            Get your access token from
                            <a href="https://app.raindrop.io/settings/integrations" target="_blank" rel="noopener noreferrer">
                                Raindrop.io Settings ‚Üí Apps
                            </a>
                            (create a test token)
                        </p>
                    </div>
                    <div class="button-group">
                        <button type="button" class="secondary" onclick="clearToken()">Clear</button>
                        <button type="button" onclick="saveToken()">Save Token</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Input Card -->
        <div class="card">
            <form onsubmit="handleSubmit(event)" id="bookmarkForm">
                <div class="form-group">
                    <label for="urlInput">URL</label>
                    <input
                        type="url"
                        id="urlInput"
                        placeholder="https://example.com"
                        required
                        aria-required="true"
                        aria-describedby="urlHelp"
                    >
                    <p class="help-text" id="urlHelp">
                        Enter a URL to add to your Unsorted collection. Raindrop will automatically parse the page metadata.
                    </p>
                </div>
                <button type="submit" id="submitBtn" disabled>
                    Add to Raindrop
                    <span id="queueBadge" class="queue-badge hidden">0</span>
                </button>
            </form>
        </div>

        <!-- Recent Bookmarks Card -->
        <div class="card recent-bookmarks">
            <div class="refresh-header">
                <h2>Recent Bookmarks</h2>
                <button type="button" class="refresh-btn" id="refreshBtn" onclick="loadRecentBookmarks()">
                    <span class="refresh-icon">‚Üª</span> Refresh
                </button>
            </div>
            <div id="bookmarksList">
                <div class="loading-text">Loading...</div>
            </div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast hidden" role="status" aria-live="polite" aria-atomic="true">
        <span class="toast-icon"></span>
        <span class="toast-message"></span>
    </div>

    <!-- Screen reader announcer -->
    <div class="sr-only" aria-live="polite" aria-atomic="true" id="announcer"></div>

    <script>
        // Constants
        const RAINDROP_API_BASE = 'https://api.raindrop.io/rest/v1';
        const UNSORTED_COLLECTION_ID = -1;
        const STORAGE_KEY_TOKEN = 'raindrop-access-token';

        // State
        const state = {
            accessToken: null,
            isSubmitting: false,
            isLoadingBookmarks: false,
            queueCount: 0,
            isSyncing: false,
            supportsBackgroundSync: false
        };

        // DOM Elements
        const elements = {
            settingsToggle: document.getElementById('settingsToggle'),
            settingsContent: document.getElementById('settingsContent'),
            settingsStatus: document.getElementById('settingsStatus'),
            accessTokenInput: document.getElementById('accessToken'),
            urlInput: document.getElementById('urlInput'),
            submitBtn: document.getElementById('submitBtn'),
            bookmarkForm: document.getElementById('bookmarkForm'),
            toast: document.getElementById('toast'),
            toastIcon: document.querySelector('.toast-icon'),
            toastMessage: document.querySelector('.toast-message'),
            chevron: document.querySelector('.chevron'),
            announcer: document.getElementById('announcer'),
            bookmarksList: document.getElementById('bookmarksList'),
            refreshBtn: document.getElementById('refreshBtn')
        };

        // Initialize on page load
        function init() {
            // Check Background Sync support
            if ('serviceWorker' in navigator && 'sync' in ServiceWorkerRegistration.prototype) {
                state.supportsBackgroundSync = true;
                console.log('Background Sync API supported');
            } else {
                console.warn('Background Sync API not supported');
            }

            loadToken();
            updateUI();
            setupEventListeners();
            handleSharedContent();
            loadRecentBookmarks();

            // Update queue badge on load
            updateQueueBadge();

            // Setup service worker message listener
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.addEventListener('message', handleSyncMessage);
            }
        }

        // Handle shared content from share target
        function handleSharedContent() {
            const urlParams = new URLSearchParams(window.location.search);
            const sharedUrl = urlParams.get('url') || urlParams.get('text');
            const sharedTitle = urlParams.get('title');

            if (sharedUrl) {
                // Validate that it's a URL
                try {
                    new URL(sharedUrl);
                    elements.urlInput.value = sharedUrl;

                    // Clear URL parameters from address bar for cleaner UX
                    if (window.history && window.history.replaceState) {
                        window.history.replaceState({}, document.title, window.location.pathname);
                    }

                    // Show notification
                    const message = sharedTitle
                        ? `Ready to add: ${sharedTitle}`
                        : 'URL received from share';
                    showToast(message, 'success', 3000);

                    // Focus the submit button if token is configured, otherwise focus URL input
                    if (state.accessToken) {
                        elements.submitBtn.focus();
                    } else {
                        showToast('Please configure your access token first', 'error');
                        toggleSettings();
                    }
                } catch (error) {
                    console.log('Shared content is not a valid URL:', sharedUrl);
                    // If not a valid URL, still put it in the field - user might want to edit it
                    elements.urlInput.value = sharedUrl;
                    elements.urlInput.focus();
                }
            }
        }

        // Event Listeners
        function setupEventListeners() {
            // Settings toggle
            elements.settingsToggle.addEventListener('click', toggleSettings);
            elements.settingsToggle.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    toggleSettings();
                }
            });

            // Auto-save token on blur
            elements.accessTokenInput.addEventListener('blur', () => {
                const value = elements.accessTokenInput.value.trim();
                if (value && value !== state.accessToken) {
                    saveToken();
                }
            });
        }

        // Settings Toggle
        function toggleSettings() {
            const isExpanded = elements.settingsContent.classList.contains('expanded');

            if (isExpanded) {
                elements.settingsContent.classList.remove('expanded');
                elements.chevron.classList.remove('expanded');
                elements.settingsToggle.setAttribute('aria-expanded', 'false');
            } else {
                elements.settingsContent.classList.add('expanded');
                elements.chevron.classList.add('expanded');
                elements.settingsToggle.setAttribute('aria-expanded', 'true');
                elements.accessTokenInput.focus();
            }
        }

        // LocalStorage Functions
        function loadToken() {
            try {
                const token = localStorage.getItem(STORAGE_KEY_TOKEN);
                if (token && token.trim().length > 0) {
                    state.accessToken = token.trim();
                    elements.accessTokenInput.value = token.trim();
                    return true;
                }
            } catch (error) {
                console.error('Failed to load access token:', error);
            }
            return false;
        }

        function saveToken() {
            try {
                const token = elements.accessTokenInput.value.trim();

                if (!token) {
                    showToast('Please enter an access token', 'error');
                    return false;
                }

                localStorage.setItem(STORAGE_KEY_TOKEN, token);
                state.accessToken = token;

                showToast('Access token saved successfully', 'success');
                updateUI();

                // Collapse settings after saving
                setTimeout(() => {
                    if (elements.settingsContent.classList.contains('expanded')) {
                        toggleSettings();
                    }
                }, 1000);

                return true;
            } catch (error) {
                console.error('Failed to save access token:', error);
                showToast('Failed to save token: ' + error.message, 'error');
                return false;
            }
        }

        function clearToken() {
            try {
                localStorage.removeItem(STORAGE_KEY_TOKEN);
                state.accessToken = null;
                elements.accessTokenInput.value = '';

                showToast('Access token cleared', 'success');
                updateUI();
            } catch (error) {
                console.error('Failed to clear token:', error);
                showToast('Failed to clear token', 'error');
            }
        }

        // UI Updates
        function updateUI() {
            const hasToken = state.accessToken !== null;

            // Update submit button state
            elements.submitBtn.disabled = !hasToken;

            // Update settings status
            if (hasToken) {
                elements.settingsStatus.textContent = 'Configured';
                elements.settingsStatus.classList.add('configured');
            } else {
                elements.settingsStatus.textContent = 'Not configured';
                elements.settingsStatus.classList.remove('configured');
            }
        }

        // Form Submission
        async function handleSubmit(event) {
            event.preventDefault();

            if (state.isSubmitting) return;

            const url = elements.urlInput.value.trim();

            // Validate URL
            try {
                new URL(url);
            } catch (error) {
                showToast('Please enter a valid URL', 'error');
                elements.urlInput.focus();
                return;
            }

            if (!state.accessToken) {
                showToast('Please configure your access token first', 'error');
                toggleSettings();
                return;
            }

            // Add bookmark
            await addBookmark(url);
        }

        // Raindrop API
        async function addBookmark(url) {
            state.isSubmitting = true;

            // Show loading state
            const originalText = elements.submitBtn.innerHTML;
            elements.submitBtn.innerHTML = '<span class="spinner"></span>Adding...';
            elements.submitBtn.disabled = true;

            try {
                const response = await fetch(`${RAINDROP_API_BASE}/raindrop`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${state.accessToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        link: url,
                        collection: { $id: UNSORTED_COLLECTION_ID },
                        pleaseParse: {}
                    })
                });

                if (!response.ok) {
                    await handleApiError(response);
                    return;
                }

                const data = await response.json();
                const title = data.item?.title || url;

                showToast(`Bookmark added: ${title}`, 'success');
                announce(`Bookmark added successfully: ${title}`);

                // Clear input and focus
                elements.urlInput.value = '';
                elements.urlInput.focus();

                // Reload recent bookmarks to show the new one
                loadRecentBookmarks();

            } catch (error) {
                console.error('Failed to add bookmark:', error);

                // Network error - queue for background sync
                if (error.message.includes('Failed to fetch') || !navigator.onLine) {
                    try {
                        await queueBookmarkForSync(url);
                    } catch (queueError) {
                        console.error('Failed to queue bookmark:', queueError);
                        showToast('Failed to add or queue bookmark', 'error');
                    }
                } else {
                    showToast('Failed to add bookmark: ' + error.message, 'error');
                }
            } finally {
                state.isSubmitting = false;
                elements.submitBtn.innerHTML = originalText;
                elements.submitBtn.disabled = !state.accessToken;
            }
        }

        // API Error Handling
        async function handleApiError(response) {
            let errorMessage = 'Failed to add bookmark';

            try {
                const errorData = await response.json();
                errorMessage = errorData.errorMessage || errorData.message || errorMessage;
            } catch (e) {
                // Use status-based messages if JSON parsing fails
            }

            switch (response.status) {
                case 401:
                    errorMessage = 'Invalid token. Please check your access token.';
                    // Show settings
                    if (!elements.settingsContent.classList.contains('expanded')) {
                        toggleSettings();
                    }
                    break;
                case 400:
                    errorMessage = errorMessage || 'Invalid URL or request.';
                    break;
                case 429:
                    errorMessage = 'Rate limit exceeded. Wait a moment and try again.';
                    break;
                case 500:
                case 502:
                case 503:
                    errorMessage = 'Raindrop service error. Please try again later.';
                    break;
            }

            showToast(errorMessage, 'error');
            announce(errorMessage);
        }

        // Load Recent Bookmarks
        async function loadRecentBookmarks() {
            if (!state.accessToken) {
                elements.bookmarksList.innerHTML = '<div class="empty-text">Configure your access token to view recent bookmarks</div>';
                return;
            }

            if (state.isLoadingBookmarks) return;

            state.isLoadingBookmarks = true;
            elements.refreshBtn.classList.add('refreshing');
            elements.refreshBtn.disabled = true;

            try {
                // Fetch from API
                const response = await fetch(
                    `${RAINDROP_API_BASE}/raindrops/${UNSORTED_COLLECTION_ID}?perpage=5&sort=-created`,
                    {
                        headers: {
                            'Authorization': `Bearer ${state.accessToken}`
                        }
                    }
                );

                if (!response.ok) {
                    if (response.status === 401) {
                        elements.bookmarksList.innerHTML = '<div class="error-text">Invalid token. Please check your access token.</div>';
                    } else {
                        elements.bookmarksList.innerHTML = '<div class="error-text">Failed to load bookmarks</div>';
                    }
                    return;
                }

                const data = await response.json();
                const apiBookmarks = data.items || [];

                // Get queued items
                const queuedItems = await getQueuedItems();

                // Combine and render
                const allBookmarks = [
                    ...queuedItems.map(item => ({
                        _id: `queue-${item.id}`,
                        title: item.url,
                        link: item.url,
                        isQueued: true,
                        queueId: item.id,
                        status: item.status,
                        lastError: item.lastError
                    })),
                    ...apiBookmarks
                ];

                if (allBookmarks.length === 0) {
                    elements.bookmarksList.innerHTML = '<div class="empty-text">No bookmarks yet. Add one above!</div>';
                    return;
                }

                // Render bookmarks with status badges
                elements.bookmarksList.innerHTML = allBookmarks.map(bookmark => {
                    const title = bookmark.title || bookmark.link || 'Untitled';
                    const url = bookmark.link;
                    const id = bookmark._id;

                    let statusBadge = '';
                    let deleteBtn = '';
                    let metaInfo = '';

                    if (bookmark.isQueued) {
                        // Queued bookmark
                        const queueId = bookmark.queueId;

                        if (bookmark.status === 'pending') {
                            statusBadge = '<span class="bookmark-status status-queued">‚è≥ Queued</span>';
                        } else if (bookmark.status === 'syncing') {
                            statusBadge = '<span class="bookmark-status status-syncing">‚ü≥ Syncing...</span>';
                        } else if (bookmark.status === 'failed') {
                            statusBadge = '<span class="bookmark-status status-failed">‚ö† Failed</span>';
                        }

                        deleteBtn = `
                            <button
                                class="bookmark-delete-btn"
                                onclick="removeQueuedBookmark(${queueId})"
                                title="Remove from queue"
                                aria-label="Remove from queue: ${escapeHtml(title)}"
                            >üóëÔ∏è</button>
                        `;
                    } else {
                        // Regular bookmark
                        const hasMetadata = bookmark.title && bookmark.title !== url;
                        metaInfo = `<div class="bookmark-meta">${hasMetadata ? 'Metadata loaded' : 'Waiting for metadata...'}</div>`;

                        deleteBtn = `
                            <button
                                class="bookmark-delete-btn"
                                onclick="deleteBookmark(${id}, '${escapeHtml(title).replace(/'/g, "\\'")}')"
                                title="Delete bookmark"
                                aria-label="Delete bookmark: ${escapeHtml(title)}"
                            >üóëÔ∏è</button>
                        `;
                    }

                    return `
                        <div class="bookmark-item">
                            <div class="bookmark-content">
                                <div class="bookmark-title">${escapeHtml(title)}${statusBadge}</div>
                                <div class="bookmark-url">
                                    <a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer">${escapeHtml(url)}</a>
                                </div>
                                ${metaInfo}
                            </div>
                            ${deleteBtn}
                        </div>
                    `;
                }).join('');

            } catch (error) {
                console.error('Failed to load bookmarks:', error);
                elements.bookmarksList.innerHTML = '<div class="error-text">Network error. Check your connection.</div>';
            } finally {
                state.isLoadingBookmarks = false;
                elements.refreshBtn.classList.remove('refreshing');
                elements.refreshBtn.disabled = false;
            }
        }

        // Delete Bookmark
        async function deleteBookmark(id, title) {
            // Confirmation dialog
            const confirmMessage = `Delete "${title}"?\n\nThis will move it to Trash.`;
            if (!confirm(confirmMessage)) {
                return;
            }

            try {
                const response = await fetch(`${RAINDROP_API_BASE}/raindrop/${id}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${state.accessToken}`
                    }
                });

                if (!response.ok) {
                    if (response.status === 401) {
                        showToast('Invalid token. Please check your access token.', 'error');
                    } else {
                        showToast('Failed to delete bookmark', 'error');
                    }
                    return;
                }

                showToast('Bookmark moved to trash', 'success');
                announce('Bookmark deleted successfully');

                // Reload the list
                loadRecentBookmarks();

            } catch (error) {
                console.error('Failed to delete bookmark:', error);
                showToast('Network error. Check your connection.', 'error');
            }
        }

        // HTML escape helper
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Toast Notification
        function showToast(message, type = 'success', duration = 4000) {
            // Update toast content
            elements.toastMessage.textContent = message;

            // Set icon based on type
            elements.toastIcon.textContent = type === 'success' ? '‚úì' : '‚úï';

            // Update toast class
            elements.toast.classList.remove('success', 'error');
            elements.toast.classList.add(type);

            // Show toast
            elements.toast.classList.remove('hidden');

            // Auto-hide after duration
            setTimeout(() => {
                elements.toast.classList.add('hidden');
            }, duration);
        }

        // Screen Reader Announcements
        function announce(message) {
            elements.announcer.textContent = message;
            setTimeout(() => {
                elements.announcer.textContent = '';
            }, 1000);
        }

        // ============================================================================
        // Background Sync - IndexedDB Queue Management
        // ============================================================================

        const DB_NAME = 'raindrop-sync-queue';
        const STORE_NAME = 'pending-bookmarks';

        // Open IndexedDB database
        async function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, 1);

                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        const store = db.createObjectStore(STORE_NAME, {
                            keyPath: 'id',
                            autoIncrement: true
                        });
                        store.createIndex('timestamp', 'timestamp', { unique: false });
                        store.createIndex('status', 'status', { unique: false });
                    }
                };
            });
        }

        // Add bookmark to queue
        async function addToQueue(url) {
            const db = await openDB();
            const tx = db.transaction(STORE_NAME, 'readwrite');
            const store = tx.objectStore(STORE_NAME);

            const item = {
                url,
                timestamp: Date.now(),
                status: 'pending',
                retryCount: 0,
                lastError: null,
                createdAt: new Date().toISOString()
            };

            return new Promise((resolve, reject) => {
                const request = store.add(item);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        // Get all queued items
        async function getQueuedItems() {
            try {
                const db = await openDB();
                const tx = db.transaction(STORE_NAME, 'readonly');
                const store = tx.objectStore(STORE_NAME);

                return new Promise((resolve, reject) => {
                    const request = store.getAll();
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => reject(request.error);
                });
            } catch (error) {
                console.error('Failed to get queued items:', error);
                return [];
            }
        }

        // Update queue item
        async function updateQueueItem(id, updates) {
            const db = await openDB();
            const tx = db.transaction(STORE_NAME, 'readwrite');
            const store = tx.objectStore(STORE_NAME);

            return new Promise((resolve, reject) => {
                const getRequest = store.get(id);
                getRequest.onsuccess = () => {
                    const item = { ...getRequest.result, ...updates };
                    const updateRequest = store.put(item);
                    updateRequest.onsuccess = () => resolve();
                    updateRequest.onerror = () => reject(updateRequest.error);
                };
                getRequest.onerror = () => reject(getRequest.error);
            });
        }

        // Remove from queue
        async function removeFromQueue(id) {
            const db = await openDB();
            const tx = db.transaction(STORE_NAME, 'readwrite');
            const store = tx.objectStore(STORE_NAME);

            return new Promise((resolve, reject) => {
                const request = store.delete(id);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        // Get count of pending items
        async function getQueueCount() {
            const items = await getQueuedItems();
            return items.filter(item => item.status === 'pending' || item.status === 'syncing').length;
        }

        // Queue bookmark for sync
        async function queueBookmarkForSync(url) {
            if (!state.supportsBackgroundSync) {
                showToast('Background sync not supported - please try again when online', 'error');
                return;
            }

            try {
                // Add to queue
                await addToQueue(url);

                // Register background sync
                const registration = await navigator.serviceWorker.ready;
                await registration.sync.register('sync-bookmarks');

                // Update UI
                await updateQueueBadge();
                showToast('Bookmark queued - will sync when online', 'success');

                elements.urlInput.value = '';
                elements.urlInput.focus();

                // Reload to show queued item
                await loadRecentBookmarks();

            } catch (error) {
                console.error('Failed to queue bookmark:', error);
                throw error;
            }
        }

        // Handle messages from service worker
        function handleSyncMessage(event) {
            const { type, url } = event.data;

            switch (type) {
                case 'GET_ACCESS_TOKEN':
                    // Respond with access token
                    event.ports[0].postMessage({ token: state.accessToken });
                    break;

                case 'SYNC_SUCCESS':
                    showToast(`Synced: ${url}`, 'success');
                    updateQueueBadge();
                    loadRecentBookmarks();
                    break;

                case 'SYNC_AUTH_FAILED':
                    showToast('Sync failed: Invalid token. Please update your access token.', 'error');
                    if (!elements.settingsContent.classList.contains('expanded')) {
                        toggleSettings();
                    }
                    updateQueueBadge();
                    loadRecentBookmarks();
                    break;

                case 'SYNC_FAILED':
                    showToast('Some bookmarks failed to sync', 'error');
                    updateQueueBadge();
                    loadRecentBookmarks();
                    break;
            }
        }

        // Update queue badge display
        async function updateQueueBadge() {
            const count = await getQueueCount();
            state.queueCount = count;

            const badge = document.getElementById('queueBadge');
            const header = document.getElementById('queueStatus');
            const queueCountText = document.getElementById('queueCount');

            if (count > 0) {
                badge.textContent = count;
                badge.classList.remove('hidden');
                queueCountText.textContent = count;
                header.classList.remove('hidden');
            } else {
                badge.classList.add('hidden');
                header.classList.add('hidden');
            }
        }

        // Dismiss queue header
        function dismissQueueHeader() {
            document.getElementById('queueStatus').classList.add('hidden');
        }

        // Remove queued bookmark
        async function removeQueuedBookmark(id) {
            try {
                await removeFromQueue(parseInt(id));
                showToast('Removed from queue', 'success');
                await updateQueueBadge();
                await loadRecentBookmarks();
            } catch (error) {
                console.error('Failed to remove from queue:', error);
                showToast('Failed to remove from queue', 'error');
            }
        }

        // Service Worker Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('raindrop-quick-add-sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registered:', registration.scope);
                    })
                    .catch(error => {
                        console.log('ServiceWorker registration failed:', error);
                    });
            });
        }

        // Initialize app
        init();
    </script>
</body>
</html>
