<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Quickly add bookmarks to Raindrop.io with automatic metadata parsing">
    <meta name="theme-color" content="#f97316">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Raindrop+">
    <link rel="manifest" href="raindrop-quick-add.manifest.json">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='80' font-size='80'>üíß</text></svg>">
    <title>Raindrop Quick Add</title>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #0a0a0a;
            --bg-card: #141414;
            --bg-card-hover: #1a1a1a;
            --bg-input: #1e1e1e;
            --border: #2a2a2a;
            --text: #e5e5e5;
            --text-muted: #888;
            --accent: #f97316;
            --accent-hover: #fb923c;
            --accent-dim: #c2410c;
            --success: #22c55e;
            --danger: #ef4444;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1.5rem;
        }

        .container {
            width: 100%;
            max-width: 600px;
        }

        /* Header */
        header {
            text-align: center;
            margin-bottom: 2rem;
            position: relative;
        }

        .back-link {
            position: absolute;
            top: 0;
            left: 0;
            color: var(--text-muted);
            text-decoration: none;
            font-size: 0.875rem;
        }

        .back-link:hover {
            color: var(--accent);
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent);
            margin-bottom: 0.5rem;
        }

        .subtitle {
            font-size: 0.875rem;
            color: var(--text-muted);
        }

        /* Cards */
        .card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1rem;
        }

        .card h2 {
            font-size: 1.125rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text);
        }

        /* Settings Section */
        .settings-section {
            margin-bottom: 1rem;
        }

        .settings-toggle {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1rem 1.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: background-color 0.2s;
        }

        .settings-toggle:hover {
            background: var(--bg-card-hover);
        }

        .settings-toggle-text {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .settings-status {
            font-size: 0.875rem;
            color: var(--text-muted);
        }

        .settings-status.configured {
            color: var(--success);
        }

        .chevron {
            transition: transform 0.2s;
            color: var(--text-muted);
        }

        .chevron.expanded {
            transform: rotate(180deg);
        }

        .settings-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .settings-content.expanded {
            max-height: 500px;
        }

        .settings-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-top: none;
            border-radius: 0 0 12px 12px;
            padding: 1.5rem;
            margin-top: -1px;
        }

        /* Form Elements */
        label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            margin-bottom: 0.5rem;
            color: var(--text);
        }

        input {
            width: 100%;
            background: var(--bg-input);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 0.75rem 1rem;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.2s;
        }

        input:focus {
            outline: none;
            border-color: var(--accent);
        }

        input::placeholder {
            color: var(--text-muted);
        }

        .help-text {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-top: 0.5rem;
            line-height: 1.4;
        }

        .help-text a {
            color: var(--accent);
            text-decoration: none;
        }

        .help-text a:hover {
            text-decoration: underline;
        }

        /* Buttons */
        button {
            background: var(--accent);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
            width: 100%;
        }

        button:hover:not(:disabled) {
            background: var(--accent-hover);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button.secondary {
            background: var(--bg-input);
            color: var(--text);
            border: 1px solid var(--border);
        }

        button.secondary:hover:not(:disabled) {
            background: var(--bg-card-hover);
        }

        .button-group {
            display: flex;
            gap: 0.75rem;
            margin-top: 1rem;
        }

        .button-group button {
            flex: 1;
        }

        /* Loading Spinner */
        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
            margin-right: 0.5rem;
            vertical-align: middle;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none;
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-left: 4px solid var(--success);
            border-radius: 8px;
            padding: 1rem 1.25rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            min-width: 300px;
            max-width: 400px;
            animation: slideIn 0.3s ease;
            opacity: 1;
            transition: opacity 0.3s;
        }

        .toast.hidden {
            display: none;
        }

        .toast.error {
            border-left-color: var(--danger);
        }

        .toast.success {
            border-left-color: var(--success);
        }

        .toast-icon {
            font-size: 1.25rem;
            flex-shrink: 0;
        }

        .toast-message {
            flex: 1;
            line-height: 1.4;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Form spacing */
        .form-group {
            margin-bottom: 1rem;
        }

        .form-group:last-child {
            margin-bottom: 0;
        }

        /* Responsive */
        @media (max-width: 640px) {
            .toast {
                left: 20px;
                right: 20px;
                min-width: 0;
            }
        }

        /* Screen reader only */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        /* Recent Bookmarks */
        .recent-bookmarks {
            margin-top: 1rem;
        }

        .bookmark-item {
            background: var(--bg-input);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            transition: background-color 0.2s;
            display: flex;
            gap: 0.75rem;
            align-items: flex-start;
        }

        .bookmark-item:hover {
            background: var(--bg-card-hover);
        }

        .bookmark-item:last-child {
            margin-bottom: 0;
        }

        .bookmark-content {
            flex: 1;
            min-width: 0;
        }

        .bookmark-delete-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-muted);
            padding: 0.4rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
            flex-shrink: 0;
            line-height: 1;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .bookmark-delete-btn:hover {
            background: var(--danger);
            color: white;
            border-color: var(--danger);
        }

        .bookmark-delete-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .bookmark-title {
            font-weight: 500;
            color: var(--text);
            margin-bottom: 0.25rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .bookmark-url {
            font-size: 0.75rem;
            color: var(--text-muted);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .bookmark-url a {
            color: var(--accent);
            text-decoration: none;
        }

        .bookmark-url a:hover {
            text-decoration: underline;
        }

        .bookmark-meta {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-top: 0.25rem;
            font-style: italic;
        }

        .loading-text {
            text-align: center;
            color: var(--text-muted);
            padding: 1rem;
            font-size: 0.875rem;
        }

        .error-text {
            text-align: center;
            color: var(--danger);
            padding: 1rem;
            font-size: 0.875rem;
        }

        .empty-text {
            text-align: center;
            color: var(--text-muted);
            padding: 1rem;
            font-size: 0.875rem;
        }

        .refresh-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
        }

        .refresh-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-muted);
            padding: 0.4rem 0.75rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s;
        }

        .refresh-btn:hover {
            background: var(--bg-input);
            color: var(--text);
            border-color: var(--accent);
        }

        .refresh-btn.refreshing {
            cursor: not-allowed;
            opacity: 0.5;
        }

        .refresh-btn .refresh-icon {
            display: inline-block;
            transition: transform 0.3s;
        }

        .refresh-btn.refreshing .refresh-icon {
            animation: spin 1s linear infinite;
        }

        /* ===================================================================
           File Upload UI Styles
           ================================================================ */

        .file-upload-zone {
            border: 2px dashed var(--border);
            border-radius: 8px;
            padding: 2rem;
            text-align: center;
            background: var(--bg-input);
            transition: all 0.2s;
            cursor: pointer;
            margin-top: 1rem;
        }

        .file-upload-zone:hover,
        .file-upload-zone.drag-over {
            border-color: var(--accent);
            background: var(--bg-card-hover);
        }

        .file-upload-zone input[type="file"] {
            display: none;
        }

        .file-upload-icon {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            opacity: 0.6;
        }

        .file-upload-text {
            color: var(--text);
            font-size: 1rem;
            margin-bottom: 0.25rem;
        }

        .file-upload-hint {
            color: var(--text-muted);
            font-size: 0.875rem;
        }

        .file-selected {
            display: flex;
            align-items: center;
            gap: 1rem;
            background: var(--bg-card-hover);
            padding: 1rem;
            border-radius: 8px;
            margin-top: 1rem;
        }

        .file-selected.hidden {
            display: none;
        }

        .file-icon {
            font-size: 2rem;
            flex-shrink: 0;
        }

        .file-info {
            flex: 1;
            min-width: 0;
        }

        .file-name {
            font-weight: 500;
            color: var(--text);
            margin-bottom: 0.25rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .file-meta {
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .file-clear-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-muted);
            padding: 0.4rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
            flex-shrink: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .file-clear-btn:hover {
            background: var(--danger);
            color: white;
            border-color: var(--danger);
        }

        .divider {
            display: flex;
            align-items: center;
            text-align: center;
            color: var(--text-muted);
            font-size: 0.875rem;
            margin: 1rem 0;
        }

        .divider::before,
        .divider::after {
            content: '';
            flex: 1;
            border-bottom: 1px solid var(--border);
        }

        .divider span {
            padding: 0 1rem;
        }

        /* ===================================================================
           Background Sync Queue UI Styles
           ================================================================ */

        /* Queue Status Header */
        .queue-status {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-left: 4px solid var(--accent);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .queue-status.hidden {
            display: none;
        }

        .queue-icon {
            font-size: 1.25rem;
            flex-shrink: 0;
        }

        .queue-text {
            flex: 1;
            font-size: 0.875rem;
            color: var(--text);
        }

        .queue-dismiss {
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 0.25rem;
            width: auto;
            min-width: unset;
            transition: color 0.2s;
        }

        .queue-dismiss:hover {
            color: var(--text);
        }

        /* Queue Badge on Submit Button */
        button[type="submit"] {
            position: relative;
        }

        .queue-badge {
            position: absolute;
            top: -8px;
            right: -8px;
            background: var(--accent);
            color: white;
            border-radius: 12px;
            padding: 2px 8px;
            font-size: 0.75rem;
            font-weight: 600;
            min-width: 20px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .queue-badge.hidden {
            display: none;
        }

        /* Bookmark Status Badges */
        .bookmark-status {
            display: inline-block;
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 500;
            margin-left: 0.5rem;
            vertical-align: middle;
        }

        .status-queued {
            background: var(--bg-input);
            color: var(--text-muted);
            border: 1px solid var(--border);
        }

        .status-syncing {
            background: var(--accent);
            color: white;
            animation: pulse 1.5s infinite;
        }

        .status-failed {
            background: var(--danger);
            color: white;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Skeleton Loader */
        .skeleton-item {
            background: var(--bg-input);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            display: flex;
            gap: 0.75rem;
            align-items: flex-start;
        }

        .skeleton-content {
            flex: 1;
            min-width: 0;
        }

        .skeleton-line {
            background: linear-gradient(
                90deg,
                var(--border) 25%,
                var(--bg-card-hover) 50%,
                var(--border) 75%
            );
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            border-radius: 4px;
            height: 1rem;
            margin-bottom: 0.5rem;
        }

        .skeleton-line:last-child {
            margin-bottom: 0;
        }

        .skeleton-line.short {
            width: 60%;
        }

        .skeleton-line.medium {
            width: 80%;
        }

        .skeleton-line.tiny {
            width: 40%;
            height: 0.7rem;
        }

        .skeleton-button {
            width: 28px;
            height: 28px;
            background: var(--border);
            border-radius: 4px;
            flex-shrink: 0;
        }

        @keyframes shimmer {
            0% {
                background-position: 200% 0;
            }
            100% {
                background-position: -200% 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="index.html" class="back-link">&larr; Tools</a>
            <h1>Raindrop Quick Add</h1>
            <p class="subtitle">Add bookmarks to your Raindrop.io collection</p>
        </header>

        <!-- Queue Status Header -->
        <div id="queueStatus" class="queue-status hidden">
            <span class="queue-icon">‚è≥</span>
            <span class="queue-text"><span id="queueCount">0</span> bookmark(s) queued</span>
            <button type="button" class="queue-dismiss" onclick="dismissQueueHeader()">‚úï</button>
        </div>

        <!-- Settings Section -->
        <div class="settings-section">
            <div class="settings-toggle" id="settingsToggle" role="button" tabindex="0" aria-expanded="false" aria-controls="settingsContent">
                <div class="settings-toggle-text">
                    <span style="font-weight: 500;">Settings</span>
                    <span class="settings-status" id="settingsStatus">Not configured</span>
                </div>
                <span class="chevron" aria-hidden="true">‚ñº</span>
            </div>
            <div class="settings-content" id="settingsContent">
                <div class="settings-card">
                    <h2>Access Token</h2>
                    <div class="form-group">
                        <label for="accessToken">Bearer Token</label>
                        <input
                            type="password"
                            id="accessToken"
                            placeholder="Enter your Raindrop.io access token"
                            aria-describedby="tokenHelp"
                        >
                        <p class="help-text" id="tokenHelp">
                            Get your access token from
                            <a href="https://app.raindrop.io/settings/integrations" target="_blank" rel="noopener noreferrer">
                                Raindrop.io Settings ‚Üí Apps
                            </a>
                            (create a test token)
                        </p>
                    </div>
                    <div class="button-group">
                        <button type="button" class="secondary" onclick="clearToken()">Clear</button>
                        <button type="button" onclick="saveToken()">Save Token</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Input Card -->
        <div class="card">
            <form onsubmit="handleSubmit(event)" id="bookmarkForm">
                <div class="form-group">
                    <label for="urlInput">URL</label>
                    <input
                        type="url"
                        id="urlInput"
                        placeholder="https://example.com"
                        aria-describedby="urlHelp"
                    >
                    <p class="help-text" id="urlHelp">
                        Enter a URL to add to your Unsorted collection. Raindrop will automatically parse the page metadata.
                    </p>
                </div>

                <div class="divider">
                    <span>OR</span>
                </div>

                <!-- File Upload Zone -->
                <div class="file-upload-zone" id="fileUploadZone" onclick="document.getElementById('fileInput').click()">
                    <input type="file" id="fileInput" accept="image/*,video/*,audio/*,application/pdf,application/zip,application/x-rar-compressed,application/msword,application/vnd.openxmlformats-officedocument.wordprocessingml.document,application/vnd.ms-excel,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,application/vnd.ms-powerpoint,application/vnd.openxmlformats-officedocument.presentationml.presentation,text/*">
                    <div class="file-upload-icon">üìÅ</div>
                    <div class="file-upload-text">Click or drag to upload a file</div>
                    <div class="file-upload-hint">Images, videos, PDFs, documents, and more</div>
                </div>

                <!-- Selected File Info -->
                <div id="fileSelected" class="file-selected hidden">
                    <div class="file-icon" id="fileIcon">üìÑ</div>
                    <div class="file-info">
                        <div class="file-name" id="fileName">filename.pdf</div>
                        <div class="file-meta" id="fileMeta">1.2 MB</div>
                    </div>
                    <button type="button" class="file-clear-btn" onclick="clearFile()" title="Clear file" aria-label="Clear selected file">‚úï</button>
                </div>

                <button type="submit" id="submitBtn" disabled>
                    Add to Raindrop
                    <span id="queueBadge" class="queue-badge hidden">0</span>
                </button>
            </form>
        </div>

        <!-- Recent Bookmarks Card -->
        <div class="card recent-bookmarks">
            <div class="refresh-header">
                <h2>Recent Bookmarks</h2>
                <button type="button" class="refresh-btn" id="refreshBtn" onclick="loadRecentBookmarks()">
                    <span class="refresh-icon">‚Üª</span> Refresh
                </button>
            </div>
            <div id="bookmarksList">
                <div class="loading-text">Loading...</div>
            </div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast hidden" role="status" aria-live="polite" aria-atomic="true">
        <span class="toast-icon"></span>
        <span class="toast-message"></span>
    </div>

    <!-- Screen reader announcer -->
    <div class="sr-only" aria-live="polite" aria-atomic="true" id="announcer"></div>

    <script>
        // Constants
        const RAINDROP_API_BASE = 'https://api.raindrop.io/rest/v1';
        const UNSORTED_COLLECTION_ID = -1;
        const STORAGE_KEY_TOKEN = 'raindrop-access-token';

        // State
        const state = {
            accessToken: null,
            isSubmitting: false,
            isLoadingBookmarks: false,
            queueCount: 0,
            isSyncing: false,
            supportsBackgroundSync: false,
            selectedFile: null
        };

        // DOM Elements
        const elements = {
            settingsToggle: document.getElementById('settingsToggle'),
            settingsContent: document.getElementById('settingsContent'),
            settingsStatus: document.getElementById('settingsStatus'),
            accessTokenInput: document.getElementById('accessToken'),
            urlInput: document.getElementById('urlInput'),
            submitBtn: document.getElementById('submitBtn'),
            bookmarkForm: document.getElementById('bookmarkForm'),
            toast: document.getElementById('toast'),
            toastIcon: document.querySelector('.toast-icon'),
            toastMessage: document.querySelector('.toast-message'),
            chevron: document.querySelector('.chevron'),
            announcer: document.getElementById('announcer'),
            bookmarksList: document.getElementById('bookmarksList'),
            refreshBtn: document.getElementById('refreshBtn'),
            fileInput: document.getElementById('fileInput'),
            fileUploadZone: document.getElementById('fileUploadZone'),
            fileSelected: document.getElementById('fileSelected'),
            fileName: document.getElementById('fileName'),
            fileMeta: document.getElementById('fileMeta'),
            fileIcon: document.getElementById('fileIcon')
        };

        // Initialize on page load
        function init() {
            // Check Background Sync support
            if ('serviceWorker' in navigator && 'sync' in ServiceWorkerRegistration.prototype) {
                state.supportsBackgroundSync = true;
                console.log('Background Sync API supported');
            } else {
                console.warn('Background Sync API not supported');
            }

            loadToken();
            updateUI();
            setupEventListeners();
            handleSharedContent();
            loadRecentBookmarks();

            // Update queue badge on load
            updateQueueBadge();

            // Setup service worker message listener
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.addEventListener('message', handleSyncMessage);
            }
        }

        // Handle shared content from share target
        async function handleSharedContent() {
            const urlParams = new URLSearchParams(window.location.search);

            // Check if this is a share from the service worker
            const isShared = urlParams.get('shared') === 'true';

            if (isShared) {
                // Get shared data from service worker cache
                try {
                    const cache = await caches.open('raindrop-share-data');
                    const response = await cache.match('share-data');

                    if (response) {
                        const sharedData = await response.json();

                        // Clear the cached data
                        await cache.delete('share-data');

                        // Clear URL parameters from address bar
                        if (window.history && window.history.replaceState) {
                            window.history.replaceState({}, document.title, window.location.pathname);
                        }

                        // Handle shared file
                        if (sharedData.file) {
                            await handleSharedFile(sharedData);
                            return;
                        }

                        // Handle shared URL
                        const sharedUrl = sharedData.url || sharedData.text;
                        if (sharedUrl) {
                            await handleSharedUrl(sharedUrl, sharedData.title);
                            return;
                        }
                    }
                } catch (error) {
                    console.error('Failed to retrieve shared data:', error);
                    showToast('Failed to process shared content', 'error');
                }
                return;
            }

            // Fallback: Handle legacy GET parameters (backward compatibility)
            const sharedUrl = urlParams.get('url') || urlParams.get('text');
            const sharedTitle = urlParams.get('title');

            if (sharedUrl) {
                // Clear URL parameters from address bar for cleaner UX
                if (window.history && window.history.replaceState) {
                    window.history.replaceState({}, document.title, window.location.pathname);
                }

                await handleSharedUrl(sharedUrl, sharedTitle);
            }
        }

        // Handle shared URL
        async function handleSharedUrl(url, title) {
            // Validate that it's a URL
            try {
                new URL(url);
                elements.urlInput.value = url;

                // Auto-submit if token is configured, otherwise prompt for token
                if (state.accessToken) {
                    // Show notification
                    const message = title
                        ? `Adding: ${title}`
                        : 'Adding bookmark...';
                    showToast(message, 'success', 2000);

                    // Automatically add the bookmark
                    await addBookmark(url);
                } else {
                    // Show notification
                    const message = title
                        ? `Ready to add: ${title}`
                        : 'URL received from share';
                    showToast(message, 'success', 3000);

                    showToast('Please configure your access token first', 'error');
                    toggleSettings();
                }
            } catch (error) {
                console.log('Shared content is not a valid URL:', url);
                // If not a valid URL, still put it in the field - user might want to edit it
                elements.urlInput.value = url;
                elements.urlInput.focus();
            }
        }

        // Handle shared file
        async function handleSharedFile(sharedData) {
            const fileInfo = sharedData.file;

            // Show notification
            showToast(`Processing file: ${fileInfo.name}`, 'success', 2000);

            // Check if token is configured
            if (!state.accessToken) {
                showToast('Please configure your access token first', 'error');
                toggleSettings();
                return;
            }

            try {
                // Reconstruct the File object from the cached data
                const blob = new Blob([fileInfo.blob], { type: fileInfo.type });
                const file = new File([blob], fileInfo.name, { type: fileInfo.type });

                // Upload the file
                await uploadFile(file);

            } catch (error) {
                console.error('Failed to process shared file:', error);
                showToast('Failed to upload file: ' + error.message, 'error');
            }
        }

        // Event Listeners
        function setupEventListeners() {
            // Settings toggle
            elements.settingsToggle.addEventListener('click', toggleSettings);
            elements.settingsToggle.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    toggleSettings();
                }
            });

            // Auto-save token on blur
            elements.accessTokenInput.addEventListener('blur', () => {
                const value = elements.accessTokenInput.value.trim();
                if (value && value !== state.accessToken) {
                    saveToken();
                }
            });

            // Clear file when URL input is focused/changed
            elements.urlInput.addEventListener('input', () => {
                if (state.selectedFile && elements.urlInput.value.trim()) {
                    clearFile();
                }
            });

            // File input change
            elements.fileInput.addEventListener('change', handleFileSelect);

            // Drag and drop
            elements.fileUploadZone.addEventListener('dragover', handleDragOver);
            elements.fileUploadZone.addEventListener('dragleave', handleDragLeave);
            elements.fileUploadZone.addEventListener('drop', handleFileDrop);

            // Prevent default drag behavior on document
            document.addEventListener('dragover', (e) => e.preventDefault());
            document.addEventListener('drop', (e) => e.preventDefault());
        }

        // Settings Toggle
        function toggleSettings() {
            const isExpanded = elements.settingsContent.classList.contains('expanded');

            if (isExpanded) {
                elements.settingsContent.classList.remove('expanded');
                elements.chevron.classList.remove('expanded');
                elements.settingsToggle.setAttribute('aria-expanded', 'false');
            } else {
                elements.settingsContent.classList.add('expanded');
                elements.chevron.classList.add('expanded');
                elements.settingsToggle.setAttribute('aria-expanded', 'true');
                elements.accessTokenInput.focus();
            }
        }

        // LocalStorage Functions
        function loadToken() {
            try {
                const token = localStorage.getItem(STORAGE_KEY_TOKEN);
                if (token && token.trim().length > 0) {
                    state.accessToken = token.trim();
                    elements.accessTokenInput.value = token.trim();
                    return true;
                }
            } catch (error) {
                console.error('Failed to load access token:', error);
            }
            return false;
        }

        function saveToken() {
            try {
                const token = elements.accessTokenInput.value.trim();

                if (!token) {
                    showToast('Please enter an access token', 'error');
                    return false;
                }

                localStorage.setItem(STORAGE_KEY_TOKEN, token);
                state.accessToken = token;

                showToast('Access token saved successfully', 'success');
                updateUI();

                // Collapse settings after saving
                setTimeout(() => {
                    if (elements.settingsContent.classList.contains('expanded')) {
                        toggleSettings();
                    }
                }, 1000);

                return true;
            } catch (error) {
                console.error('Failed to save access token:', error);
                showToast('Failed to save token: ' + error.message, 'error');
                return false;
            }
        }

        function clearToken() {
            try {
                localStorage.removeItem(STORAGE_KEY_TOKEN);
                state.accessToken = null;
                elements.accessTokenInput.value = '';

                showToast('Access token cleared', 'success');
                updateUI();
            } catch (error) {
                console.error('Failed to clear token:', error);
                showToast('Failed to clear token', 'error');
            }
        }

        // UI Updates
        function updateUI() {
            const hasToken = state.accessToken !== null;

            // Update submit button state
            elements.submitBtn.disabled = !hasToken;

            // Update settings status
            if (hasToken) {
                elements.settingsStatus.textContent = 'Configured';
                elements.settingsStatus.classList.add('configured');
            } else {
                elements.settingsStatus.textContent = 'Not configured';
                elements.settingsStatus.classList.remove('configured');
            }
        }

        // File handling functions
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                displaySelectedFile(file);
            }
        }

        function handleDragOver(event) {
            event.preventDefault();
            event.stopPropagation();
            elements.fileUploadZone.classList.add('drag-over');
        }

        function handleDragLeave(event) {
            event.preventDefault();
            event.stopPropagation();
            elements.fileUploadZone.classList.remove('drag-over');
        }

        function handleFileDrop(event) {
            event.preventDefault();
            event.stopPropagation();
            elements.fileUploadZone.classList.remove('drag-over');

            const file = event.dataTransfer.files[0];
            if (file) {
                displaySelectedFile(file);
            }
        }

        function displaySelectedFile(file) {
            state.selectedFile = file;

            // Update file info display
            elements.fileName.textContent = file.name;
            elements.fileMeta.textContent = formatFileSize(file.size) + ' ‚Ä¢ ' + file.type.split('/')[0];

            // Set appropriate icon based on file type
            const fileType = file.type.split('/')[0];
            const iconMap = {
                'image': 'üñºÔ∏è',
                'video': 'üé•',
                'audio': 'üéµ',
                'text': 'üìù',
                'application': 'üìÑ'
            };
            elements.fileIcon.textContent = iconMap[fileType] || 'üìÑ';

            // Show file selected, hide upload zone
            elements.fileSelected.classList.remove('hidden');
            elements.fileUploadZone.style.display = 'none';

            // Clear URL input
            elements.urlInput.value = '';

            // Update button text
            updateSubmitButton();
        }

        function clearFile() {
            state.selectedFile = null;
            elements.fileInput.value = '';
            elements.fileSelected.classList.add('hidden');
            elements.fileUploadZone.style.display = 'block';

            // Update button text
            updateSubmitButton();
        }

        function updateSubmitButton() {
            const queueBadge = document.getElementById('queueBadge');
            const badgeHtml = queueBadge ? queueBadge.outerHTML : '';

            if (state.selectedFile) {
                elements.submitBtn.innerHTML = 'Upload File' + badgeHtml;
            } else {
                elements.submitBtn.innerHTML = 'Add to Raindrop' + badgeHtml;
            }
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Form Submission
        async function handleSubmit(event) {
            event.preventDefault();

            if (state.isSubmitting) return;

            if (!state.accessToken) {
                showToast('Please configure your access token first', 'error');
                toggleSettings();
                return;
            }

            // Check if file is selected
            if (state.selectedFile) {
                await uploadFile(state.selectedFile);
                clearFile();
                return;
            }

            // Otherwise, handle URL
            const url = elements.urlInput.value.trim();

            // Check if URL is provided
            if (!url) {
                showToast('Please enter a URL or select a file to upload', 'error');
                elements.urlInput.focus();
                return;
            }

            // Validate URL
            try {
                new URL(url);
            } catch (error) {
                showToast('Please enter a valid URL', 'error');
                elements.urlInput.focus();
                return;
            }

            // Add bookmark
            await addBookmark(url);
        }

        // Raindrop API
        async function addBookmark(url) {
            state.isSubmitting = true;

            // Show loading state
            const originalText = elements.submitBtn.innerHTML;
            elements.submitBtn.innerHTML = '<span class="spinner"></span>Adding...';
            elements.submitBtn.disabled = true;

            try {
                const response = await fetch(`${RAINDROP_API_BASE}/raindrop`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${state.accessToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        link: url,
                        collection: { $id: UNSORTED_COLLECTION_ID },
                        pleaseParse: {}
                    })
                });

                if (!response.ok) {
                    await handleApiError(response);
                    return;
                }

                const data = await response.json();
                const title = data.item?.title || url;

                showToast(`Bookmark added: ${title}`, 'success');
                announce(`Bookmark added successfully: ${title}`);

                // Clear input and focus
                elements.urlInput.value = '';
                elements.urlInput.focus();

                // Reload recent bookmarks to show the new one
                loadRecentBookmarks();

            } catch (error) {
                console.error('Failed to add bookmark:', error);

                // Network error - queue for background sync
                if (error.message.includes('Failed to fetch') || !navigator.onLine) {
                    try {
                        await queueBookmarkForSync(url);
                    } catch (queueError) {
                        console.error('Failed to queue bookmark:', queueError);
                        showToast('Failed to add or queue bookmark', 'error');
                    }
                } else {
                    showToast('Failed to add bookmark: ' + error.message, 'error');
                }
            } finally {
                state.isSubmitting = false;
                updateSubmitButton();
                elements.submitBtn.disabled = !state.accessToken;
            }
        }

        // File Upload to Raindrop
        async function uploadFile(file) {
            state.isSubmitting = true;

            // Show loading state
            const originalText = elements.submitBtn.innerHTML;
            elements.submitBtn.innerHTML = '<span class="spinner"></span>Uploading...';
            elements.submitBtn.disabled = true;

            try {
                // Prepare multipart form data
                const formData = new FormData();
                formData.append('file', file);
                formData.append('collectionId', UNSORTED_COLLECTION_ID.toString());

                const response = await fetch(`${RAINDROP_API_BASE}/raindrop/file`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${state.accessToken}`
                    },
                    body: formData
                });

                if (!response.ok) {
                    await handleFileUploadError(response);
                    return;
                }

                const data = await response.json();
                const title = data.item?.title || file.name;

                showToast(`File uploaded: ${title}`, 'success');
                announce(`File uploaded successfully: ${title}`);

                // Reload recent bookmarks to show the new file
                loadRecentBookmarks();

            } catch (error) {
                console.error('Failed to upload file:', error);

                // Network error - queue for background sync
                if (error.message.includes('Failed to fetch') || !navigator.onLine) {
                    showToast('File upload failed - offline queueing not yet supported for files', 'error');
                } else {
                    showToast('Failed to upload file: ' + error.message, 'error');
                }
            } finally {
                state.isSubmitting = false;
                updateSubmitButton();
                elements.submitBtn.disabled = !state.accessToken;
            }
        }

        // File Upload Error Handling
        async function handleFileUploadError(response) {
            let errorMessage = 'Failed to upload file';

            try {
                const errorData = await response.json();

                // Handle specific error codes from Raindrop API
                if (errorData.error === -1 || errorData.errorMessage === 'no file') {
                    errorMessage = 'No file provided';
                } else if (errorData.error === 'file_invalid') {
                    errorMessage = 'File format not supported';
                } else if (errorData.error === 'file_size_limit') {
                    errorMessage = 'File size exceeds limit';
                } else {
                    errorMessage = errorData.errorMessage || errorData.message || errorMessage;
                }
            } catch (e) {
                // Use status-based messages if JSON parsing fails
            }

            switch (response.status) {
                case 401:
                    errorMessage = 'Invalid token. Please check your access token.';
                    if (!elements.settingsContent.classList.contains('expanded')) {
                        toggleSettings();
                    }
                    break;
                case 429:
                    errorMessage = 'Rate limit exceeded. Wait a moment and try again.';
                    break;
                case 500:
                case 502:
                case 503:
                    errorMessage = 'Raindrop service error. Please try again later.';
                    break;
            }

            showToast(errorMessage, 'error');
            announce(errorMessage);
        }

        // API Error Handling
        async function handleApiError(response) {
            let errorMessage = 'Failed to add bookmark';

            try {
                const errorData = await response.json();
                errorMessage = errorData.errorMessage || errorData.message || errorMessage;
            } catch (e) {
                // Use status-based messages if JSON parsing fails
            }

            switch (response.status) {
                case 401:
                    errorMessage = 'Invalid token. Please check your access token.';
                    // Show settings
                    if (!elements.settingsContent.classList.contains('expanded')) {
                        toggleSettings();
                    }
                    break;
                case 400:
                    errorMessage = errorMessage || 'Invalid URL or request.';
                    break;
                case 429:
                    errorMessage = 'Rate limit exceeded. Wait a moment and try again.';
                    break;
                case 500:
                case 502:
                case 503:
                    errorMessage = 'Raindrop service error. Please try again later.';
                    break;
            }

            showToast(errorMessage, 'error');
            announce(errorMessage);
        }

        // Generate skeleton loader HTML
        function generateSkeletonLoader() {
            const skeletons = Array(5).fill(0).map(() => `
                <div class="skeleton-item">
                    <div class="skeleton-content">
                        <div class="skeleton-line medium"></div>
                        <div class="skeleton-line short"></div>
                        <div class="skeleton-line tiny"></div>
                    </div>
                    <div class="skeleton-button"></div>
                </div>
            `).join('');
            return skeletons;
        }

        // Load Recent Bookmarks
        async function loadRecentBookmarks() {
            if (!state.accessToken) {
                elements.bookmarksList.innerHTML = '<div class="empty-text">Configure your access token to view recent bookmarks</div>';
                return;
            }

            if (state.isLoadingBookmarks) return;

            state.isLoadingBookmarks = true;
            elements.refreshBtn.classList.add('refreshing');
            elements.refreshBtn.disabled = true;

            // Show skeleton loader
            elements.bookmarksList.innerHTML = generateSkeletonLoader();

            try {
                // Fetch from API
                const response = await fetch(
                    `${RAINDROP_API_BASE}/raindrops/${UNSORTED_COLLECTION_ID}?perpage=5&sort=-created`,
                    {
                        headers: {
                            'Authorization': `Bearer ${state.accessToken}`
                        }
                    }
                );

                if (!response.ok) {
                    if (response.status === 401) {
                        elements.bookmarksList.innerHTML = '<div class="error-text">Invalid token. Please check your access token.</div>';
                    } else {
                        elements.bookmarksList.innerHTML = '<div class="error-text">Failed to load bookmarks</div>';
                    }
                    return;
                }

                const data = await response.json();
                const apiBookmarks = data.items || [];

                // Get queued items
                const queuedItems = await getQueuedItems();

                // Combine and render
                const allBookmarks = [
                    ...queuedItems.map(item => ({
                        _id: `queue-${item.id}`,
                        title: item.url,
                        link: item.url,
                        isQueued: true,
                        queueId: item.id,
                        status: item.status,
                        lastError: item.lastError
                    })),
                    ...apiBookmarks
                ];

                if (allBookmarks.length === 0) {
                    elements.bookmarksList.innerHTML = '<div class="empty-text">No bookmarks yet. Add one above!</div>';
                    return;
                }

                // Render bookmarks with status badges
                elements.bookmarksList.innerHTML = allBookmarks.map(bookmark => {
                    const title = bookmark.title || bookmark.link || 'Untitled';
                    const url = bookmark.link;
                    const id = bookmark._id;

                    let statusBadge = '';
                    let deleteBtn = '';
                    let metaInfo = '';

                    if (bookmark.isQueued) {
                        // Queued bookmark
                        const queueId = bookmark.queueId;

                        if (bookmark.status === 'pending') {
                            statusBadge = '<span class="bookmark-status status-queued">‚è≥ Queued</span>';
                        } else if (bookmark.status === 'syncing') {
                            statusBadge = '<span class="bookmark-status status-syncing">‚ü≥ Syncing...</span>';
                        } else if (bookmark.status === 'failed') {
                            statusBadge = '<span class="bookmark-status status-failed">‚ö† Failed</span>';
                        }

                        deleteBtn = `
                            <button
                                class="bookmark-delete-btn"
                                onclick="removeQueuedBookmark(${queueId})"
                                title="Remove from queue"
                                aria-label="Remove from queue: ${escapeHtml(title)}"
                            >üóëÔ∏è</button>
                        `;
                    } else {
                        // Regular bookmark
                        const hasMetadata = bookmark.title && bookmark.title !== url;
                        metaInfo = `<div class="bookmark-meta">${hasMetadata ? 'Metadata loaded' : 'Waiting for metadata...'}</div>`;

                        deleteBtn = `
                            <button
                                class="bookmark-delete-btn"
                                onclick="deleteBookmark(${id}, '${escapeHtml(title).replace(/'/g, "\\'")}')"
                                title="Delete bookmark"
                                aria-label="Delete bookmark: ${escapeHtml(title)}"
                            >üóëÔ∏è</button>
                        `;
                    }

                    return `
                        <div class="bookmark-item">
                            <div class="bookmark-content">
                                <div class="bookmark-title">${escapeHtml(title)}${statusBadge}</div>
                                <div class="bookmark-url">
                                    <a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer">${escapeHtml(url)}</a>
                                </div>
                                ${metaInfo}
                            </div>
                            ${deleteBtn}
                        </div>
                    `;
                }).join('');

            } catch (error) {
                console.error('Failed to load bookmarks:', error);
                elements.bookmarksList.innerHTML = '<div class="error-text">Network error. Check your connection.</div>';
            } finally {
                state.isLoadingBookmarks = false;
                elements.refreshBtn.classList.remove('refreshing');
                elements.refreshBtn.disabled = false;
            }
        }

        // Delete Bookmark
        async function deleteBookmark(id, title) {
            // Confirmation dialog
            const confirmMessage = `Delete "${title}"?\n\nThis will move it to Trash.`;
            if (!confirm(confirmMessage)) {
                return;
            }

            try {
                const response = await fetch(`${RAINDROP_API_BASE}/raindrop/${id}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${state.accessToken}`
                    }
                });

                if (!response.ok) {
                    if (response.status === 401) {
                        showToast('Invalid token. Please check your access token.', 'error');
                    } else {
                        showToast('Failed to delete bookmark', 'error');
                    }
                    return;
                }

                showToast('Bookmark moved to trash', 'success');
                announce('Bookmark deleted successfully');

                // Reload the list
                loadRecentBookmarks();

            } catch (error) {
                console.error('Failed to delete bookmark:', error);
                showToast('Network error. Check your connection.', 'error');
            }
        }

        // HTML escape helper
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Toast Notification
        function showToast(message, type = 'success', duration = 4000) {
            // Update toast content
            elements.toastMessage.textContent = message;

            // Set icon based on type
            elements.toastIcon.textContent = type === 'success' ? '‚úì' : '‚úï';

            // Update toast class
            elements.toast.classList.remove('success', 'error');
            elements.toast.classList.add(type);

            // Show toast
            elements.toast.classList.remove('hidden');

            // Auto-hide after duration
            setTimeout(() => {
                elements.toast.classList.add('hidden');
            }, duration);
        }

        // Screen Reader Announcements
        function announce(message) {
            elements.announcer.textContent = message;
            setTimeout(() => {
                elements.announcer.textContent = '';
            }, 1000);
        }

        // ============================================================================
        // Background Sync - IndexedDB Queue Management
        // ============================================================================

        const DB_NAME = 'raindrop-sync-queue';
        const STORE_NAME = 'pending-bookmarks';

        // Open IndexedDB database
        async function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, 1);

                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        const store = db.createObjectStore(STORE_NAME, {
                            keyPath: 'id',
                            autoIncrement: true
                        });
                        store.createIndex('timestamp', 'timestamp', { unique: false });
                        store.createIndex('status', 'status', { unique: false });
                    }
                };
            });
        }

        // Add bookmark to queue
        async function addToQueue(url) {
            const db = await openDB();
            const tx = db.transaction(STORE_NAME, 'readwrite');
            const store = tx.objectStore(STORE_NAME);

            const item = {
                url,
                timestamp: Date.now(),
                status: 'pending',
                retryCount: 0,
                lastError: null,
                createdAt: new Date().toISOString()
            };

            return new Promise((resolve, reject) => {
                const request = store.add(item);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        // Get all queued items
        async function getQueuedItems() {
            try {
                const db = await openDB();
                const tx = db.transaction(STORE_NAME, 'readonly');
                const store = tx.objectStore(STORE_NAME);

                return new Promise((resolve, reject) => {
                    const request = store.getAll();
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => reject(request.error);
                });
            } catch (error) {
                console.error('Failed to get queued items:', error);
                return [];
            }
        }

        // Update queue item
        async function updateQueueItem(id, updates) {
            const db = await openDB();
            const tx = db.transaction(STORE_NAME, 'readwrite');
            const store = tx.objectStore(STORE_NAME);

            return new Promise((resolve, reject) => {
                const getRequest = store.get(id);
                getRequest.onsuccess = () => {
                    const item = { ...getRequest.result, ...updates };
                    const updateRequest = store.put(item);
                    updateRequest.onsuccess = () => resolve();
                    updateRequest.onerror = () => reject(updateRequest.error);
                };
                getRequest.onerror = () => reject(getRequest.error);
            });
        }

        // Remove from queue
        async function removeFromQueue(id) {
            const db = await openDB();
            const tx = db.transaction(STORE_NAME, 'readwrite');
            const store = tx.objectStore(STORE_NAME);

            return new Promise((resolve, reject) => {
                const request = store.delete(id);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        // Get count of pending items
        async function getQueueCount() {
            const items = await getQueuedItems();
            return items.filter(item => item.status === 'pending' || item.status === 'syncing').length;
        }

        // Queue bookmark for sync
        async function queueBookmarkForSync(url) {
            if (!state.supportsBackgroundSync) {
                showToast('Background sync not supported - please try again when online', 'error');
                return;
            }

            try {
                // Add to queue
                await addToQueue(url);

                // Register background sync
                const registration = await navigator.serviceWorker.ready;
                await registration.sync.register('sync-bookmarks');

                // Update UI
                await updateQueueBadge();
                showToast('Bookmark queued - will sync when online', 'success');

                elements.urlInput.value = '';
                elements.urlInput.focus();

                // Reload to show queued item
                await loadRecentBookmarks();

            } catch (error) {
                console.error('Failed to queue bookmark:', error);
                throw error;
            }
        }

        // Handle messages from service worker
        function handleSyncMessage(event) {
            const { type, url } = event.data;

            switch (type) {
                case 'GET_ACCESS_TOKEN':
                    // Respond with access token
                    event.ports[0].postMessage({ token: state.accessToken });
                    break;

                case 'SYNC_SUCCESS':
                    showToast(`Synced: ${url}`, 'success');
                    updateQueueBadge();
                    loadRecentBookmarks();
                    break;

                case 'SYNC_AUTH_FAILED':
                    showToast('Sync failed: Invalid token. Please update your access token.', 'error');
                    if (!elements.settingsContent.classList.contains('expanded')) {
                        toggleSettings();
                    }
                    updateQueueBadge();
                    loadRecentBookmarks();
                    break;

                case 'SYNC_FAILED':
                    showToast('Some bookmarks failed to sync', 'error');
                    updateQueueBadge();
                    loadRecentBookmarks();
                    break;
            }
        }

        // Update queue badge display
        async function updateQueueBadge() {
            const count = await getQueueCount();
            state.queueCount = count;

            const badge = document.getElementById('queueBadge');
            const header = document.getElementById('queueStatus');
            const queueCountText = document.getElementById('queueCount');

            if (count > 0) {
                badge.textContent = count;
                badge.classList.remove('hidden');
                queueCountText.textContent = count;
                header.classList.remove('hidden');
            } else {
                badge.classList.add('hidden');
                header.classList.add('hidden');
            }
        }

        // Dismiss queue header
        function dismissQueueHeader() {
            document.getElementById('queueStatus').classList.add('hidden');
        }

        // Remove queued bookmark
        async function removeQueuedBookmark(id) {
            try {
                await removeFromQueue(parseInt(id));
                showToast('Removed from queue', 'success');
                await updateQueueBadge();
                await loadRecentBookmarks();
            } catch (error) {
                console.error('Failed to remove from queue:', error);
                showToast('Failed to remove from queue', 'error');
            }
        }

        // Service Worker Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('raindrop-quick-add-sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registered:', registration.scope);
                    })
                    .catch(error => {
                        console.log('ServiceWorker registration failed:', error);
                    });
            });
        }

        // Initialize app
        init();
    </script>
</body>
</html>
